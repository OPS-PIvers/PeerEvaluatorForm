# Implementation Plan: Work Product Observation

## 1. Overview

This document outlines the implementation plan for the "Work Product" feature. This feature introduces a new type of observation, initiated by a Peer Evaluator, which allows a staff member to answer a set of reflective questions. These answers are then visible to the Peer Evaluator within their observation view for analysis and feedback.

The primary goals are:
- To introduce the "Work Product" functionality without disrupting the existing observation workflow.
- To ensure the user experience is intuitive for both Peer Evaluators and staff members.
- To maintain the stability and reliability of the application.

## 2. Success Criteria

- **For Peer Evaluators:**
  - When a user with role `SPECIAL_ROLES.PEER_EVALUATOR` selects a staff member, they see two buttons: "Create Observation" and "Create Work Product".
  - Admin users (role `SPECIAL_ROLES.ADMINISTRATOR`) do not see the "Create Work Product" button.
  - Clicking "Create Work Product" initiates the standard observation creation flow.
  - When viewing a "Work Product" observation draft, the Peer Evaluator can see the staff member's answers to the questions dynamically load into the script editor.
- **For Staff Members:**
  - When a staff member opens the web app, the rubric loads as normal. If a peer evaluator has created a work product observation for this staff member, they see a "Work Product Questions" button.
  - This button is not present if a work product observation has not been created for the staff member by a Peer Evaluator (`SPECIAL_ROLES.PEER_EVALUATOR`).
  - Clicking the button opens a modal with a dynamic list of questions loaded from the `WorkProductQuestions` sheet.
  - Text entered into the fields is auto-saved.
  - The staff member can open and close the modal to see their previously saved answers.
- **System Stability:**
  - The existing observation creation and viewing process is unaffected.
  - No data loss or corruption occurs.
  - zero change for Administrator users (`SPECIAL_ROLES.ADMINISTRATOR`)
  - zero change for rubric rendering for staff members aside from conditionally displayed Work Product Questions button.
  - zero change for standard observation creation, editing, or finalization for Peer Evaluators (`SPECIAL_ROLES.PEER_EVALUATOR`).

## 3. Data Model Changes - Specific To-Do List

### Sheet Structure Updates
- [ ] **Add `Type` column to `Observation_Data` sheet**
  - Position: After existing columns, before any JSON fields
  - Default value: `"Standard"` for all existing rows
  - Data validation: Allow only `"Standard"` or `"Work Product"`

- [ ] **Create `WorkProductQuestions` sheet with exact structure:**
  - Column A: `QuestionID` (e.g., "WPQ1", "WPQ2")
  - Column B: `QuestionText` (e.g., "What was the goal of the work product?")
  - Column C: `Order` (numeric: 1, 2, 3...)
  - Add 5 sample questions for testing:
    - WPQ1: "What was the primary goal or objective of this work product?"
    - WPQ2: "What specific strategies or methods did you use to create this work product?"
    - WPQ3: "What challenges did you encounter and how did you address them?"
    - WPQ4: "How does this work product demonstrate your professional growth?"
    - WPQ5: "What would you do differently if you were to create this work product again?"

- [ ] **Create `WorkProductAnswers` sheet with exact structure:**
  - Column A: `AnswerID` (UUID generated by `Utilities.getUuid()`)
  - Column B: `ObservationID` (foreign key to Observation_Data)
  - Column C: `QuestionID` (foreign key to WorkProductQuestions)
  - Column D: `AnswerText` (staff member's response)

### Constants.js Updates
- [ ] **Add to `SHEET_NAMES` object at line 14:**
  ```javascript
  WORK_PRODUCT_QUESTIONS: 'WorkProductQuestions',
  WORK_PRODUCT_ANSWERS: 'WorkProductAnswers'
  ```

## 4. Backend Implementation - Specific To-Do List

### 4.1. ObservationService.js Updates

#### Modify Existing Function
- [ ] **Update `createNewObservation(observerEmail, observedEmail, observationType = 'Standard')` at line ~185**
  - Add third parameter with default value: `observationType = 'Standard'`
  - In the `newObservation` object creation, add: `Type: observationType`
  - Update the `_saveObservationToSheet()` call to include the Type column

#### Add 5 New Functions (Exact Signatures and Implementation Details)
- [ ] **Create `createWorkProductObservation(observerEmail, observedEmail)` after existing `createNewObservation()`:**
  ```javascript
  function createWorkProductObservation(observerEmail, observedEmail) {
    return createNewObservation(observerEmail, observedEmail, 'Work Product');
  }
  ```

- [ ] **Create `getObservationType(observationId)` after `getObservationById()`:**
  ```javascript
  function getObservationType(observationId) {
    try {
      const observations = _getObservationsDb();
      const observation = observations.find(obs => obs.observationId === observationId);
      return observation ? (observation.Type || 'Standard') : 'Standard';
    } catch (error) {
      console.error('Error getting observation type:', error);
      return 'Standard';
    }
  }
  ```

- [ ] **Create `getWorkProductQuestions()` after `getObservationType()`:**
  ```javascript
  function getWorkProductQuestions() {
    try {
      const cacheKey = 'work_product_questions';
      const cached = getCachedDataEnhanced(cacheKey);
      if (cached) return cached;

      const spreadsheet = openSpreadsheet();
      const sheet = getSheetByName(spreadsheet, SHEET_NAMES.WORK_PRODUCT_QUESTIONS);
      if (!sheet || sheet.getLastRow() < 2) return [];

      const values = sheet.getRange(2, 1, sheet.getLastRow() - 1, 3).getValues();
      const questions = values
        .filter(row => row[0]) // Filter out empty rows
        .map(row => ({
          questionId: row[0],
          questionText: row[1],
          order: row[2] || 0
        }))
        .sort((a, b) => a.order - b.order);

      setCachedDataEnhanced(cacheKey, questions);
      return questions;
    } catch (error) {
      console.error('Error getting work product questions:', error);
      return [];
    }
  }
  ```

- [ ] **Create `saveWorkProductAnswer(observationId, questionId, answerText)` after `getWorkProductQuestions()`:**
  ```javascript
  function saveWorkProductAnswer(observationId, questionId, answerText) {
    try {
      const spreadsheet = openSpreadsheet();
      const sheet = getSheetByName(spreadsheet, SHEET_NAMES.WORK_PRODUCT_ANSWERS);
      if (!sheet) {
        console.error('WorkProductAnswers sheet not found');
        return false;
      }

      // Find existing answer
      const values = sheet.getDataRange().getValues();
      const headers = values[0];
      const dataRows = values.slice(1);

      const existingRowIndex = dataRows.findIndex(row =>
        row[1] === observationId && row[2] === questionId
      );

      if (existingRowIndex !== -1) {
        // Update existing answer
        sheet.getRange(existingRowIndex + 2, 4).setValue(answerText);
      } else {
        // Create new answer
        const newRow = [
          Utilities.getUuid(),
          observationId,
          questionId,
          answerText
        ];
        sheet.appendRow(newRow);
      }

      return true;
    } catch (error) {
      console.error('Error saving work product answer:', error);
      return false;
    }
  }
  ```

- [ ] **Create `getWorkProductAnswers(observationId)` after `saveWorkProductAnswer()`:**
  ```javascript
  function getWorkProductAnswers(observationId) {
    try {
      const spreadsheet = openSpreadsheet();
      const sheet = getSheetByName(spreadsheet, SHEET_NAMES.WORK_PRODUCT_ANSWERS);
      if (!sheet || sheet.getLastRow() < 2) return [];

      const values = sheet.getDataRange().getValues();
      const dataRows = values.slice(1);

      return dataRows
        .filter(row => row[1] === observationId) // Filter by ObservationID
        .map(row => ({
          questionId: row[2],
          answerText: row[3] || ''
        }));
    } catch (error) {
      console.error('Error getting work product answers:', error);
      return [];
    }
  }
  ```

- [ ] **Create `checkUserHasWorkProductObservation(userEmail)` after `getWorkProductAnswers()`:**
  ```javascript
  function checkUserHasWorkProductObservation(userEmail) {
    try {
      const observations = _getObservationsDb();
      return observations.some(obs =>
        obs.observedEmail === userEmail &&
        obs.Type === 'Work Product' &&
        obs.status === 'Draft'
      );
    } catch (error) {
      console.error('Error checking work product observation:', error);
      return false;
    }
  }
  ```

### 4.2. Code.js Updates - Add 4 New Endpoint Functions

- [ ] **Add `createWorkProductObservationForEvaluator(observedEmail)` after existing `createNewObservationForEvaluator()`:**
  ```javascript
  function createWorkProductObservationForEvaluator(observedEmail) {
    try {
      const userContext = createUserContext();

      if (userContext.role !== SPECIAL_ROLES.PEER_EVALUATOR) {
        return { success: false, error: ERROR_MESSAGES.PERMISSION_DENIED };
      }

      const newObservation = createWorkProductObservation(userContext.email, observedEmail);
      if (!newObservation) {
        return { success: false, error: 'Failed to create work product observation.' };
      }

      const rubricData = getRubricDataForEvaluator(observedEmail);
      if (!rubricData.success) {
        return rubricData;
      }

      return {
        success: true,
        observation: newObservation,
        rubricData: rubricData.rubricData,
        userContext: userContext
      };
    } catch (error) {
      console.error('Error in createWorkProductObservationForEvaluator:', error);
      return { success: false, error: 'An unexpected error occurred: ' + error.message };
    }
  }
  ```

- [ ] **Add `getWorkProductQuestionsForClient()` after the above function:**
  ```javascript
  function getWorkProductQuestionsForClient() {
    try {
      const questions = getWorkProductQuestions();
      return { success: true, questions: questions };
    } catch (error) {
      console.error('Error in getWorkProductQuestionsForClient:', error);
      return { success: false, error: 'Failed to load questions: ' + error.message };
    }
  }
  ```

- [ ] **Add `saveWorkProductAnswerFromClient(observationId, questionId, answerText)` after the above function:**
  ```javascript
  function saveWorkProductAnswerFromClient(observationId, questionId, answerText) {
    try {
      const userContext = createUserContext();

      // Verify user has access to this observation
      const observation = getObservationById(observationId);
      if (!observation || observation.observedEmail !== userContext.email) {
        return { success: false, error: 'Access denied to this observation.' };
      }

      const saved = saveWorkProductAnswer(observationId, questionId, answerText);
      return { success: saved };
    } catch (error) {
      console.error('Error in saveWorkProductAnswerFromClient:', error);
      return { success: false, error: 'Failed to save answer: ' + error.message };
    }
  }
  ```

- [ ] **Add `getWorkProductAnswersForClient(observationId)` after the above function:**
  ```javascript
  function getWorkProductAnswersForClient(observationId) {
    try {
      const userContext = createUserContext();

      // Verify user has access to this observation
      const observation = getObservationById(observationId);
      if (!observation) {
        return { success: false, error: 'Observation not found.' };
      }

      // Allow access for observed staff or peer evaluators
      if (observation.observedEmail !== userContext.email &&
          userContext.role !== SPECIAL_ROLES.PEER_EVALUATOR) {
        return { success: false, error: 'Access denied to this observation.' };
      }

      const answers = getWorkProductAnswers(observationId);
      return { success: true, answers: answers };
    } catch (error) {
      console.error('Error in getWorkProductAnswersForClient:', error);
      return { success: false, error: 'Failed to load answers: ' + error.message };
    }
  }
  ```

### 4.3. UiService.js Updates

- [ ] **Modify `createFilterSelectionInterface()` function around line 50:**
  - After the line where `userContext` is passed to template
  - Add: `templateData.showWorkProductButton = (userContext.role === SPECIAL_ROLES.PEER_EVALUATOR);`

- [ ] **Update `doGet()` function in Code.js around line 30:**
  - After user context creation but before serving rubric.html
  - Add this logic:
  ```javascript
  // Check if user has any Work Product observations
  let hasWorkProduct = false;
  if (userContext.role !== SPECIAL_ROLES.PEER_EVALUATOR) {
    hasWorkProduct = checkUserHasWorkProductObservation(userContext.email);
  }
  templateData.showWorkProductQuestionsButton = hasWorkProduct;
  ```

## 5. Frontend Implementation - Specific To-Do List

### 5.1. filter-interface.html Updates

#### Add Work Product Button Next to Existing "Start New Observation"
- [ ] **Find the line with "Start New Observation" action card** (around line 3200 in the `populateObservationsList` function)
- [ ] **Add immediately after the existing "Start New Observation" card:**
  ```html
  <? if (userContext.role === 'Peer Evaluator') { ?>
  <div class="action-card" onclick="handleNewWorkProductObservation('${safeObservedEmailJs}')">
    <span class="action-icon">📋</span>
    <div class="action-title">Create Work Product</div>
    <div class="action-desc">Request reflective responses from this staff member.</div>
  </div>
  <? } ?>
  ```

#### Add JavaScript Function for Work Product Creation
- [ ] **Add after existing `handleNewObservation()` function around line 3800:**
  ```javascript
  function handleNewWorkProductObservation(observedEmail) {
    console.log('Starting new work product observation for:', observedEmail);
    clearObservationState();
    showLoading('Creating work product observation...');
    google.script.run
      .withSuccessHandler(handleRubricData)
      .withFailureHandler(handleError)
      .createWorkProductObservationForEvaluator(observedEmail);
  }
  ```

#### Add Refresh Work Product Answers Section to Script Editor
- [ ] **Find the script editor section around line 2500-2600 (look for `<div id="scriptEditorContainer">`)**
- [ ] **Add after the script editor toolbar but before the quill editor div:**
  ```html
  <div id="workProductAnswersSection" style="display: none; margin-bottom: 15px;">
    <div style="background: #f0fdf4; border: 1px solid #86efac; border-radius: 6px; padding: 12px;">
      <h4 style="margin: 0 0 10px 0; color: #166534;">Staff Work Product Responses</h4>
      <button onclick="refreshWorkProductAnswers()" class="filter-btn" style="margin-bottom: 10px;">
        🔄 Refresh Staff Answers
      </button>
      <div id="workProductAnswersDisplay" style="font-size: 0.9rem; line-height: 1.4;"></div>
    </div>
  </div>
  ```

#### Add JavaScript Functions for Answer Display
- [ ] **Add these functions after the existing script editor functions around line 4500:**
  ```javascript
  function refreshWorkProductAnswers() {
    if (!currentObservationId) {
      showToast('No observation selected');
      return;
    }

    // Check if this is a work product observation
    if (!window.currentObservationType || window.currentObservationType !== 'Work Product') {
      return;
    }

    showLoading('Loading staff responses...');
    google.script.run
      .withSuccessHandler(displayWorkProductAnswers)
      .withFailureHandler(function(error) {
        hideLoading();
        console.error('Failed to load answers:', error);
        showToast('Failed to load staff responses');
      })
      .getWorkProductAnswersForClient(currentObservationId);
  }

  function displayWorkProductAnswers(result) {
    hideLoading();
    const container = document.getElementById('workProductAnswersDisplay');
    if (!container) return;

    if (!result.success) {
      container.innerHTML = '<p style="color: #dc2626;">Error loading answers: ' + result.error + '</p>';
      return;
    }

    if (!result.answers || result.answers.length === 0) {
      container.innerHTML = '<p style="color: #6b7280; font-style: italic;">No staff responses yet.</p>';
      return;
    }

    // Load questions to match with answers
    google.script.run
      .withSuccessHandler(function(questionsResult) {
        if (questionsResult.success) {
          displayAnswersWithQuestions(result.answers, questionsResult.questions);
        }
      })
      .getWorkProductQuestionsForClient();
  }

  function displayAnswersWithQuestions(answers, questions) {
    const container = document.getElementById('workProductAnswersDisplay');
    if (!container) return;

    let html = '';
    questions.forEach(question => {
      const answer = answers.find(a => a.questionId === question.questionId);
      const answerText = answer ? answer.answerText : 'No response yet';

      html += `
        <div style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 4px; border-left: 3px solid #10b981;">
          <strong style="color: #374151;">${question.questionText}</strong>
          <div style="margin-top: 5px; color: #6b7280; white-space: pre-wrap;">${answerText}</div>
        </div>
      `;
    });

    container.innerHTML = html;
  }

  // Show/hide work product answers section based on observation type
  function toggleWorkProductAnswersSection(show) {
    const section = document.getElementById('workProductAnswersSection');
    if (section) {
      section.style.display = show ? 'block' : 'none';
    }
  }
  ```

#### Update Existing Script Editor Loading Logic
- [ ] **Find the `handleRubricData` function around line 4000**
- [ ] **Add after the observation data is set:**
  ```javascript
  // Store observation type and show work product section if needed
  window.currentObservationType = result.observation?.Type || 'Standard';
  toggleWorkProductAnswersSection(window.currentObservationType === 'Work Product');

  // Auto-load answers for work product observations
  if (window.currentObservationType === 'Work Product') {
    setTimeout(refreshWorkProductAnswers, 1000);
  }
  ```

### 5.2. rubric.html Updates

#### Add Work Product Questions Button
- [ ] **Find the main content area around line 100-200 (after page title, before rubric content)**
- [ ] **Add conditional button:**
  ```html
  <? if (showWorkProductQuestionsButton) { ?>
  <div style="margin: 20px 0; text-align: center;">
    <button id="workProductQuestionsBtn" onclick="openWorkProductModal()"
            class="filter-btn" style="background: linear-gradient(135deg, #059669, #10b981); color: white; padding: 12px 24px; font-size: 1.1rem;">
      📋 Work Product Questions
    </button>
  </div>
  <? } ?>
  ```

#### Add Modal HTML Structure
- [ ] **Add before closing `</body>` tag:**
  ```html
  <!-- Work Product Questions Modal -->
  <div id="workProductModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;" onclick="closeWorkProductModalOnBackdrop(event)">
    <div style="position: relative; top: 5%; margin: 0 auto; width: 90%; max-width: 800px; background: white; border-radius: 8px; padding: 0; max-height: 85vh; overflow: hidden;" onclick="event.stopPropagation()">
      <div style="padding: 20px; border-bottom: 1px solid #e5e7eb; background: #f9fafb;">
        <h2 style="margin: 0; color: #374151;">Work Product Reflection Questions</h2>
        <p style="margin: 5px 0 0 0; color: #6b7280; font-size: 0.9rem;">Your responses are automatically saved as you type.</p>
      </div>
      <div id="questionsContainer" style="padding: 20px; overflow-y: auto; max-height: calc(85vh - 140px);"></div>
      <div style="padding: 15px 20px; border-top: 1px solid #e5e7eb; background: #f9fafb; text-align: right;">
        <button onclick="closeWorkProductModal()" class="filter-btn">Close</button>
      </div>
    </div>
  </div>
  ```

#### Add CSS Styles for Modal
- [ ] **Add in the `<style>` section:**
  ```css
  .work-product-question {
    margin-bottom: 25px;
    padding: 15px;
    border: 1px solid #e5e7eb;
    border-radius: 6px;
    background: #fafafa;
  }

  .work-product-question-text {
    font-weight: 600;
    color: #374151;
    margin-bottom: 10px;
    font-size: 1rem;
  }

  .work-product-textarea {
    width: 100%;
    min-height: 100px;
    padding: 10px;
    border: 1px solid #d1d5db;
    border-radius: 4px;
    font-family: inherit;
    font-size: 0.9rem;
    line-height: 1.4;
    resize: vertical;
    transition: border-color 0.2s ease;
  }

  .work-product-textarea:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .save-status {
    font-size: 0.8rem;
    margin-top: 5px;
    transition: opacity 0.3s ease;
  }

  .save-status.saving {
    color: #f59e0b;
  }

  .save-status.saved {
    color: #10b981;
  }

  .save-status.error {
    color: #ef4444;
  }
  ```

#### Add JavaScript Functions for Modal
- [ ] **Add in the `<script>` section:**
  ```javascript
  let saveTimeouts = {};
  let currentWorkProductObservationId = null;

  function openWorkProductModal() {
    loadWorkProductQuestions();
    document.getElementById('workProductModal').style.display = 'block';
    document.body.style.overflow = 'hidden'; // Prevent background scrolling
  }

  function closeWorkProductModal() {
    document.getElementById('workProductModal').style.display = 'none';
    document.body.style.overflow = 'auto'; // Restore scrolling
  }

  function closeWorkProductModalOnBackdrop(event) {
    if (event.target === event.currentTarget) {
      closeWorkProductModal();
    }
  }

  function loadWorkProductQuestions() {
    const container = document.getElementById('questionsContainer');
    container.innerHTML = '<div style="text-align: center; padding: 20px;">Loading questions...</div>';

    google.script.run
      .withSuccessHandler(function(result) {
        if (result.success) {
          displayQuestions(result.questions);
        } else {
          container.innerHTML = '<div style="text-align: center; padding: 20px; color: #ef4444;">Error loading questions: ' + result.error + '</div>';
        }
      })
      .withFailureHandler(function(error) {
        console.error('Failed to load questions:', error);
        container.innerHTML = '<div style="text-align: center; padding: 20px; color: #ef4444;">Failed to load questions. Please try again.</div>';
      })
      .getWorkProductQuestionsForClient();
  }

  function displayQuestions(questions) {
    const container = document.getElementById('questionsContainer');

    if (!questions || questions.length === 0) {
      container.innerHTML = '<div style="text-align: center; padding: 20px; color: #6b7280;">No questions available.</div>';
      return;
    }

    let html = '';
    questions.forEach(question => {
      html += `
        <div class="work-product-question">
          <div class="work-product-question-text">${question.questionText}</div>
          <textarea class="work-product-textarea"
                    id="answer-${question.questionId}"
                    placeholder="Enter your response here..."
                    oninput="handleAnswerInput('${question.questionId}')"></textarea>
          <div class="save-status" id="status-${question.questionId}"></div>
        </div>
      `;
    });

    container.innerHTML = html;

    // Load existing answers
    loadExistingAnswers();
  }

  function loadExistingAnswers() {
    // Get observation ID from current context
    getCurrentWorkProductObservationId(function(observationId) {
      if (!observationId) return;

      currentWorkProductObservationId = observationId;

      google.script.run
        .withSuccessHandler(function(result) {
          if (result.success && result.answers) {
            result.answers.forEach(answer => {
              const textarea = document.getElementById('answer-' + answer.questionId);
              if (textarea) {
                textarea.value = answer.answerText;
              }
            });
          }
        })
        .withFailureHandler(function(error) {
          console.error('Failed to load existing answers:', error);
        })
        .getWorkProductAnswersForClient(observationId);
    });
  }

  function getCurrentWorkProductObservationId(callback) {
    // This needs to be implemented based on how the current observation ID is tracked
    // For now, we'll use a placeholder that should be replaced with actual implementation
    google.script.run
      .withSuccessHandler(function(result) {
        if (result.success && result.observationId) {
          callback(result.observationId);
        } else {
          callback(null);
        }
      })
      .withFailureHandler(function(error) {
        console.error('Failed to get observation ID:', error);
        callback(null);
      })
      .getCurrentUserWorkProductObservationId(); // This function needs to be implemented in Code.js
  }

  function handleAnswerInput(questionId) {
    const textarea = document.getElementById('answer-' + questionId);
    const statusDiv = document.getElementById('status-' + questionId);

    if (!textarea || !currentWorkProductObservationId) return;

    // Clear existing timeout
    if (saveTimeouts[questionId]) {
      clearTimeout(saveTimeouts[questionId]);
    }

    // Show saving status
    statusDiv.textContent = 'Typing...';
    statusDiv.className = 'save-status saving';

    // Set new timeout for debounced save
    saveTimeouts[questionId] = setTimeout(() => {
      saveAnswer(questionId, textarea.value, statusDiv);
    }, 1500); // 1.5 second debounce
  }

  function saveAnswer(questionId, answerText, statusDiv) {
    statusDiv.textContent = 'Saving...';
    statusDiv.className = 'save-status saving';

    google.script.run
      .withSuccessHandler(function(result) {
        if (result.success) {
          statusDiv.textContent = 'Saved';
          statusDiv.className = 'save-status saved';
          setTimeout(() => {
            statusDiv.style.opacity = '0.5';
          }, 2000);
        } else {
          statusDiv.textContent = 'Error saving: ' + result.error;
          statusDiv.className = 'save-status error';
        }
      })
      .withFailureHandler(function(error) {
        console.error('Save failed:', error);
        statusDiv.textContent = 'Save failed. Please try again.';
        statusDiv.className = 'save-status error';
      })
      .saveWorkProductAnswerFromClient(currentWorkProductObservationId, questionId, answerText);
  }

  // Initialize modal functionality when page loads
  document.addEventListener('DOMContentLoaded', function() {
    // Auto-open modal if work product button exists (optional)
    // Uncomment the next lines if you want the modal to open automatically
    /*
    const wpButton = document.getElementById('workProductQuestionsBtn');
    if (wpButton) {
      // Could add auto-open logic here if desired
    }
    */
  });
  ```

#### Add Missing Server Function for Getting Current User's Work Product Observation
- [ ] **Add to Code.js (this function is referenced in the frontend code above):**
  ```javascript
  function getCurrentUserWorkProductObservationId() {
    try {
      const userContext = createUserContext();
      const observations = _getObservationsDb();

      const userWorkProductObs = observations.find(obs =>
        obs.observedEmail === userContext.email &&
        obs.Type === 'Work Product' &&
        obs.status === 'Draft'
      );

      if (userWorkProductObs) {
        return { success: true, observationId: userWorkProductObs.observationId };
      } else {
        return { success: false, error: 'No work product observation found' };
      }
    } catch (error) {
      console.error('Error getting current user work product observation:', error);
      return { success: false, error: 'Failed to get observation ID: ' + error.message };
    }
  }
  ```
