<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><?= userContext.role ?> - Select Rubric View</title>
    
    <!-- Content Security Policy - Allow framing from same origin and Google domains -->
    <meta http-equiv="Content-Security-Policy" content="frame-ancestors 'self' https://*.google.com;">
    
    <!-- Quill.js for rich text editing -->
    <link href="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.js"></script>
    <style>
:root {
    --color-white: white;
    --color-text-default: #333;
    --color-bg-body: #f5f5f5;

    /* Greens for toggle button and assignments */
    --color-green-base: #10b981;
    --color-green-dark: #059669;
    --color-green-darker: #047857;
    --color-green-light-bg: #f0fdf4;

    /* Ambers for toggle button (assigned mode) and active filters */
    --color-amber-base: #f59e0b;
    --color-amber-dark: #d97706;
    --color-amber-darker: #b45309;
    --color-amber-light-bg: #fef3c7;
    --color-amber-text-dark: #92400e;

    /* Blues for filter status and select focus */
    --color-blue-base: #3b82f6;
    --color-blue-dark: #2563eb;
    --color-blue-light-bg: #dbeafe;
    --color-blue-text-dark: #1e40af;
    --color-blue-focus-shadow: rgba(59, 130, 246, 0.1);

    /* Grays for various UI elements */
    --color-gray-text: #4a5568;
    --color-gray-text-light: #374151;
    --color-gray-border-light: #d1d5db;
    --color-gray-border-medium: #e2e8f0;
    --color-gray-bg-light: #f8fafc;
    --color-gray-bg-medium: #6b7280;
    --color-gray-bg-dark: #4b5563;
    --color-gray-component-not-assigned-border: #e5e7eb;
    --color-gray-assignment-indicator-not-assigned-bg: #e5e7eb;
    --color-text-deemphasized: #718096;

    /* Reds for destructive actions */
    --color-red-base: #dc2626;
    --color-red-dark: #b91c1c;
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg-body);
            padding: 20px;
            line-height: 1.6;
            color: var(--color-text-default);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--color-white);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header {
            background: linear-gradient(135deg, #4a5568, #2d3748);
            color: var(--color-white);
            padding: 40px 30px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 101;
            border-radius: 12px 12px 0 0;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .content {
            padding: 40px 30px;
        }

        /* Dashboard-specific styles */
        .quick-actions { margin-bottom: 40px; }
        .section-title {
            color: var(--color-gray-text);
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .actions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        .action-card {
            background: var(--color-white);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        .action-card:hover {
            border-color: var(--color-blue-base);
            background: var(--color-gray-bg-light);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        .action-icon { font-size: 2.5rem; margin-bottom: 15px; display: block; }
        .action-title { font-weight: 600; color: var(--color-gray-text-light); font-size: 1.1rem; margin-bottom: 8px; }
        .action-desc { color: var(--color-text-deemphasized); font-size: 0.95rem; }

        /* Filter controls */
        .custom-filters, .observation-selector {
            background: var(--color-gray-bg-light);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 12px;
            padding: 30px;
            display: none;
        }
        .filter-row { display: flex; gap: 15px; margin-bottom: 20px; align-items: center; flex-wrap: wrap; }
        .filter-select {
            padding: 12px 15px;
            border: 1px solid var(--color-gray-border-light);
            border-radius: 8px;
            font-size: 1rem;
            background: var(--color-white);
            transition: all 0.3s ease;
            flex: 1;
            min-width: 200px;
        }
        .filter-select:focus {
            outline: none;
            border-color: var(--color-blue-base);
            box-shadow: 0 0 0 3px var(--color-blue-focus-shadow);
        }
        .filter-btn {
            background: var(--color-blue-base);
            color: var(--color-white);
            border: 2px solid var(--color-blue-base);
            cursor: pointer;
            font-weight: 600;
            min-width: 140px;
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        .filter-btn:hover:not(:disabled) { background: #2c5aa0; border-color: #2c5aa0; }
        .filter-btn:disabled { background: #cbd5e0; border-color: #cbd5e0; cursor: not-allowed; }
        .btn-secondary { 
            background: var(--color-gray-bg-medium); 
            border: 2px solid var(--color-gray-bg-medium);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .btn-secondary:hover { 
            background: var(--color-gray-bg-dark); 
            border-color: var(--color-gray-bg-dark);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(75, 85, 99, 0.2);
        }
        
        .btn-primary {
            background: var(--color-blue-base);
            border: 2px solid var(--color-blue-base);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary:hover {
            background: var(--color-blue-dark);
            border-color: var(--color-blue-dark);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
        }

        /* Loading Overlay */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .loading-content {
            background: var(--color-white);
            color: var(--color-blue-text-dark);
            border: 2px solid var(--color-blue-base);
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            min-width: 300px;
        }
        .loading-spinner { 
            display: inline-block; 
            width: 40px; 
            height: 40px; 
            border: 4px solid rgba(59, 130, 246, 0.3); 
            border-radius: 50%; 
            border-top-color: var(--color-blue-base); 
            animation: spin 1s ease-in-out infinite; 
            margin-bottom: 15px; 
        }
        .loading-text {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--color-gray-text-light);
        }
        
        /* Error states */
        .error { text-align: center; padding: 40px; margin: 20px 0; border-radius: 12px; display: none; background: #fef2f2; color: #dc2626; border: 2px solid #fecaca; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Observation cards */
        .observation-card {
            background: var(--color-white);
            border: 1px solid var(--color-gray-border-medium);
            border-radius: 12px;
            padding: 0;
            text-align: left;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        .observation-card:hover { box-shadow: 0 8px 25px rgba(0,0,0,0.08); transform: translateY(-2px); }
        .obs-card-content { padding: 20px; flex-grow: 1; }
        .obs-card-title { font-weight: 600; color: var(--color-gray-text-light); font-size: 1.1rem; margin-bottom: 4px; }
        .obs-card-desc { color: var(--color-text-deemphasized); font-size: 0.9rem; margin-bottom: 12px; }
        .status-badge { display: inline-block; padding: 4px 10px; font-size: 0.8rem; font-weight: 600; border-radius: 9999px; }
        .status-draft { background-color: var(--color-amber-light-bg); color: var(--color-amber-text-dark); }
        .status-finalized { background-color: var(--color-green-light-bg); color: var(--color-green-darker); }
        .obs-card-actions { background: var(--color-gray-bg-light); border-top: 1px solid var(--color-gray-border-medium); padding: 15px 20px; display: flex; gap: 10px; }
        .obs-card-actions .filter-btn { flex: 1; text-align: center; padding: 8px 16px; font-size: 0.9rem; min-width: auto; }
        .btn-edit { background: #3b82f6; border-color: #3b82f6; }
        .btn-edit:hover { background: #2563eb; border-color: #2563eb; }
        .btn-finalize { background: var(--color-green-base); border-color: var(--color-green-base); }
        .btn-finalize:hover { background: var(--color-green-dark); border-color: var(--color-green-dark); }
        .btn-delete { background: var(--color-red-base); border-color: var(--color-red-base); }
        .btn-delete:hover { background: var(--color-red-dark); border-color: var(--color-red-dark); }
        .btn-view { background: #3b82f6; border-color: #3b82f6; }
        .btn-view:hover { background: #2563eb; border-color: #2563eb; }
        .btn-export { background: var(--color-green-base); border-color: var(--color-green-base); }
        .btn-export:hover { background: var(--color-green-dark); border-color: var(--color-green-dark); }

        .observation-metadata-editor {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        .global-tools-bar {
            background: var(--color-white);
            border-bottom: 2px solid var(--color-gray-border-medium);
            padding: 16px 24px;
            display: flex;
            justify-content: center;
        }

        .global-tools-container {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .global-tool-btn {
            background: var(--color-blue-base);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .global-tool-btn:hover {
            background: var(--color-blue-dark);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }
        
        .global-tool-btn:active {
            background: var(--color-blue-dark);
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
        }

        .global-tool-btn.recording {
            background: var(--color-red-base);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* PDF Button States */
        .btn-pdf-failed { 
            background: #f97316; 
            border-color: #f97316; 
            position: relative;
        }
        .btn-pdf-failed:hover { 
            background: #ea580c; 
            border-color: #ea580c; 
        }
        .btn-pdf-failed:before {
            content: "‚ö†Ô∏è ";
            margin-right: 4px;
        }
        
        .btn-pdf-missing { 
            background: #6b7280; 
            border-color: #6b7280; 
            position: relative;
        }
        .btn-pdf-missing:hover { 
            background: #4b5563; 
            border-color: #4b5563; 
        }
        .btn-pdf-missing:before {
            content: "üìÑ ";
            margin-right: 4px;
        }

        /* === Sticky Navigation Bar === */
        .sticky-nav {
            position: sticky;
            top: 0;
            z-index: 100;
            background: var(--color-white);
            border-bottom: 2px solid var(--color-gray-border-medium);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: none; /* Hidden by default, shown when viewing rubric */
        }

        .sticky-nav.show {
            display: flex;
        }

        .nav-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            gap: 24px;
        }

        .nav-section {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .nav-back {
            color: var(--color-blue-base);
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .nav-back:hover {
            background: var(--color-blue-light-bg);
            color: var(--color-blue-text-dark);
        }

        /* Professional Sliding Toggle */
        .view-toggle {
            display: flex;
            align-items: center;
            background: var(--color-gray-bg-light);
            border-radius: 8px;
            padding: 4px;
            border: 2px solid var(--color-gray-border-light);
            position: relative;
        }

        .toggle-option {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--color-gray-text);
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
            white-space: nowrap;
        }

        .toggle-option.active {
            color: var(--color-blue-text-dark);
        }

        .toggle-slider {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            background: var(--color-white);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .staff-context {
            color: var(--color-gray-text);
            font-weight: 500;
            font-size: 0.9rem;
            padding: 8px 12px;
            background: var(--color-gray-bg-light);
            border-radius: 6px;
            border: 1px solid var(--color-gray-border-light);
        }

        .nav-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .nav-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            border: 2px solid;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }


        .nav-btn-finalize {
            background: var(--color-green-base);
            color: var(--color-white);
            border-color: var(--color-green-base);
        }

        .nav-btn-finalize:hover {
            background: var(--color-green-dark);
            border-color: var(--color-green-dark);
        }

        .role-badge {
            background: var(--color-blue-base);
            color: var(--color-white);
            border: 2px solid var(--color-blue-base);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            transition: all 0.2s ease;
        }

        /* === Rubric Styles (from rubric.html) === */
        .rubric-container { display: none; margin-top: 30px; }
        .domain-section { border-bottom: 3px solid var(--color-gray-border-medium); }
        .domain-header { background: linear-gradient(135deg, #7c9ac5, #5a82b8); color: white; padding: 15px 20px; font-size: 1.1rem; font-weight: 600; position: sticky; top: 76px; z-index: 50; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .component-section { border-bottom: 1px solid var(--color-gray-border-medium); position: relative; transition: background-color 0.2s; }
        .performance-levels-header { position: sticky; top: 132px; z-index: 40; background: white; border-bottom: 2px solid var(--color-gray-border-medium); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .performance-levels { display: grid; grid-template-columns: 200px 1fr 1fr 1fr 1fr; min-height: 50px; }
        .performance-levels-content { display: grid; grid-template-columns: 200px 1fr 1fr 1fr 1fr; min-height: 120px; }
        .level-header { background: #e2e8f0; padding: 12px; font-weight: 600; text-align: center; border-bottom: 1px solid #cbd5e0; color: var(--color-gray-text); font-size: 0.9rem; }
        .level-content { padding: 20px; border-right: 1px solid var(--color-gray-border-medium); border-bottom: 1px solid var(--color-gray-border-medium); background: var(--color-white); color: var(--color-gray-text); font-size: 0.9rem; transition: background-color 0.2s; }
        .level-content:last-child { border-right: none; }
        .row-label { background: #64748b; padding: 20px; font-weight: 600; color: white; border-bottom: 1px solid var(--color-gray-border-medium); display: flex; align-items: center; font-size: 0.9rem; }

        /* Look-fors (Best Practices) */
        .look-fors-section { border-top: 1px solid var(--color-gray-border-medium); }
        .look-fors-header { background: linear-gradient(135deg, #3182ce, #2b77cb); color: white; padding: 10px 20px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-weight: 600; transition: background 0.3s ease; font-size: 0.85rem; }
        .look-fors-header:hover { background: linear-gradient(135deg, #2b77cb, #2c5aa0); }
        .chevron { transition: all 0.3s ease; font-size: 1rem; }
        .look-fors-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; background: var(--color-gray-bg-light); }
        .look-fors-content.expanded { max-height: 1000px; }
        .look-fors-grid { padding: 12px 20px; display: grid; grid-template-columns: 1fr; gap: 8px; }
        .look-for-item { display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: var(--color-white); border-radius: 4px; box-shadow: 0 1px 2px rgba(0,0,0,0.08); border-left: 3px solid var(--color-blue-base); }
        .look-for-item label { cursor: pointer; color: var(--color-gray-text); font-weight: 500; font-size: 0.85rem; line-height: 1.4; }

        /* Component Assignment & Highlighting */
        .component-section.component-assigned { border-left: 4px solid var(--color-green-base); background: var(--color-green-light-bg); }
        .component-section.component-not-assigned { border-left: 4px solid var(--color-gray-component-not-assigned-border); }
        .component-section.component-not-assigned .level-content { color: var(--color-text-deemphasized); }
        .component-section[data-assigned="true"]:hover { border-left-color: var(--color-green-dark); }
        .component-section:not([data-assigned="true"]):hover { border-left-color: var(--color-gray-border-light); background-color: var(--color-gray-bg-light); }
        .component-hidden { display: none; }
        
        /* Utility class for hiding elements completely */
        .hidden { display: none !important; }
        
        /* Interactive Rubric Styles */
        .level-content.editable { cursor: pointer; }
        .level-content.editable:hover { background-color: var(--color-blue-light-bg); }
        .level-content.selected { background-color: var(--color-blue-light-bg) !important; border: 2px solid var(--color-blue-base); font-weight: 600; color: var(--color-blue-text-dark); }

        /* Media Upload Styles */
        .media-upload-section { padding: 15px 20px; background-color: var(--color-gray-bg-light); border-top: 1px solid var(--color-gray-border-medium); }
        .media-upload-title { font-weight: 600; color: var(--color-gray-text); margin-bottom: 10px; font-size: 0.9rem; }
        .media-upload-area { display: flex; gap: 10px; align-items: center; }
        .media-upload-input { display: none; }
        .media-upload-label { background: var(--color-gray-bg-medium); color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; transition: background-color 0.2s; }
        .media-upload-label:hover { background: var(--color-gray-bg-dark); }
        .upload-status { font-size: 0.85rem; color: var(--color-gray-text); font-style: italic; }
        .evidence-list { margin-top: 10px; padding-left: 20px; }
        .evidence-item { margin-bottom: 5px; font-size: 0.9rem; }
        .evidence-item a { color: var(--color-blue-base); text-decoration: none; }
        .evidence-item a:hover { text-decoration: underline; }

        /* View Toggle Button */
        .view-toggle-button {
            background-color: var(--color-gray-bg-light);
            border: 1px solid var(--color-gray-border-light);
            padding: 8px 16px;
            margin: 0 0 20px 0;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            color: var(--color-gray-text);
            transition: all 0.2s ease;
        }
        .view-toggle-button:hover { background-color: #dee2e6; border-color: #adb5bd; }
        .filter-status {
            background: var(--color-blue-light-bg);
            border: 1px solid var(--color-blue-base);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: var(--color-blue-text-dark);
            font-weight: 500;
            display: none;
        }

        /* Toast Notification Styles */
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--color-red-base);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 9999;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            font-weight: 500;
            max-width: 350px;
            word-wrap: break-word;
        }
        .toast-notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast-notification.success {
            background-color: var(--color-green-base);
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .content { padding: 20px; }
            .actions-grid { grid-template-columns: 1fr; }
            .filter-row { flex-direction: column; align-items: stretch; }
            .filter-select, .filter-btn { min-width: auto; width: 100%; }
            .performance-levels, .performance-levels-content { grid-template-columns: 1fr; gap: 1px; }
            .level-header, .row-label, .level-content { border-right: none; padding: 15px; font-size: 0.9rem; }
            .toast-notification { top: 10px; right: 10px; left: 10px; right: 10px; max-width: none; }
            
            /* Responsive Navigation */
            .nav-container {
                flex-wrap: wrap;
                padding: 8px 16px;
                gap: 12px;
            }
            
            .nav-section {
                gap: 8px;
            }
            
            .nav-back {
                font-size: 0.8rem;
                padding: 6px 12px;
            }
            
            .toggle-option {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
            
            .staff-context {
                font-size: 0.8rem;
                padding: 6px 10px;
            }
            
            .nav-btn {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
            
            .role-badge {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
        }

        /* Evidence Section Styles */
        .evidence-section {
            border-top: 1px solid #e2e8f0;
            margin-top: 10px;
        }

        .evidence-toggle-btn {
            background: linear-gradient(135deg, #64748b, #475569);
            color: white;
            border: none;
            padding: 10px 20px;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            transition: background 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .evidence-toggle-btn:hover {
            background: linear-gradient(135deg, #475569, #374151);
        }

        .evidence-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: #f8fafc;
        }

        .evidence-content.expanded {
            max-height: 800px;
        }

        .notes-container {
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .notes-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            display: inline-block;
        }

        .notes-header-actions {
            float: right;
            margin-top: -5px;
        }

        .clear-notes-btn {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .clear-notes-btn:hover {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(245, 101, 101, 0.3);
        }

        .clear-notes-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .look-fors-container {
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .look-fors-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .look-fors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 8px;
        }

        .look-for-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
        }

        .look-for-item input[type="checkbox"] {
            margin-top: 2px;
            flex-shrink: 0;
        }

        .look-for-item label {
            font-size: 0.85rem;
            line-height: 1.4;
            cursor: pointer;
        }

        .media-upload-container {
            padding: 15px 20px;
        }

        .media-upload-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .media-upload-input {
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            width: 100%;
        }

        .media-upload-button {
            background: #3182ce;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .media-upload-button:hover {
            background: #2b77cb;
        }

        .media-links-container {
            margin-top: 10px;
        }

        .evidence-item {
            margin-bottom: 5px;
        }

        .evidence-item a {
            color: #3182ce;
            text-decoration: none;
            font-size: 0.85rem;
        }

        .evidence-item a:hover {
            text-decoration: underline;
        }

        /* Script Editor Modal Styles */
        .script-editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .script-editor-container {
            background: white;
            width: 95%;
            height: 90%;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .script-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 2px solid var(--color-gray-border-medium);
        }

        .script-editor-header h2 {
            font-size: 1.5rem;
            color: var(--color-gray-text-light);
        }

        .script-editor-controls {
            display: flex;
            gap: 12px;
        }

        .script-editor-controls .btn-primary {
            background-color: var(--color-green-base);
            border-color: var(--color-green-base);
            font-weight: 700;
            padding: 10px 20px;
        }

        .script-editor-controls .btn-primary:hover {
            background-color: var(--color-green-dark);
            border-color: var(--color-green-dark);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
        }
        
        .script-editor-controls .btn-secondary {
            padding: 10px 20px;
            font-weight: 500;
        }

        .script-editor-content {
            flex-grow: 1;
            padding: 0 24px 24px 24px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #scriptEditor {
            height: 100%;
            border: 1px solid var(--color-gray-border-light);
            border-radius: 6px;
            background-color: var(--color-white);
        }

        /* Quill toolbar customization */
        .script-editor-toolbar {
            padding: 12px 0;
        }

        #scriptEditor .ql-editor {
            font-size: 16px;
            line-height: 1.6;
            color: var(--color-text-default);
            height: 100%;
        }

        /* Component Tagging System Styles */
        .script-tagging-toolbar {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-bottom: 2px solid #e2e8f0;
            padding: 12px 16px;
        }

        .tagging-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .component-selector {
            min-width: 200px;
            max-width: 300px;
            padding: 8px 12px;
            border: 2px solid #cbd5e0;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            color: var(--color-text-default);
            transition: all 0.2s ease;
        }

        .component-selector:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .btn-tag, .btn-push, .btn-clear-tags {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-tag {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-tag:hover {
            background: linear-gradient(135deg, #3182ce 0%, #2c5aa0 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(49, 130, 206, 0.3);
        }

        .btn-push {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-push:hover {
            background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(72, 187, 120, 0.3);
        }

        .btn-clear-tags {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-clear-tags:hover {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(245, 101, 101, 0.3);
        }

        .tag-status {
            font-size: 12px;
            color: #4a5568;
            font-style: italic;
            padding: 4px 8px;
            background: #f7fafc;
            border-radius: 4px;
            border-left: 3px solid #4299e1;
        }

        /* Tagged content visual indicators */
        .script-editor-content .ql-editor [style*="background"] {
            position: relative;
            border-radius: 3px;
            padding: 1px 2px;
        }

        /* Component tag color legend (could be added later if needed) */
        .tag-legend {
            display: none; /* Hidden for now, but available for future use */
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        /* Responsive adjustments for tagging toolbar */
        @media (max-width: 768px) {
            .tagging-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .component-selector {
                min-width: unset;
                max-width: unset;
            }
            
            .btn-tag, .btn-push, .btn-clear-tags {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sticky Navigation Bar -->
        <nav class="sticky-nav" id="stickyNav">
            <div class="nav-container">
                <div class="nav-section">
                    <a href="#" class="nav-back" onclick="goBackToObservations(); return false;">
                        ‚Üê Back
                    </a>
                    
                    <div class="view-toggle" id="viewToggle" style="display: none;">
                        <div class="toggle-slider" id="toggleSlider"></div>
                        <button class="toggle-option active" id="assignedToggle" onclick="setViewMode('assigned')">
                            Assigned Subdomains
                        </button>
                        <button class="toggle-option" id="fullToggle" onclick="setViewMode('full')">
                            Full Rubric
                        </button>
                    </div>
                </div>
                
                <div class="staff-context" id="staffContext" style="display: none;">
                    Viewing: <span id="staffName">--</span>
                </div>
                
                <div class="nav-section">
                    <div class="nav-actions" id="navActions" style="display: none;">
                        <button class="nav-btn nav-btn-finalize" id="finalizeBtn" onclick="handleFinalizeFromNav()">
                            ‚úÖ Finalize & Submit
                        </button>
                    </div>
                    
                    <div class="role-badge">
                        <?= userContext.role ?>
                    </div>
                </div>
            </div>
        </nav>

        <div class="header"><h1>üë• <?= userContext.role ?> Dashboard</h1><p>Select how you'd like to view rubric information</p></div>
        <div class="content">
            <div id="quickActionsView">
                <div class="quick-actions"><h2 class="section-title"><span>üéØ</span> Quick Actions</h2>
                    <div class="actions-grid">
                        <? if (userContext.specialRoleType === 'peer_evaluator' || userContext.specialRoleType === 'full_access') { ?>
                        <div class="action-card" onclick="showCustomFilters()"><span class="action-icon">üîç</span><div class="action-title">Find Staff & Start Observation</div><div class="action-desc">Filter by role, year, or specific staff member</div></div>
                        <div class="action-card" onclick="loadMyOwnView()"><span class="action-icon">üìã</span><div class="action-title">My Own Rubric</div><div class="action-desc">View your personal assigned areas</div></div>
                        <? } ?>
                    </div>
                </div>
            </div>
            <div class="custom-filters" id="customFiltersView">
                <h2 class="section-title"><span>üîç</span> Find Staff Member</h2>
                <div class="filter-row"><select id="roleSelect" class="filter-select" onchange="handleRoleChange()"><option value="">1. Select Role...</option><? for (var i = 0; i < availableRoles.length; i++) { ?><option value="<?= availableRoles[i] ?>"><?= availableRoles[i] ?></option><? } ?></select></div>
                <div class="filter-row"><select id="yearSelect" class="filter-select" style="display: none;" onchange="handleYearChange()"><option value="">2. Select Year...</option><option value="1">Year 1</option><option value="2">Year 2</option><option value="3">Year 3</option><option value="0">Probationary</option></select></div>
                <div class="filter-row"><select id="staffSelect" class="filter-select" style="display: none;" onchange="handleStaffChange()"><option value="">3. Select Staff Member...</option></select></div>
                <div class="filter-row"><button class="filter-btn" id="loadBtn" onclick="loadSelectedView()" disabled>üìñ Select Staff</button><button class="filter-btn btn-secondary" onclick="clearFilters()">üóëÔ∏è Clear & Go Back</button></div>
            </div>
            <div class="observation-selector" id="observationSelectorView"></div>
            <div class="error" id="error"><div id="errorMessage"></div><button class="filter-btn btn-secondary" onclick="hideError()" style="margin-top: 15px;">Dismiss</button></div>
            <div class="filter-status" id="filterStatus"><strong>Currently Viewing:</strong> <span id="filterStatusText"></span></div>
            <div class="rubric-container" id="rubricContainer"></div>
        </div>
    </div>
    <div class="toast-notification" id="toastNotification"></div>
    <script>
        /**
         * Escapes HTML entities in a string to prevent XSS and ensure safe HTML rendering.
         * This implementation matches the server-side Utils.js version for consistency.
         * @param {*} unsafe - The input to escape (will be converted to string if not already)
         * @returns {string} The escaped string with HTML entities replaced
         */
        function escapeHtml(unsafe) {
            // Handle null and undefined by returning empty string
            if (unsafe == null) {
                return '';
            }
            
            // Convert to string if not already a string
            const str = String(unsafe);
            
            // Define the character mapping for HTML entities
            const entityMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            };
            
            // Replace characters using the entity map
            return str.replace(/[&<>"']/g, function(match) {
                return entityMap[match];
            });
        }

        /**
         * Escapes characters in a string to ensure it's safe to use within a JavaScript
         * single-quoted string literal, such as in an onclick attribute.
         * @param {*} unsafe - The input to escape (will be converted to string if not already)
         * @returns {string} The escaped string, safe for JS string literals.
         */
        function escapeJsString(unsafe) {
            if (unsafe == null) {
                return '';
            }
            const str = String(unsafe);
            return str.replace(/[\\']/g, '\\$&')
                      .replace(/\n/g, '\\n')
                      .replace(/\r/g, '\\r');
        }

        function showLoading(message = 'Loading...') { 
            document.getElementById('loading-text').textContent = message; 
            document.getElementById('loading').style.display = 'flex'; 
            hideError(); 
        }
        function hideLoading() { document.getElementById('loading').style.display = 'none'; }
        function showError(error) { const msg = error.message || String(error); document.getElementById('errorMessage').textContent = msg; document.getElementById('error').style.display = 'block'; hideLoading(); }
        function hideError() { document.getElementById('error').style.display = 'none'; }
        function handleError(error) { console.error('AJAX Error:', error); showError(error); }

        function showToast(message, isSuccess = false) {
            const toast = document.getElementById('toastNotification');
            toast.textContent = message;
            toast.className = 'toast-notification' + (isSuccess ? ' success' : '');
            toast.classList.add('show');
            setTimeout(function() {
                toast.classList.remove('show');
            }, 4000);
        }

        let currentFilters = { role: null, year: null, staff: null };
        let currentObservationId = null;
        let observationViewMode = 'assigned';
        let currentObservedUser = { email: null, name: null };

        function showView(viewId) {
            stopAllPollers(); // Stop any running pollers when the view changes
            ['quickActionsView', 'customFiltersView', 'observationSelectorView', 'rubricContainer'].forEach(id => { 
                document.getElementById(id).style.display = 'none'; 
            }); 
            document.getElementById(viewId).style.display = 'block'; 
            
            const header = document.querySelector('.header');

            // Show/hide sticky nav and header based on view
            if (viewId === 'rubricContainer') {
                if (header) header.classList.add('hidden');
                // Nav will be shown by handleRubricData
            } else {
                if (header) header.classList.remove('hidden');
                hideStickyNav();
            }
        }
        function showCustomFilters() { showView('customFiltersView'); }
        function loadMyOwnView() { showLoading('Loading your assigned rubric...'); google.script.run.withSuccessHandler(handleRubricData).withFailureHandler(handleError).loadRubricData({ myOwnView: true }); }

        function handleRoleChange() {
            const roleSelect = document.getElementById('roleSelect'); const yearSelect = document.getElementById('yearSelect'); currentFilters.role = roleSelect.value;
            yearSelect.value = ''; yearSelect.style.display = roleSelect.value ? 'block' : 'none'; handleYearChange();
        }
        function handleYearChange() {
            const yearSelect = document.getElementById('yearSelect'); const staffSelect = document.getElementById('staffSelect'); currentFilters.year = yearSelect.value;
            staffSelect.value = ''; staffSelect.style.display = yearSelect.value ? 'block' : 'none';
            if (yearSelect.value) { loadStaffOptions(); } else { handleStaffChange(); }
        }
        function handleStaffChange() { const staffSelect = document.getElementById('staffSelect'); currentFilters.staff = staffSelect.value; document.getElementById('loadBtn').disabled = !staffSelect.value; }
        function loadStaffOptions() {
            const staffSelect = document.getElementById('staffSelect'); staffSelect.innerHTML = '<option value="">Loading staff...</option>'; staffSelect.disabled = true;
            google.script.run.withSuccessHandler(populateStaffDropdown).withFailureHandler(handleError).getStaffListForDropdown(currentFilters.role, currentFilters.year);
        }
        function populateStaffDropdown(result) {
            const staffSelect = document.getElementById('staffSelect'); staffSelect.disabled = false;
            if (!result.success) { staffSelect.innerHTML = `<option value="">Error: ${result.error}</option>`; return; }
            staffSelect.innerHTML = '<option value="">3. Select Staff Member...</option>';
            if (result.staff?.length) {
                result.staff.forEach(staff => staffSelect.appendChild(new Option(staff.displayName, staff.email)));
            } else {
                staffSelect.appendChild(new Option('No staff found', '', true, true));
            }
        }
        function loadSelectedView() { if (!currentFilters.staff) return; showLoading('Loading...'); google.script.run.withSuccessHandler(handleRubricData).withFailureHandler(handleError).loadRubricData(currentFilters); }
        function clearFilters() { showView('quickActionsView'); hideError(); hideLoading(); document.getElementById('filterStatus').style.display = 'none'; }

        let activePollers = {};

        function _setPdfButtonState(observationId, state, pdfUrl = null) {
            const pdfButton = document.getElementById(`pdf-button-${observationId}`);
            if (!pdfButton) return;

            switch (state) {
                case 'generating':
                    pdfButton.textContent = 'Generating PDF...';
                    pdfButton.className = 'filter-btn btn-export btn-pdf-missing';
                    pdfButton.disabled = true;
                    pdfButton.onclick = null;
                    break;
                case 'ready':
                    pdfButton.textContent = 'View PDF';
                    pdfButton.className = 'filter-btn btn-export';
                    pdfButton.disabled = false;
                    pdfButton.onclick = () => window.open(pdfUrl, '_blank');
                    break;
                case 'failed':
                    pdfButton.textContent = 'Retry PDF';
                    pdfButton.className = 'filter-btn btn-export btn-pdf-failed';
                    pdfButton.disabled = false;
                    pdfButton.onclick = () => handleRetryPdf(observationId);
                    break;
            }
        }

        function startPdfPolling(observationId) {
            if (activePollers[observationId]) {
                console.log(`Polling already active for ${observationId}`);
                return;
            }

            console.log(`Starting PDF polling for ${observationId}`);
            const pollInterval = 5000; // 5 seconds
            const pollTimeout = 60000; // 60 seconds

            const intervalId = setInterval(() => {
                google.script.run
                    .withSuccessHandler(res => {
                        if (res.success) {
                            if (res.pdfUrl) {
                                console.log(`PDF found for ${observationId}`);
                                showToast('PDF is ready!', true);
                                _setPdfButtonState(observationId, 'ready', res.pdfUrl);
                                stopPdfPolling(observationId);
                            } else if (res.pdfStatus === 'failed') {
                                console.log(`PDF generation failed for ${observationId}`);
                                showToast('PDF generation failed. Please retry.', false);
                                _setPdfButtonState(observationId, 'failed');
                                stopPdfPolling(observationId);
                            }
                        } else {
                             console.warn(`Polling check failed for ${observationId}: ${res.error}`);
                        }
                    })
                    .withFailureHandler(err => {
                        console.error(`Polling error for ${observationId}:`, err);
                    })
                    .getObservationStatusAndPdfUrl(observationId);
            }, pollInterval);

            const timeoutId = setTimeout(() => {
                console.log(`Polling timed out for ${observationId}`);
                const pdfButton = document.getElementById(`pdf-button-${observationId}`);
                if (pdfButton && pdfButton.disabled) {
                     showToast('PDF generation is taking longer than expected. Please check back later or retry.', false);
                    _setPdfButtonState(observationId, 'failed');
                }
                stopPdfPolling(observationId);
            }, pollTimeout);

            activePollers[observationId] = { intervalId, timeoutId };
        }

        function stopPdfPolling(observationId) {
            if (activePollers[observationId]) {
                clearInterval(activePollers[observationId].intervalId);
                clearTimeout(activePollers[observationId].timeoutId);
                delete activePollers[observationId];
                console.log(`Stopped polling for ${observationId}`);
            }
        }

        function stopAllPollers() {
            Object.keys(activePollers).forEach(observationId => {
                stopPdfPolling(observationId);
            });
        }

        function renderObservationCards(result, observedEmail, observedName) {
            hideLoading();
            if (!result.success) return showError(result.error);
            const container = document.getElementById('observationSelectorView');
            const safeObservedNameHtml = escapeHtml(observedName);
            const safeObservedEmailJs = escapeJsString(observedEmail);

            let cardsHtml = `<div class="action-card" onclick="handleNewObservation('${safeObservedEmailJs}')"><span class="action-icon">‚ûï</span><div class="action-title">Start New Observation</div><div class="action-desc">Begin a new evaluation for this staff member.</div></div>`;
            result.observations.forEach(obs => {
                const date = new Date(obs.createdAt).toLocaleDateString();
                let buttons = '';
                const safeObsIdJs = escapeJsString(obs.observationId);
                const safeObsIdHtml = escapeHtml(obs.observationId);
                const safeObsNameHtml = escapeHtml(obs.observedName);
                const safeStatusHtml = escapeHtml(obs.status);
                const safeObservedNameJs = escapeJsString(observedName); // For passing to finalize/delete handlers

                if (obs.status === 'Draft') {
                    buttons = `<button class="filter-btn btn-edit" onclick="handleEditObservation('${safeObsIdJs}')">Edit</button>
                               <button class="filter-btn btn-finalize" onclick="handleFinalizeObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Finalize</button>
                               <button class="filter-btn btn-delete" onclick="handleDeleteObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Delete</button>`;
                } else if (obs.status === 'Finalized') {
                    let pdfButtonHtml = '';
                    if (obs.pdfUrl) {
                        pdfButtonHtml = `<button class="filter-btn btn-export" onclick="window.open('${escapeJsString(obs.pdfUrl)}', '_blank')">View PDF</button>`;
                    } else if (obs.pdfStatus === 'failed') {
                        pdfButtonHtml = `<button class="filter-btn btn-export btn-pdf-failed" id="pdf-button-${safeObsIdHtml}" onclick="handleRetryPdf('${safeObsIdJs}')">Retry PDF</button>`;
                    } else {
                        pdfButtonHtml = `<button class="filter-btn btn-export btn-pdf-missing" id="pdf-button-${safeObsIdHtml}" disabled>Generating PDF...</button>`;
                        setTimeout(() => startPdfPolling(obs.observationId), 100);
                    }

                    buttons = `<button class="filter-btn btn-view" onclick="handleViewObservation('${safeObsIdJs}')">View</button>
                               ${pdfButtonHtml}
                               <button class="filter-btn btn-delete" onclick="handleDeleteFinalizedObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Delete</button>`;
                }
                cardsHtml += `
                    <div class="observation-card">
                        <div class="obs-card-content">
                            <div class="obs-card-title">${safeObsNameHtml} - ${safeStatusHtml}</div>
                            <div class="obs-card-desc">Created on ${date}</div>
                            <div class="status-badge ${obs.status === 'Draft' ? 'status-draft' : 'status-finalized'}">${safeStatusHtml}</div>
                        </div>
                        ${buttons ? `<div class="obs-card-actions">${buttons}</div>` : ''}
                    </div>`;
            });
            container.innerHTML = `<h2 class="section-title"><span>üìù</span> Observations for ${safeObservedNameHtml}</h2><div class="actions-grid">${cardsHtml}</div><div style="margin-top: 20px;"><button class="filter-btn btn-secondary" onclick="showView('customFiltersView')">Back to Filters</button></div>`;
            showView('observationSelectorView');
        }

        function displayObservationOptions(observedEmail, observedName) {
            currentObservedUser.email = observedEmail;
            currentObservedUser.name = observedName;
            showLoading(`Loading options for ${observedName}`);
            google.script.run
                .withSuccessHandler(result => {
                    renderObservationCards(result, observedEmail, observedName);
                })
                .withFailureHandler(handleError)
                .getObservationOptions(observedEmail);
        }

        function handleNewObservation(observedEmail) { showLoading('Creating new observation draft...'); google.script.run.withSuccessHandler(handleRubricData).withFailureHandler(handleError).createNewObservationForPeerEvaluator(observedEmail); }
        function handleEditObservation(obsId) { showLoading('Loading observation...'); google.script.run.withSuccessHandler(handleRubricData).withFailureHandler(handleError).loadObservationForEditing(obsId); }
        function handleDeleteObservation(obsId, email, name) { if (confirm('Are you sure you want to delete this draft? This cannot be undone.')) { showLoading('Deleting draft...'); google.script.run.withSuccessHandler(res => { if(res.success) { displayObservationOptions(email, name); } else { showError(res.error); } }).withFailureHandler(handleError).deleteObservation(obsId); } }

        function handleFinalizeObservation(obsId, email, name) {
            if (confirm('Are you sure you want to finalize this observation? You will not be able to edit it further.')) {
                showLoading('Finalizing observation, please wait...');
                google.script.run
                    .withSuccessHandler(res => {
                        hideLoading();
                        if (res.success) {
                            showToast('Observation finalized. Generating PDF...', true);
                            // Refresh the view to show the "Generating..." button
                            displayObservationOptions(email, name);
                        } else {
                            showError(res.error);
                        }
                    })
                    .withFailureHandler(handleError)
                    .finalizeObservation(obsId);
            }
        }

        function handleFinalizeFromNav() {
            if (!currentObservationId || !currentObservedUser.email || !currentObservedUser.name) {
                showError('Unable to finalize: Missing observation context.');
                return;
            }
            
            if (confirm('Are you sure you want to finalize this observation? You will not be able to edit it further.')) {
                showLoading('Finalizing observation, please wait...');
                google.script.run
                    .withSuccessHandler(res => {
                        hideLoading();
                        if (res.success) {
                            showToast('Observation finalized. Generating PDF...', true);
                            // Navigate back to observation list
                            displayObservationOptions(currentObservedUser.email, currentObservedUser.name);
                        } else {
                            showError(res.error);
                        }
                    })
                    .withFailureHandler(handleError)
                    .finalizeObservation(currentObservationId);
            }
        }

        function handleViewObservation(obsId) {
            showLoading('Loading observation...');
            google.script.run.withSuccessHandler(handleRubricData).withFailureHandler(handleError).loadFinalizedObservationForViewing(obsId);
        }

        function handleDeleteFinalizedObservation(obsId, email, name) {
            if (confirm('Are you sure you want to PERMANENTLY DELETE this finalized observation? This action cannot be undone.')) {
                showLoading('Deleting observation...');
                google.script.run.withSuccessHandler(res => {
                    if(res.success) {
                        displayObservationOptions(email, name);
                    } else {
                        showError(res.error);
                    }
                }).withFailureHandler(handleError).deleteFinalizedObservation(obsId);
            }
        }

        function handleViewPdf(obsId) {
            showLoading('Retrieving PDF...');
            google.script.run.withSuccessHandler(res => {
                hideLoading();
                if (res.success) {
                    window.open(res.pdfUrl, '_blank');
                } else {
                    showError(res.error);
                }
            }).withFailureHandler(handleError).getObservationPdfUrl(obsId);
        }

        function handleRetryPdf(obsId) {
            if (confirm('This will attempt to regenerate the PDF for this observation. Continue?')) {
                showLoading('Requesting PDF regeneration...');
                _setPdfButtonState(obsId, 'generating');

                google.script.run.withSuccessHandler(res => {
                    hideLoading();
                    if (res.success) {
                        showToast('PDF regeneration started successfully!', true);
                        startPdfPolling(obsId);
                    } else {
                         showError('PDF regeneration failed: ' + res.error);
                         _setPdfButtonState(obsId, 'failed');
                    }
                }).withFailureHandler(error => {
                    handleError(error);
                    _setPdfButtonState(obsId, 'failed');
                }).regenerateObservationPdf(obsId);
            }
        }

        function toggleLookFors(componentId) {
            const content = document.getElementById(`lookForsContent-${componentId}`);
            const chevron = document.getElementById(`chevron-${componentId}`);

            if (content && chevron) {
                const isExpanded = content.classList.toggle('expanded');
                chevron.textContent = isExpanded ? '‚ñº' : '‚ñ∂';
                try {
                    if (!window.pageLoadInfo) return;
                    const storageKey = `lookForsState_${window.pageLoadInfo.cacheVersion}`;
                    const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');
                    allStates[componentId] = isExpanded;
                    sessionStorage.setItem(storageKey, JSON.stringify(allStates));
                } catch (e) {
                    console.warn('SessionStorage not available for look-fors state.');
                }
            }
        }

        function restoreLookForsState() {
            try {
                if (!window.pageLoadInfo) return;
                const storageKey = `lookForsState_${window.pageLoadInfo.cacheVersion}`;
                const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');

                for (const componentId in allStates) {
                    if (allStates[componentId] === true) {
                        const content = document.getElementById(`lookForsContent-${componentId}`);
                        const chevron = document.getElementById(`chevron-${componentId}`);
                        if (content && chevron) {
                            content.classList.add('expanded');
                            chevron.textContent = '‚ñº';
                        }
                    }
                }
            } catch (e) {
                console.warn('Could not restore look-fors state:', e);
            }
        }

        function goBackToObservations() {
            if (currentObservedUser.email && currentObservedUser.name) {
                displayObservationOptions(currentObservedUser.email, currentObservedUser.name);
            } else {
                showView('customFiltersView');
            }
        }

        function handleRubricData(result) {
            hideLoading();
            if (!result.success) return showError(result.error);
            if (result.action === 'show_observation_selector') {
                currentObservedUser.email = result.observedEmail;
                currentObservedUser.name = result.observedName;
                hideStickyNav(); // Hide nav when going back to selector
                return displayObservationOptions(result.observedEmail, result.observedName);
            }

            const { observation, rubricData } = result;
            currentObservationId = observation ? observation.observationId : null;
            if (observation) {
                currentObservedUser.email = observation.observedEmail;
                currentObservedUser.name = observation.observedName;
            }
            observationViewMode = (rubricData.userContext && rubricData.userContext.viewMode) || 'assigned';

            // Store rubricData globally for nav functions
            window.rubricData = rubricData;
            
            // Show sticky navigation when viewing rubric
            showStickyNav(observation);

            window.pageLoadInfo = {
                cacheVersion: rubricData.userContext ? rubricData.userContext.cacheVersion : 'unknown'
            };
            
            updateFilterStatus(rubricData, observation);
            const rubricHtml = generateInteractiveRubricHtml(rubricData, observation);
            document.getElementById('rubricContainer').innerHTML = rubricHtml;
            
            // Initialize notes data from observation if available
            if (observation && observation.observationData) {
                Object.keys(observation.observationData).forEach(componentId => {
                    const componentData = observation.observationData[componentId];
                    if (componentData && componentData.notes) {
                        window.globalObservationNotes[componentId] = componentData.notes;
                    }
                });
                
                // Schedule recovery for components with notes data
                setTimeout(() => {
                    ensureEditorsForNotesData(rubricData.userContext.isEvaluator);
                }, 500);
            }
            
            // Show global tools bar for evaluators after DOM injection
            if (rubricData.userContext.isEvaluator) {
                updateComponentVisibility();
                
                // Show global tools bar after HTML is in the DOM
                const globalToolsBar = document.getElementById('globalToolsBar');
                if (globalToolsBar) {
                    globalToolsBar.style.display = 'block';
                }
            }
            restoreLookForsState();
            showView('rubricContainer');
        }

        function generateInteractiveRubricHtml(data, observation) {
            const isEvaluator = data.userContext && data.userContext.isEvaluator;
            let html = `<div style="background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">`;

            if (isEvaluator) {
                const today = new Date().toISOString().slice(0, 10);
                const defaultObsName = `${observation.observedName.split(' ').pop()}, ${observation.observedName.split(' ')[0]}_${today}`;
                html += `
                <div class="observation-metadata-editor">
                    <div class="filter-row">
                        <input type="text" id="observationName" class="filter-select" value="${escapeHtml(observation.observationName || defaultObsName)}" onchange="saveObservationMetadata()">
                        <input type="date" id="observationDate" class="filter-select" value="${escapeHtml(observation.observationDate || today)}" onchange="saveObservationMetadata()">
                    </div>
                </div>`;
            }

            // Global tools bar visibility will be handled after DOM injection

            html += `
            <div class="global-tools-bar" id="globalToolsBar" style="display: none;">
                <div class="global-tools-container">
                    <button class="global-tool-btn" id="recordAudioBtn" onclick="toggleAudioRecording()">
                        üé§ Record Audio
                    </button>
                    <button class="global-tool-btn" id="recordVideoBtn" onclick="toggleVideoRecording()">
                        üìπ Record Video
                    </button>
                    <button class="global-tool-btn" id="scriptEditorBtn" onclick="openScriptEditor()">
                        üìù Script Editor
                    </button>
                </div>
            </div>`;

            // Old navigation buttons removed - now handled by sticky nav

            data.domains.forEach((domain, domainIdx) => {
                html += `<div class="domain-section" id="domain-${domainIdx}"><div class="domain-header">${domain.name}</div>`;
                html += `<div class="performance-levels-header"><div class="performance-levels"><div class="level-header"></div><div class="level-header">Developing</div><div class="level-header">Basic</div><div class="level-header">Proficient</div><div class="level-header">Distinguished</div></div></div>`;
                domain.components.forEach((comp, compIdx) => {
                    const componentId = comp.componentId;
                    const isAssigned = comp.isAssigned || false;
                    const selectedProficiency = observation?.observationData?.[componentId]?.proficiency;
                    const evidence = observation?.evidenceLinks?.[componentId] || [];

                    html += `<div class="component-section ${isAssigned ? 'component-assigned' : 'component-not-assigned'}" data-component-id="${componentId}" data-is-assigned="${isAssigned}"><div class="performance-levels-content">`;
                    html += `<div class="row-label">${comp.title}</div>`;
                    ['developing', 'basic', 'proficient', 'distinguished'].forEach(level => {
                        const isSelected = selectedProficiency === level;
                        html += `<div class="level-content ${isEvaluator ? 'editable' : ''} ${isSelected ? 'selected' : ''}" data-level="${level}" onclick="${isEvaluator ? `selectProficiency(this, '${componentId}', '${level}')` : ''}">${comp[level] || ''}</div>`;
                    });
                    html += `</div>`;

                    // Look-fors section (collapsible blue header, directly below subdomain rows)
                    if (comp.bestPractices && comp.bestPractices.length > 0) {
                        const lookForsId = `domain-${domainIdx}-component-${compIdx}`;
                        html += `<div class="look-fors-section">`;
                        html += `<div class="look-fors-header" onclick="toggleLookFors('${lookForsId}')">`;
                        html += `<span>Best Practices aligned with 5D+ and PELSB Standards</span>`;
                        html += `<span class="chevron" id="chevron-${lookForsId}">‚ñ∂</span>`;
                        html += `</div>`;
                        html += `<div class="look-fors-content" id="lookForsContent-${lookForsId}">`;
                        html += `<div class="look-fors-grid">`;
                        comp.bestPractices.forEach((practice, practiceIdx) => {
                            const practiceId = `practice-${domainIdx}-${compIdx}-${practiceIdx}`;
                            const sanitizedPractice = escapeHtml(practice);
                            const onchangeHandler = isEvaluator ? `onchange="handleLookForChange(this, '${componentId}')"` : '';
                            
                            // Check if this practice is already selected in existing observation data
                            const existingLookfors = observation?.observationData?.[componentId]?.lookfors || [];
                            const isChecked = existingLookfors.includes(practice);
                            const checkedAttribute = isChecked ? 'checked' : '';
                            
                            html += `<div class="look-for-item">`;
                            html += `<input type="checkbox" id="${practiceId}" ${checkedAttribute} ${onchangeHandler}><label for="${practiceId}">${sanitizedPractice}</label>`;
                            html += `</div>`;
                        });
                        html += `</div></div></div>`;
                    }

                    // Notes & Evidence section (for evaluators only - contains notes editor and media upload)
                    if (isEvaluator) {
                        html += `<div class="evidence-section">`;
                        html += `<div class="evidence-toggle-btn" onclick="toggleEvidenceSection('evidence-${componentId}')">`;
                        html += `<span>üìù Notes & Evidence</span>`;
                        html += `<span class="chevron" id="evidence-chevron-${componentId}">‚ñ∂</span>`;
                        html += `</div>`;
                        html += `<div class="evidence-content" id="evidence-${componentId}">`;
                        
                        // Notes container
                        const sanitizedComponentId = componentId.replace(/[^a-zA-Z0-9]/g, '');
                        html += `<div class="notes-container">`;
                        html += `<h4>Observation Notes</h4>`;
                        html += `<div class="notes-header-actions">`;
                        html += `<button class="clear-notes-btn" onclick="clearNotes('${componentId}')" title="Clear all notes for this component">üóëÔ∏è Clear All</button>`;
                        html += `</div>`;
                        html += `<div id="notes-editor-${sanitizedComponentId}"></div>`;
                        html += `</div>`;
                        
                        // Media upload section
                        let evidenceHtml = '';
                        evidence.forEach(item => { evidenceHtml += `<div class="evidence-item"><a href="${item.url}" target="_blank" rel="noopener noreferrer">${item.name}</a></div>`; });
                        html += `<div class="media-upload-container">`;
                        html += `<h4>Upload Evidence</h4>`;
                        html += `<input type="file" class="media-upload-input" id="media-upload-${componentId}" onchange="uploadSelectedFile('${componentId}')" style="display: none;">`;
                        html += `<button class="media-upload-button" onclick="triggerFileUpload('${componentId}')">üìé Select & Upload File</button>`;
                        html += `<div class="media-links-container" data-component-id="${componentId}">`;
                        html += `<ul>${evidenceHtml}</ul>`;
                        html += `</div></div>`;
                        
                        // Close evidence-content and evidence-section
                        html += `</div></div>`;
                    }
                    html += `</div>`;
                });
                html += `</div>`;
            });
            html += `</div>`;
            return html;
        }

        function updateFilterStatus(rubricData, observation) {
            const status = document.getElementById('filterStatus');
            
            if (observation) {
                // Hide status div completely when viewing observations - main heading provides context
                status.style.display = 'none';
                return;
            }
            
            // Keep existing logic for other contexts (role viewing, etc.)
            const statusText = document.getElementById('filterStatusText');
            let text = 'Viewing Your Own Rubric';
            if (rubricData?.userContext?.filterInfo) {
                text = `Viewing as: ${rubricData.userContext.filterInfo.viewingAs} (${rubricData.userContext.filterInfo.viewingRole}, Year ${rubricData.userContext.filterInfo.viewingYear})`;
            }
            statusText.innerHTML = text;
            status.style.display = 'block';
        }

        function saveObservationMetadata() {
            const obsId = currentObservationId;
            const newName = document.getElementById('observationName').value;
            const newDate = document.getElementById('observationDate').value;

            if (!obsId || !newName || !newDate) return;

            google.script.run
                .withSuccessHandler(res => {
                    if (res.success) {
                        showToast('Observation details saved.', true);
                    } else {
                        showError(res.error);
                    }
                })
                .withFailureHandler(handleError)
                .updateObservationMetadata(obsId, { observationName: newName, observationDate: newDate });
        }

        function selectProficiency(element, componentId, proficiency) {
            if (!currentObservationId || !componentId || !proficiency) {
                console.error('Missing data for proficiency selection:', { currentObservationId, componentId, proficiency });
                return;
            }

            const parentRow = element.closest('.performance-levels-content');
            const currentlySelected = parentRow.querySelector('.level-content.selected');

            // --- Instant UI Update ---
            if (currentlySelected) {
                currentlySelected.classList.remove('selected');
            }
            element.classList.add('selected');

            // --- Background Save ---
            google.script.run
                .withSuccessHandler(function(response) {
                    if (response.success) {
                        console.log('Proficiency saved:', { componentId, proficiency });
                        // Optionally show a subtle success indicator
                    } else {
                        console.error('Failed to save proficiency:', response.error);
                        // --- Revert UI on Failure ---
                        element.classList.remove('selected');
                        if (currentlySelected) {
                            currentlySelected.classList.add('selected');
                        }
                        showToast('Error saving selection: ' + response.error);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Server error saving proficiency:', error);
                    // --- Revert UI on Failure ---
                    element.classList.remove('selected');
                    if (currentlySelected) {
                        currentlySelected.classList.add('selected');
                    }
                    showToast('Server error: ' + error.message);
                })
                .saveProficiencySelection(currentObservationId, componentId, proficiency);
        }
        function uploadFile(fileInput, componentId) {
            const file = fileInput.files[0]; if (!file) return;
            const statusEl = document.getElementById(`upload-status-${componentId}`); statusEl.textContent = 'Uploading...';
            const reader = new FileReader();
            reader.onload = e => {
                const base64Data = e.target.result.split(',')[1];
                google.script.run.withSuccessHandler(result => {
                    if (result.success) {
                        statusEl.textContent = 'Upload complete.'; fileInput.value = '';
                        const listEl = document.getElementById(`evidence-list-${componentId}`);
                        listEl.innerHTML += `<div class="evidence-item"><a href="${result.fileUrl}" target="_blank">${result.fileName}</a></div>`;
                        setTimeout(() => { statusEl.textContent = 'Select another file?'; }, 3000);
                    } else { handleError(result); statusEl.textContent = 'Upload failed.'; }
                }).withFailureHandler(handleError).uploadMediaEvidence(currentObservationId, componentId, base64Data, file.name, file.type);
            };
            reader.readAsDataURL(file);
        }
        function toggleObservationView() { observationViewMode = observationViewMode === 'assigned' ? 'full' : 'assigned'; updateComponentVisibility(); }
        function updateComponentVisibility() {
            const components = document.querySelectorAll('.component-section');
            if (observationViewMode === 'assigned') {
                components.forEach(comp => { comp.style.display = comp.dataset.isAssigned === 'true' ? '' : 'none'; });
            } else {
                components.forEach(comp => { comp.style.display = ''; });
            }
        }
        
        // Global Quill management system - consolidated for both interfaces
        window.globalQuillInstances = window.globalQuillInstances || {};
        window.globalObservationNotes = window.globalObservationNotes || {};
        
        function toggleEvidenceSection(contentId) {
            console.log('toggleEvidenceSection called with:', contentId);
            const content = document.getElementById(contentId);
            if (!content) {
                console.error('Evidence content element not found:', contentId);
                return;
            }
            console.log('Found evidence content element:', content);

            const isExpanded = content.classList.toggle('expanded');
            console.log('Evidence section expanded state:', isExpanded);
            const componentId = contentId.replace('evidence-', '');
            console.log('Component ID:', componentId);

            // Toggle chevron
            const chevron = document.getElementById(`evidence-chevron-${componentId}`);
            if (chevron) {
                chevron.textContent = isExpanded ? '‚ñº' : '‚ñ∂';
            }

            // Initialize Quill on first expansion if not already initialized
            if (isExpanded && !window.globalQuillInstances[componentId]) {
                initializeQuillEditor(componentId);
            } else if (isExpanded) {
                console.log('Quill instance already exists for component:', componentId);
            }

            // Store state in sessionStorage for persistence
            try {
                const storageKey = 'evidenceState_' + (window.pageLoadInfo?.cacheVersion || 'default');
                const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');
                allStates[componentId] = isExpanded;
                sessionStorage.setItem(storageKey, JSON.stringify(allStates));
            } catch (e) {
                console.warn('Could not save evidence section state:', e);
            }
        }

        // Consolidated Quill initialization function - make globally available
        window.initializeQuillEditor = function(componentId) {
            console.log('Attempting to initialize Quill editor for:', componentId);
            const sanitizedComponentId = componentId.replace(/[^a-zA-Z0-9]/g, '');
            const editorId = 'notes-editor-' + sanitizedComponentId;
            const editorElement = document.getElementById(editorId);
            
            if (!editorElement) {
                console.error('Notes editor element not found:', editorId);
                return false;
            }

            // Check if this element already has a Quill instance (prevent duplicates)
            if (editorElement.__quill) {
                console.log('Quill already initialized on this element:', editorId);
                const existingEditor = editorElement.__quill;
                window.globalQuillInstances[componentId] = existingEditor;
                
                // Load existing notes content if available and not already loaded
                if (window.globalObservationNotes[componentId] && 
                    (!existingEditor.root.innerHTML || existingEditor.root.innerHTML === '<p><br></p>')) {
                    existingEditor.root.innerHTML = window.globalObservationNotes[componentId];
                    console.log('Loaded existing notes for component:', componentId);
                }
                
                // Ensure auto-save is set up (check if already has listeners to avoid duplicates)
                if (!existingEditor._hasAutoSaveListener) {
                    let timeout;
                    existingEditor.on('text-change', () => {
                        clearTimeout(timeout);
                        timeout = setTimeout(() => {
                            saveNotes(componentId, existingEditor.root.innerHTML);
                        }, 1500);
                    });
                    existingEditor._hasAutoSaveListener = true;
                    console.log('Auto-save listener attached to existing editor for:', componentId);
                }
                
                return true;
            }
            
            console.log('Found editor element:', editorId);
            try {
                // Check if Quill is available
                if (typeof Quill === 'undefined') {
                    console.error('Quill library failed to load from CDN');
                    showToast('Rich text editor unavailable. Please refresh the page.');
                    return false;
                }
                
                const editor = new Quill(editorElement, {
                    theme: 'snow',
                    modules: {
                        toolbar: [
                            [{ 'header': [1, 2, false] }],
                            ['bold', 'italic', 'underline'],
                            [{'list': 'ordered'}, {'list': 'bullet'}],
                            ['clean']
                        ]
                    }
                });
                console.log('Quill editor created successfully');

                // Load existing notes 
                if (window.globalObservationNotes[componentId]) {
                    editor.root.innerHTML = window.globalObservationNotes[componentId];
                    console.log('Loaded existing notes for component:', componentId);
                }

                // Add debounced auto-save
                let timeout;
                editor.on('text-change', () => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        saveNotes(componentId, editor.root.innerHTML);
                    }, 1500); // Save 1.5 seconds after typing stops
                });
                editor._hasAutoSaveListener = true;

                window.globalQuillInstances[componentId] = editor;
                console.log('Quill editor initialized for component:', componentId);
                return true;
            } catch (error) {
                console.error('Error initializing Quill editor:', error);
                return false;
            }
        }
        
        function saveNotes(componentId, content) {
            if (!currentObservationId) {
                console.error('Cannot save notes: No observation context available.');
                showToast('Error: No active observation found. Cannot save notes.');
                return;
            }

            // Update local data using global storage
            window.globalObservationNotes[componentId] = content;

            google.script.run
                .withSuccessHandler(() => console.log(`Notes saved for ${componentId}`))
                .withFailureHandler(error => {
                    console.error('Failed to save notes:', error);
                    showToast('Error saving notes. Please check your connection.');
                })
                .saveObservationNotes(currentObservationId, componentId, content);
        }

        // Clear all notes for a specific component
        window.clearNotes = function(componentId) {
            if (!confirm(`Are you sure you want to clear all notes for this component?\n\nThis action cannot be undone.`)) {
                return;
            }

            const editor = window.globalQuillInstances[componentId];
            if (editor) {
                editor.setContents([], 'user'); // Clear content and trigger change event
                console.log(`Notes cleared for component: ${componentId}`);
                showToast(`Notes cleared for ${componentId}`, true);
                
                // Immediately save the cleared state
                window.globalObservationNotes[componentId] = '';
                saveNotes(componentId, '');
            } else {
                console.warn(`No editor found for component: ${componentId}`);
                showToast(`No notes to clear for ${componentId}`, false);
            }
        }

        // Recovery mechanism to ensure all components with notes data have editors
        function ensureEditorsForNotesData(isEvaluator) {
            if (!isEvaluator || !window.globalObservationNotes) {
                return;
            }
            
            console.log('Running recovery mechanism for orphaned notes data...');
            
            Object.keys(window.globalObservationNotes).forEach(componentId => {
                const notesContent = window.globalObservationNotes[componentId];
                if (notesContent && notesContent.trim() !== '' && notesContent !== '<p><br></p>') {
                    // Check if editor exists
                    if (!window.globalQuillInstances[componentId]) {
                        console.log(`Found orphaned notes data for ${componentId}, attempting to initialize editor...`);
                        
                        // Check if the evidence section exists but is collapsed
                        const evidenceSectionId = `evidence-${componentId}`;
                        const evidenceSection = document.getElementById(evidenceSectionId);
                        
                        if (evidenceSection) {
                            // Expand the section if collapsed
                            const content = document.getElementById(evidenceSectionId);
                            if (content && !content.classList.contains('expanded')) {
                                console.log(`Expanding collapsed section for ${componentId} to recover notes...`);
                                toggleEvidenceSection(evidenceSectionId);
                            }
                            
                            // Try to initialize the editor with a slight delay
                            setTimeout(() => {
                                if (!window.globalQuillInstances[componentId]) {
                                    console.log(`Force initializing editor for ${componentId}...`);
                                    const success = window.initializeQuillEditor(componentId);
                                    if (success) {
                                        console.log(`Successfully recovered notes editor for ${componentId}`);
                                    } else {
                                        console.warn(`Failed to recover notes editor for ${componentId}`);
                                    }
                                }
                            }, 200);
                        } else {
                            console.warn(`Evidence section not found for ${componentId}, cannot recover notes`);
                        }
                    } else {
                        // Editor exists, ensure content is loaded
                        const editor = window.globalQuillInstances[componentId];
                        if (editor && (!editor.root.innerHTML || editor.root.innerHTML === '<p><br></p>')) {
                            editor.root.innerHTML = notesContent;
                            console.log(`Restored content to existing editor for ${componentId}`);
                        }
                    }
                }
            });
        }

        function triggerFileUpload(componentId) {
            const fileInput = document.getElementById(`media-upload-${componentId}`);
            if (!fileInput) {
                console.error('File input not found for component:', componentId);
                return;
            }
            
            // Trigger the file picker
            fileInput.click();
        }

        function uploadSelectedFile(componentId) {
            const fileInput = document.getElementById(`media-upload-${componentId}`);
            if (!fileInput) {
                console.error('File input not found for component:', componentId);
                return;
            }

            const file = fileInput.files[0];
            if (!file) {
                return; // No file selected, user probably cancelled
            }

            if (!currentObservationId) {
                showToast('No observation selected. Please save the observation first.');
                return;
            }

            showToast('Uploading file...', false);

            // Convert file to base64 for Google Apps Script
            const reader = new FileReader();
            reader.onload = function(e) {
                const fileData = {
                    name: file.name,
                    mimeType: file.type,
                    content: e.target.result.split(',')[1], // Remove data:mime;base64, prefix
                    size: file.size
                };

                google.script.run
                    .withSuccessHandler(function(result) {
                        if (result.success) {
                            showToast('File uploaded successfully!', true);
                            updateMediaLinks(componentId, result.fileUrl, result.fileName);
                            fileInput.value = ''; // Clear the input
                        } else {
                            showToast('Upload failed: ' + result.error);
                        }
                    })
                    .withFailureHandler(function(error) {
                        console.error('Upload error:', error);
                        showToast('Upload failed. Please try again.');
                    })
                    .uploadMediaEvidence(currentObservationId, componentId, fileData.content, fileData.name, fileData.mimeType);
            };
            reader.onerror = function() {
                showToast('Error reading file. Please try again.');
            };
            reader.readAsDataURL(file);
        }

        function updateMediaLinks(componentId, fileUrl, fileName) {
            const linksContainer = document.querySelector(`[data-component-id="${componentId}"] ul`);
            if (linksContainer) {
                const listItem = document.createElement('li');
                listItem.className = 'evidence-item';
                listItem.innerHTML = `<a href="${fileUrl}" target="_blank">${fileName}</a>`;
                linksContainer.appendChild(listItem);
            }
        }
        
        function handleLookForChange(checkbox, componentId) {
            const lookForText = checkbox.nextElementSibling.textContent;
            const isChecked = checkbox.checked;

            if (!currentObservationId) {
                console.error('Cannot save look-for selection: Observation context not available.');
                checkbox.checked = !isChecked; // Revert the checkbox state
                showToast('Error: No active observation found. Cannot save selection.');
                return;
            }

            google.script.run
                .withSuccessHandler(() => {
                    console.log(`Saved look-for: ${componentId} -> ${lookForText}`);
                })
                .withFailureHandler(error => {
                    console.error('Save failed:', error);
                    checkbox.checked = !isChecked; // Revert the checkbox state on failure
                    showToast('Failed to save look-for selection. Please check your connection.');
                })
                .saveLookForSelection(currentObservationId, componentId, lookForText, isChecked);
        }
        
        // === New Sticky Navigation Functions ===
        
        function setViewMode(mode) {
            observationViewMode = mode;
            updateViewToggle();
            updateComponentVisibility();
        }
        
        function updateViewToggle() {
            const assignedToggle = document.getElementById('assignedToggle');
            const fullToggle = document.getElementById('fullToggle');
            const slider = document.getElementById('toggleSlider');
            
            if (!assignedToggle || !fullToggle || !slider) return;
            
            // Update active states
            assignedToggle.classList.toggle('active', observationViewMode === 'assigned');
            fullToggle.classList.toggle('active', observationViewMode === 'full');
            
            // Animate slider position
            const toggleWidth = assignedToggle.offsetWidth;
            if (observationViewMode === 'assigned') {
                slider.style.width = toggleWidth + 'px';
                slider.style.transform = 'translateX(0)';
            } else {
                slider.style.width = fullToggle.offsetWidth + 'px';
                slider.style.transform = `translateX(${toggleWidth}px)`;
            }
        }
        
        function showStickyNav(observation) {
            const stickyNav = document.getElementById('stickyNav');
            const viewToggle = document.getElementById('viewToggle');
            const staffContext = document.getElementById('staffContext');
            const staffName = document.getElementById('staffName');
            const navActions = document.getElementById('navActions');
            const finalizeBtn = document.getElementById('finalizeBtn');
            
            if (!stickyNav) return;
            
            stickyNav.classList.add('show');
            
            if (observation) {
                // Show staff context
                if (staffContext && staffName) {
                    staffName.textContent = observation.observedName || 'N/A';
                    staffContext.style.display = 'block';
                }
                
                // Show view toggle for evaluators
                if (viewToggle && window.rubricData?.userContext?.isEvaluator) {
                    viewToggle.style.display = 'flex';
                    updateViewToggle();
                }
                
                // Show action buttons for draft observations
                if (navActions && observation.status === 'Draft') {
                    navActions.style.display = 'flex';
                }
                
                // Update finalize button text based on status
                if (finalizeBtn) {
                    if (observation.status === 'Draft') {
                        finalizeBtn.textContent = '‚úÖ Finalize & Submit';
                        finalizeBtn.onclick = handleFinalizeFromNav;
                    } else {
                        finalizeBtn.style.display = 'none';
                    }
                }
            }
        }
        
        function hideStickyNav() {
            const stickyNav = document.getElementById('stickyNav');
            if (stickyNav) {
                stickyNav.classList.remove('show');
            }
        }
        
        
        // Update existing functions to work with new nav
        const originalToggleObservationView = toggleObservationView;
        toggleObservationView = function() {
            originalToggleObservationView();
            updateViewToggle();
        };

        document.addEventListener('DOMContentLoaded', () => {
          showView('quickActionsView');
        });

        // Consolidated recording state management
        const recordingState = {
            audio: { recorder: null, stream: null, isRecording: false },
            video: { recorder: null, stream: null, isRecording: false }
        };

        // Recording configuration
        const recordingConfig = {
            audio: {
                constraints: { audio: true },
                buttonId: 'recordAudioBtn',
                startText: 'üõë Stop Audio',
                stopText: 'üé§ Record Audio',
                errorMessage: 'Error accessing microphone: '
            },
            video: {
                constraints: { video: true, audio: true },
                buttonId: 'recordVideoBtn', 
                startText: 'üõë Stop Video',
                stopText: 'üìπ Record Video',
                errorMessage: 'Error accessing camera: '
            }
        };

        async function toggleRecording(type) {
            const state = recordingState[type];
            const config = recordingConfig[type];
            const btn = document.getElementById(config.buttonId);

            if (!state.isRecording) {
                try {
                    state.stream = await navigator.mediaDevices.getUserMedia(config.constraints);
                    state.recorder = new MediaRecorder(state.stream);

                    const chunks = [];
                    state.recorder.ondataavailable = event => chunks.push(event.data);

                    state.recorder.onstop = () => {
                        const mimeType = type === 'audio' ? 'audio/webm' : 'video/webm';
                        const blob = new Blob(chunks, { type: mimeType });
                        uploadRecording(blob, type);
                    };

                    state.recorder.start();
                    state.isRecording = true;
                    btn.textContent = config.startText;
                    btn.classList.add('recording');

                } catch (error) {
                    showToast(config.errorMessage + error.message, false);
                }
            } else {
                state.recorder.stop();
                state.stream.getTracks().forEach(track => track.stop());
                state.isRecording = false;
                btn.textContent = config.stopText;
                btn.classList.remove('recording');
            }
        }

        // Wrapper functions for backwards compatibility
        async function toggleAudioRecording() {
            await toggleRecording('audio');
        }

        async function toggleVideoRecording() {
            await toggleRecording('video');
        }

        function uploadRecording(blob, type) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `${type}-recording-${timestamp}.webm`;

            // Convert blob to base64
            const reader = new FileReader();
            reader.onload = function() {
                const base64Data = reader.result.split(',')[1];

                google.script.run
                    .withSuccessHandler(function(result) {
                        if (result.success) {
                            showToast(`${type} recording saved successfully!`, true);
                            // Add to global recordings list
                            addGlobalRecording(result.fileUrl, filename, type);
                        } else {
                            showToast(`Error saving ${type} recording: ` + result.error, false);
                        }
                    })
                    .withFailureHandler(function(error) {
                        showToast(`Failed to save ${type} recording: ` + error.message, false);
                    })
                    .uploadGlobalRecording(currentObservationId, base64Data, filename, type);
            };
            reader.readAsDataURL(blob);
        }

        function addGlobalRecording(fileUrl, filename, type) {
            // Placeholder for now
            console.log(`Recording saved: ${type} at ${fileUrl} with name ${filename}`);
        }

        // === Script Editor Functions ===
        const SCRIPT_EDITOR_CONSTANTS = <?!= JSON.stringify(scriptEditorSettings) ?>;
        let scriptQuill = null;
        let scriptContent = {};
        const SILENT_SAVE_DEBOUNCE_MS = 5000;
        let isScriptDirty = false;
        let scriptSaveDebounceTimer;
        let isSavingScript = false;

        function updateSaveButtonState() {
            const saveBtn = document.getElementById('saveScriptBtn');
            if (!saveBtn) return;

            if (isScriptDirty) {
                saveBtn.textContent = 'Save all changes';
                saveBtn.disabled = false;
                saveBtn.classList.remove('btn-secondary');
                saveBtn.classList.add('btn-primary');
            } else {
                saveBtn.textContent = 'Saved!';
                saveBtn.disabled = true;
                saveBtn.classList.remove('btn-primary');
                saveBtn.classList.add('btn-secondary');
            }
        }

        function openScriptEditor() {
            const modal = document.getElementById('scriptEditorModal');
            modal.style.display = 'flex';

            // Clear any pending auto-save timer when opening editor
            clearTimeout(scriptSaveDebounceTimer);

            if (!scriptQuill) {
                // Initialize Quill editor using constants
                scriptQuill = new Quill('#scriptEditor', {
                    theme: 'snow',
                    modules: {
                        toolbar: SCRIPT_EDITOR_CONSTANTS.TOOLBAR_OPTIONS
                    }
                });

                // Load existing content
                loadScriptContent();

                // Auto-save on content change
                scriptQuill.on('text-change', function(delta, oldDelta, source) {
                    if (source === 'user') {
                        isScriptDirty = true;
                        updateSaveButtonState();
                        clearTimeout(scriptSaveDebounceTimer);
                        scriptSaveDebounceTimer = setTimeout(() => {
                            silentSaveScriptContent();
                        }, SILENT_SAVE_DEBOUNCE_MS);
                    }
                });
            }
            isScriptDirty = false;
            updateSaveButtonState();
        }

        function closeScriptEditor() {
            if (isScriptDirty) {
                if (!confirm('You have unsaved changes that will be lost. Are you sure you want to close?')) {
                    return;
                }
            }
            // Clear any pending auto-save timer
            clearTimeout(scriptSaveDebounceTimer);
            const modal = document.getElementById('scriptEditorModal');
            modal.style.display = 'none';
            isScriptDirty = false;
        }

        function manualSaveScriptContent() {
            if (!scriptQuill || !currentObservationId || isSavingScript) return;

            showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SAVING, false);
            saveScriptContent().then(success => {
                if (success) {
                    showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SAVED, true);
                }
            }).catch(error => {
                // Log errors, but don't show a toast as saveScriptContent already does.
                console.warn("Could not manually save script:", error.message);
            });
        }

        function silentSaveScriptContent() {
            if (!scriptQuill || !currentObservationId || !isScriptDirty || isSavingScript) return;
            console.log('Silently saving script content...');
            saveScriptContent().catch(error => {
                // Silent saves should not bother the user, so just log.
                console.warn("Could not silently save script:", error.message);
            });
        }

        function saveScriptContent() {
            return new Promise((resolve, reject) => {
                if (isSavingScript) {
                    reject(new Error('A save operation is already in progress.'));
                    return;
                }
                if (!scriptQuill || !currentObservationId) {
                    reject(new Error('Quill editor or observation ID is not available.'));
                    return;
                }

                isSavingScript = true;
                const content = scriptQuill.getContents();
                scriptContent = content; // Keep local copy

                google.script.run
                    .withSuccessHandler(function(result) {
                        isSavingScript = false;
                        if (result.success) {
                            isScriptDirty = false;
                            updateSaveButtonState();
                            resolve(true);
                        } else {
                            console.error('Failed to save script content:', result.error);
                            showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.ERROR_SAVING + result.error, false);
                            reject(new Error(result.error || 'Unknown save error'));
                        }
                    })
                    .withFailureHandler(function(error) {
                        isSavingScript = false;
                        console.error('Error saving script content:', error);
                        showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SERVER_ERROR + error.message, false);
                        reject(error);
                    })
                    .updateObservationScript(currentObservationId, content);
            });
        }

        function loadScriptContent() {
            if (!currentObservationId) {
                console.warn('Cannot load script content: currentObservationId is not set');
                return;
            }
            google.script.run
                .withSuccessHandler(function(content) {
                    if (!scriptQuill) return;
                    if (content && typeof content === 'object' && Object.keys(content).length > 0) {
                        scriptQuill.setContents(content, 'silent');
                        scriptContent = content;
                    } else {
                        scriptQuill.setContents([], 'silent');
                        scriptContent = {};
                    }
                    isScriptDirty = false;
                    updateSaveButtonState();
                })
                .withFailureHandler(function(error) {
                    console.error('Error loading script content:', error);
                    showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.LOAD_ERROR + error.message, false);
                })
                .getObservationScript(currentObservationId);
        }

        function exportScriptPDF() {
            if (!currentObservationId) {
                showToast('No observation context found', false);
                return;
            }

            // Show loading state
            const exportBtn = document.querySelector('button[onclick="exportScriptPDF()"]');
            const originalText = exportBtn ? exportBtn.textContent : 'Export PDF';
            if (exportBtn) {
                exportBtn.disabled = true;
                exportBtn.textContent = 'Saving...';
            }

            // Save current script content first and wait for completion
            if (scriptQuill) {
                const content = scriptQuill.getContents();
                scriptContent = content; // Keep local copy

                showToast('Saving script content...', true);

                // Save script content and wait for completion before generating PDF
                google.script.run
                    .withSuccessHandler(function(saveResult) {
                        if (saveResult.success) {
                            // Script saved successfully, now generate PDF
                            if (exportBtn) {
                                exportBtn.textContent = 'Generating PDF...';
                            }
                            showToast('Generating script PDF...', true);
                            
                            // Generate PDF via server
                            google.script.run
                                .withSuccessHandler(function(result) {
                                    if (exportBtn) {
                                        exportBtn.disabled = false;
                                        exportBtn.textContent = originalText;
                                    }
                                    
                                    if (result.success) {
                                        showToast('Script PDF generated successfully!', true);
                                        // Open PDF in new tab
                                        if (result.pdfUrl) {
                                            window.open(result.pdfUrl, '_blank');
                                        }
                                    } else {
                                        showToast('Error generating script PDF: ' + result.error, false);
                                    }
                                })
                                .withFailureHandler(function(error) {
                                    if (exportBtn) {
                                        exportBtn.disabled = false;
                                        exportBtn.textContent = originalText;
                                    }
                                    showToast('Failed to generate script PDF: ' + error.message, false);
                                    console.error('Script PDF generation failed:', error);
                                })
                                .generateScriptPDF(currentObservationId);
                        } else {
                            // Save failed
                            if (exportBtn) {
                                exportBtn.disabled = false;
                                exportBtn.textContent = originalText;
                            }
                            showToast('Failed to save script content: ' + saveResult.error, false);
                        }
                    })
                    .withFailureHandler(function(error) {
                        if (exportBtn) {
                            exportBtn.disabled = false;
                            exportBtn.textContent = originalText;
                        }
                        showToast('Error saving script content: ' + error.message, false);
                        console.error('Script save failed:', error);
                    })
                    .updateObservationScript(currentObservationId, content);
            } else {
                // No script content to save, directly generate PDF
                if (exportBtn) {
                    exportBtn.textContent = 'Generating PDF...';
                }
                showToast('Generating script PDF...', true);
                
                // Generate PDF via server
                google.script.run
                    .withSuccessHandler(function(result) {
                        if (exportBtn) {
                            exportBtn.disabled = false;
                            exportBtn.textContent = originalText;
                        }

                        if (result.success) {
                            showToast('Script PDF generated successfully!', true);
                            // Open PDF in new tab
                            if (result.pdfUrl) {
                                window.open(result.pdfUrl, '_blank');
                            }
                        } else {
                            showToast('Error generating script PDF: ' + (result.error || 'Unknown error'), false);
                        }
                    })
                    .withFailureHandler(function(error) {
                        if (exportBtn) {
                            exportBtn.disabled = false;
                            exportBtn.textContent = originalText;
                        }
                        showToast('Failed to generate script PDF: ' + error.message, false);
                        console.error('Script PDF generation failed:', error);
                    })
                    .generateScriptPDF(currentObservationId);
            }
        }

        // === Component Tagging System ===
        let componentTags = {};
        const TAG_COLORS = {
            '1a:': '#e3f2fd', '1b:': '#f3e5f5', '1c:': '#e8f5e8', '1d:': '#fff3e0',
            '1e:': '#fce4ec', '1f:': '#e0f2f1', '2a:': '#e1f5fe', '2b:': '#f1f8e9',
            '2c:': '#fef7e0', '2d:': '#ede7f6', '2e:': '#fcf2ff', '3a:': '#e8eaf6',
            '3b:': '#f9fbe7', '3c:': '#fff8e1', '3d:': '#ffebee', '4a:': '#e0f7fa',
            '4b:': '#f0f4c3', '4c:': '#ffe0b2', '4d:': '#d1c4e9', '4e:': '#ffcdd2',
            '4f:': '#b2dfdb'
        };

        function populateComponentSelector() {
            const selector = document.getElementById('componentSelector');
            if (!selector) {
                console.warn('Component selector element not found');
                return;
            }
            
            // Check if rubric data is available (using the same source as the main rubric)
            if (window.rubricData && window.rubricData.domains && window.rubricData.domains.length > 0) {
                // Data is available, populate the selector
                selector.innerHTML = '<option value="">Select Component to Tag</option>';
                
                let hasComponents = false;
                window.rubricData.domains.forEach(domain => {
                    if (domain.components && domain.components.length > 0) {
                        domain.components.forEach(component => {
                            // Only show assigned components to match main rubric behavior
                            if (component.isAssigned) {
                                const option = document.createElement('option');
                                option.value = component.componentId;
                                option.textContent = `${domain.name}: ${component.title}`;
                                selector.appendChild(option);
                                hasComponents = true;
                            }
                        });
                    }
                });
                
                if (!hasComponents) {
                    selector.innerHTML = '<option value="">No components available</option>';
                    console.warn('Rubric data exists but contains no components');
                }
            } else {
                // Rubric data not available - this should not happen if called after rubric is loaded
                selector.innerHTML = '<option value="">Rubric data not loaded</option>';
                console.warn('Component selector called but rubric data not available:', {
                    hasWindow: typeof window !== 'undefined',
                    hasRubricData: !!window.rubricData,
                    hasDomains: window.rubricData && !!window.rubricData.domains,
                    domainsLength: window.rubricData && window.rubricData.domains ? window.rubricData.domains.length : 'N/A'
                });
            }
        }

        function tagSelectedText() {
            if (!scriptQuill) {
                showToast('Script editor not initialized', false);
                return;
            }
            
            const range = scriptQuill.getSelection();
            if (!range || range.length === 0) {
                showToast('Please select text to tag', false);
                return;
            }
            
            const componentId = document.getElementById('componentSelector').value;
            if (!componentId) {
                showToast('Please select a component', false);
                return;
            }
            
            // Get the selected text
            const selectedText = scriptQuill.getText(range.index, range.length);
            if (!selectedText.trim()) {
                showToast('Selected text is empty', false);
                return;
            }
            
            // Apply visual formatting to tagged text
            const tagColor = TAG_COLORS[componentId] || '#e3f2fd';
            scriptQuill.formatText(range.index, range.length, 'background', tagColor);
            scriptQuill.formatText(range.index, range.length, 'color', '#1565c0');
            
            // Store tag information
            const tagData = {
                componentId: componentId,
                start: range.index,
                length: range.length,
                text: selectedText.trim(),
                timestamp: new Date().toISOString(),
                color: tagColor
            };
            
            if (!componentTags[componentId]) {
                componentTags[componentId] = [];
            }
            componentTags[componentId].push(tagData);
            
            // Update status
            document.getElementById('tagStatus').textContent = 
                `Tagged "${selectedText.substring(0, 30)}${selectedText.length > 30 ? '...' : ''}" to ${componentId}`;
            
            // Save tags
            saveComponentTags();
            
            showToast('Text tagged successfully', true);
        }

        function pushTaggedToNotes() {
            const allTags = Object.keys(componentTags);
            if (allTags.length === 0) {
                showToast('No tagged evidence to push.', false);
                return;
            }

            let pushedCount = 0;
            allTags.forEach(componentId => {
                const tags = componentTags[componentId];
                if (tags && tags.length > 0) {
                    let notesEditor = window.globalQuillInstances && window.globalQuillInstances[componentId];
                    if (!notesEditor) {
                        const evidenceSectionId = `evidence-${componentId}`;
                        const evidenceSection = document.getElementById(evidenceSectionId);
                        if (evidenceSection) {
                            toggleEvidenceSection(evidenceSectionId);
                            const attemptPush = (retries = 8) => { // Increased retries
                                if (retries <= 0) {
                                    console.warn(`Could not initialize notes editor for ${componentId} after multiple attempts.`);
                                    showToast(`Could not push to ${componentId} notes - editor initialization failed`, false);
                                    return;
                                }
                                
                                // Try to force initialization if editor doesn't exist
                                if (!window.globalQuillInstances[componentId]) {
                                    console.log(`Attempting to force initialize editor for ${componentId}, retries left: ${retries}`);
                                    window.initializeQuillEditor(componentId);
                                }
                                
                                notesEditor = window.globalQuillInstances && window.globalQuillInstances[componentId];
                                if (notesEditor) {
                                    completePushToNotes(componentId, tags, notesEditor);
                                } else {
                                    setTimeout(() => attemptPush(retries - 1), 300); // Increased delay
                                }
                            };
                            attemptPush();
                        } else {
                            console.warn(`Evidence section not found for ${componentId}.`);
                            showToast(`Could not find notes section for ${componentId}`, false);
                        }
                    } else {
                        completePushToNotes(componentId, tags, notesEditor);
                    }
                    pushedCount++;
                }
            });

            if (pushedCount > 0) {
                showToast(`Pushed all tagged evidence to their respective notes sections.`, true);
                document.getElementById('tagStatus').textContent = `Pushed all tagged evidence to notes.`;
            } else {
                showToast('No tagged evidence to push.', false);
            }
        }
        
        function completePushToNotes(componentId, tags, notesEditor) {
            // Combine all tagged text for this component
            const taggedContent = tags.map(tag => tag.text).join('\n\n');
            
            // Get current notes content
            const currentContent = notesEditor.root.innerHTML;
            const separator = currentContent && currentContent !== '<p><br></p>' ? '\n\n' : '';
            const scriptHeader = '<p><strong>From Script:</strong></p>';
            const newContent = currentContent + separator + scriptHeader + '<p>' + taggedContent.replace(/\n/g, '</p><p>') + '</p>';
            
            // Update notes editor
            notesEditor.root.innerHTML = newContent;
            
            // Trigger save
            setTimeout(() => {
                const event = new Event('input', { bubbles: true });
                notesEditor.root.dispatchEvent(event);
            }, 100);
            
            document.getElementById('tagStatus').textContent = 
                `Pushed ${tags.length} tagged item(s) to ${componentId} notes`;
            
            showToast(`Tagged content added to ${componentId} notes`, true);
        }

        function clearComponentTags() {
            const componentId = document.getElementById('componentSelector').value;
            if (!componentId) {
                // Clear all tags
                if (confirm('Clear all component tags from the script?')) {
                    componentTags = {};
                    // Remove all formatting - this is a simplified approach
                    if (scriptQuill) {
                        const length = scriptQuill.getLength();
                        scriptQuill.removeFormat(0, length);
                    }
                    saveComponentTags();
                    document.getElementById('tagStatus').textContent = 'All tags cleared';
                    showToast('All tags cleared', true);
                }
            } else {
                // Clear tags for specific component
                if (componentTags[componentId] && componentTags[componentId].length > 0) {
                    if (confirm(`Clear all tags for component ${componentId}?`)) {
                        delete componentTags[componentId];
                        saveComponentTags();
                        document.getElementById('tagStatus').textContent = `Tags cleared for ${componentId}`;
                        showToast(`Tags cleared for ${componentId}`, true);
                    }
                }
            }
        }

        function saveComponentTags() {
            if (!currentObservationId) return;
            
            google.script.run
                .withSuccessHandler(function(result) {
                    if (result.success) {
                        console.log('Component tags saved successfully');
                    } else {
                        console.error('Failed to save component tags:', result.error);
                        showToast('Failed to save tags: ' + result.error, false);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Error saving component tags:', error);
                    showToast('Error saving tags: ' + error.message, false);
                })
                .saveComponentTags(currentObservationId, componentTags);
        }

        function loadComponentTags() {
            if (!currentObservationId) return;
            
            google.script.run
                .withSuccessHandler(function(tags) {
                    if (tags) {
                        componentTags = tags;
                        // Could restore visual formatting here if needed
                        console.log('Component tags loaded:', componentTags);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Error loading component tags:', error);
                })
                .getComponentTags(currentObservationId);
        }

        // Extend the openScriptEditor function to initialize component selector
        const originalOpenScriptEditor = openScriptEditor;
        openScriptEditor = function() {
            originalOpenScriptEditor();
            // Populate component selector when script editor opens
            setTimeout(() => {
                populateComponentSelector();
                loadComponentTags();
            }, 100);
        };
    </script>

    <!-- Loading Overlay -->
    <div class="loading" id="loading">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">Loading...</div>
        </div>
    </div>

    <!-- Script Editor Modal -->
    <div class="script-editor-modal" id="scriptEditorModal" style="display: none;">
        <div class="script-editor-container">
            <div class="script-editor-header">
                <h2>Observation Script Editor</h2>
                <div class="script-editor-controls">
                    <button id="saveScriptBtn" class="btn-secondary" onclick="manualSaveScriptContent()" disabled>Saved!</button>
                    <button class="btn-secondary" onclick="closeScriptEditor()">Close</button>
                    <button class="btn-primary" onclick="exportScriptPDF()">Export PDF</button>
                </div>
            </div>
            
            <!-- Component Tagging Toolbar -->
            <div class="script-tagging-toolbar">
                <div class="tagging-controls">
                    <select id="componentSelector" class="component-selector">
                        <option value="">Select Component to Tag</option>
                    </select>
                    <button class="btn-tag" onclick="tagSelectedText()">üè∑Ô∏è Tag Selection</button>
                    <button class="btn-push" onclick="pushTaggedToNotes()">‚û°Ô∏è Push Tagged to Notes</button>
                    <button class="btn-clear-tags" onclick="clearComponentTags()">üóëÔ∏è Clear Tags</button>
                </div>
                <div class="tag-status" id="tagStatus">
                    Select text and choose a component to create tags
                </div>
            </div>
            
            <div class="script-editor-content">
                <div id="scriptEditor"></div>
            </div>
        </div>
    </div>
</body>
</html>