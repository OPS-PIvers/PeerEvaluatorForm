<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><?= userContext.role ?> - Select Rubric View</title>
    
    <!-- Content Security Policy - Allow framing from same origin and Google domains -->
    <meta http-equiv="Content-Security-Policy" content="frame-ancestors 'self' https://*.google.com;">
    
    <!-- Quill.js for rich text editing -->
    <link href="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.js"></script>
    <!-- Lame.js for MP3 encoding -->
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <style>
:root {
    --color-white: white;
    --color-text-default: #333;
    --color-bg-body: #f5f5f5;

    /* Greens for toggle button and assignments */
    --color-green-base: #10b981;
    --color-green-dark: #059669;
    --color-green-darker: #047857;
    --color-green-light-bg: #f0fdf4;

    /* Ambers for toggle button (assigned mode) and active filters */
    --color-amber-base: #f59e0b;
    --color-amber-dark: #d97706;
    --color-amber-darker: #b45309;
    --color-amber-light-bg: #fef3c7;
    --color-amber-text-dark: #92400e;

    /* Blues for filter status and select focus */
    --color-blue-base: #3b82f6;
    --color-blue-dark: #2563eb;
    --color-blue-light-bg: #dbeafe;
    --color-blue-text-dark: #1e40af;
    --color-blue-focus-shadow: rgba(59, 130, 246, 0.1);

    /* Grays for various UI elements */
    --color-gray-text: #4a5568;
    --color-gray-text-light: #374151;
    --color-gray-border-light: #d1d5db;
    --color-gray-border-medium: #e2e8f0;
    --color-gray-bg-light: #f8fafc;
    --color-gray-bg-medium: #6b7280;
    --color-gray-bg-dark: #4b5563;
    --color-gray-component-not-assigned-border: #e5e7eb;
    --color-gray-assignment-indicator-not-assigned-bg: #e5e7eb;
    --color-text-deemphasized: #718096;

    /* Reds for destructive actions */
    --color-red-base: #dc2626;
    --color-red-dark: #b91c1c;
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg-body);
            padding: 20px;
            line-height: 1.6;
            color: var(--color-text-default);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--color-white);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header {
            background: linear-gradient(135deg, #4a5568, #2d3748);
            color: var(--color-white);
            padding: 40px 30px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 101;
            border-radius: 12px 12px 0 0;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .content {
            padding: 40px 30px;
        }

        /* Dashboard-specific styles */
        .quick-actions { margin-bottom: 40px; }
        .section-title {
            color: var(--color-gray-text);
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .action-card {
            background: var(--color-white);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        .action-card:hover {
            border-color: var(--color-blue-base);
            background: var(--color-gray-bg-light);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        .action-icon { font-size: 2.5rem; margin-bottom: 15px; display: block; }
        .action-title { font-weight: 600; color: var(--color-gray-text-light); font-size: 1.1rem; margin-bottom: 8px; }
        .action-desc { color: var(--color-text-deemphasized); font-size: 0.95rem; }

        /* Staff List Styles */
        .staff-filter-container {
            margin-bottom: 25px;
            display: flex;
            justify-content: center;
        }

        .filter-toggle-group {
            display: flex;
            background: var(--color-white);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 8px;
            overflow: hidden;
        }

        .filter-toggle-btn {
            padding: 12px 24px;
            background: var(--color-white);
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--color-gray-text-light);
            transition: all 0.2s ease;
            border-right: 1px solid var(--color-gray-border-medium);
        }

        .filter-toggle-btn:last-child {
            border-right: none;
        }

        .filter-toggle-btn:hover {
            background: var(--color-gray-bg-light);
            color: var(--color-blue-base);
        }

        .filter-toggle-btn.active {
            background: var(--color-blue-base);
            color: var(--color-white);
        }

        .staff-list-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .staff-list-item {
            background: var(--color-white);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .staff-list-item:hover {
            border-color: var(--color-blue-base);
            background: var(--color-gray-bg-light);
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .staff-item-main {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .staff-item-icon {
            font-size: 1.8rem;
            color: var(--color-blue-base);
        }

        .staff-item-info {
            display: flex;
            flex-direction: column;
        }

        .staff-item-name {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--color-gray-text-light);
            margin-bottom: 4px;
        }

        .staff-item-details {
            font-size: 0.9rem;
            color: var(--color-text-deemphasized);
        }

        .staff-item-year-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .staff-item-year-badge.tenured {
            background: var(--color-green-light);
            color: var(--color-green-dark);
            border: 1px solid var(--color-green-base);
        }

        .staff-item-year-badge.probationary {
            background: var(--color-orange-light);
            color: var(--color-orange-dark);
            border: 1px solid var(--color-orange-base);
        }

        /* Responsive adjustments for staff list */
        @media (max-width: 768px) {
            .staff-list-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }

            .staff-item-main {
                width: 100%;
            }

            .filter-toggle-btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
        }

        /* Filter controls */
        .custom-filters, .observation-selector {
            background: var(--color-gray-bg-light);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 12px;
            padding: 30px;
            display: none;
        }
        .filter-row { display: flex; gap: 15px; margin-bottom: 20px; align-items: center; flex-wrap: wrap; }
        .filter-select {
            padding: 12px 15px;
            border: 1px solid var(--color-gray-border-light);
            border-radius: 8px;
            font-size: 1rem;
            background: var(--color-white);
            transition: all 0.3s ease;
            flex: 1;
            min-width: 200px;
        }
        .filter-select:focus {
            outline: none;
            border-color: var(--color-blue-base);
            box-shadow: 0 0 0 3px var(--color-blue-focus-shadow);
        }

        /* Read-only field styling to mimic input boxes */
        .obs-field-display {
            padding: 12px 15px;
            border: 1px solid var(--color-gray-border-light);
            border-radius: 8px;
            font-size: 1rem;
            background: var(--color-gray-background-light);
            flex: 1;
            min-width: 200px;
            color: var(--color-gray-text-medium);
            cursor: default;
            display: inline-block;
            line-height: 1.4;
            letter-spacing: 0.3px;
        }

        .obs-name-field {
            font-weight: 500;
        }

        .obs-date-field {
            font-weight: normal;
        }
        .filter-btn {
            background: var(--color-blue-base);
            color: var(--color-white);
            border: 2px solid var(--color-blue-base);
            cursor: pointer;
            font-weight: 600;
            min-width: 140px;
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        .filter-btn:hover:not(:disabled) { background: #2c5aa0; border-color: #2c5aa0; }
        .filter-btn:disabled { background: #cbd5e0; border-color: #cbd5e0; cursor: not-allowed; }
        .btn-secondary { 
            background: var(--color-gray-bg-medium); 
            border: 2px solid var(--color-gray-bg-medium);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .btn-secondary:hover { 
            background: var(--color-gray-bg-dark); 
            border-color: var(--color-gray-bg-dark);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(75, 85, 99, 0.2);
        }
        
        .btn-primary {
            background: var(--color-blue-base);
            border: 2px solid var(--color-blue-base);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary:hover {
            background: var(--color-blue-dark);
            border-color: var(--color-blue-dark);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
        }

        /* Loading Overlay */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .loading-content {
            background: var(--color-white);
            color: var(--color-blue-text-dark);
            border: 2px solid var(--color-blue-base);
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            min-width: 300px;
        }
        .loading-spinner { 
            display: inline-block; 
            width: 40px; 
            height: 40px; 
            border: 4px solid rgba(59, 130, 246, 0.3); 
            border-radius: 50%; 
            border-top-color: var(--color-blue-base); 
            animation: spin 1s ease-in-out infinite; 
            margin-bottom: 15px; 
        }
        .loading-text {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--color-gray-text-light);
        }
        
        /* Error states */
        .error { text-align: center; padding: 40px; margin: 20px 0; border-radius: 12px; display: none; background: #fef2f2; color: #dc2626; border: 2px solid #fecaca; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Status badges and action buttons */
        .status-badge { display: inline-block; padding: 4px 10px; font-size: 0.8rem; font-weight: 600; border-radius: 9999px; }
        .status-draft { background-color: var(--color-amber-light-bg); color: var(--color-amber-text-dark); }
        .status-finalized { background-color: var(--color-green-light-bg); color: var(--color-green-darker); }
        .btn-edit { background: #3b82f6; border-color: #3b82f6; }
        .btn-edit:hover { background: #2563eb; border-color: #2563eb; }
        .btn-finalize { background: var(--color-green-base); border-color: var(--color-green-base); }
        .btn-finalize:hover { background: var(--color-green-dark); border-color: var(--color-green-dark); }
        .btn-delete { background: var(--color-red-base); border-color: var(--color-red-base); }
        .btn-delete:hover { background: var(--color-red-dark); border-color: var(--color-red-dark); }
        .btn-view { background: #3b82f6; border-color: #3b82f6; }
        .btn-view:hover { background: #2563eb; border-color: #2563eb; }
        .btn-export { background: var(--color-green-base); border-color: var(--color-green-base); }
        .btn-export:hover { background: var(--color-green-dark); border-color: var(--color-green-dark); }

        /* NEW LIST VIEW STYLES */
        .action-buttons-section {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .observation-filter-section {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        .observation-filter-toggle {
            display: flex;
            background: var(--color-white);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 8px;
            overflow: hidden;
        }

        .observation-filter-btn {
            padding: 10px 20px;
            background: var(--color-white);
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--color-gray-text-light);
            transition: all 0.2s ease;
            border-right: 1px solid var(--color-gray-border-medium);
        }

        .observation-filter-btn:last-child {
            border-right: none;
        }

        .observation-filter-btn.active {
            background: var(--color-blue-base);
            color: white;
        }

        .observation-filter-btn:hover:not(.active) {
            background: var(--color-gray-bg-light);
        }

        .observations-list-container {
            background: var(--color-white);
            border: 1px solid var(--color-gray-border-medium);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .observations-list-header {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr 1fr 2fr;
            gap: 20px;
            align-items: center;
            padding: 16px 20px;
            background: var(--color-gray-bg-light);
            border-bottom: 1px solid var(--color-gray-border-medium);
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--color-gray-text-light);
        }

        .observations-list-item {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr 1fr 2fr;
            gap: 20px;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--color-gray-border-light);
            transition: all 0.2s ease;
        }

        .observations-list-item:last-child {
            border-bottom: none;
        }

        .observations-list-item:hover {
            background: var(--color-gray-bg-light);
        }

        .obs-list-title {
            font-weight: 600;
            color: var(--color-gray-text-light);
            font-size: 1rem;
        }

        .obs-list-date {
            color: var(--color-text-deemphasized);
            font-size: 0.9rem;
        }

        .obs-list-type {
            color: var(--color-gray-text-light);
            font-size: 0.9rem;
        }

        .obs-list-creator {
            color: var(--color-gray-text-light);
            font-size: 0.9rem;
        }

        .obs-list-status {
            display: flex;
            align-items: center;
        }

        .obs-list-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .obs-list-actions .filter-btn {
            padding: 6px 12px;
            font-size: 0.85rem;
            min-width: auto;
        }

        .empty-observations-message {
            padding: 40px 20px;
            text-align: center;
            color: var(--color-text-deemphasized);
            font-style: italic;
        }

        .observation-metadata-editor {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        .observation-metadata-display {
            padding: 20px 20px 0 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        /* Finalized Observation Header */
        .finalized-observation-header {
            padding: 12px 20px;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border-bottom: 1px solid #047857;
        }

        .finalized-status {
            margin-bottom: 4px;
        }

        .status-indicator {
            font-weight: 600;
            font-size: 0.85rem;
        }

        .observation-details {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .obs-name {
            font-weight: 600;
            font-size: 1.0rem;
        }

        .obs-date {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        /* Read-only Evidence Sections */
        .readonly-evidence .evidence-content {
            background: #f8fafc;
        }

        .readonly-notes-content {
            padding: 15px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            line-height: 1.6;
            color: #374151;
        }

        .no-notes-message {
            padding: 15px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            color: #6b7280;
            font-style: italic;
            text-align: center;
        }

        /* Read-only evidence sections use standard toggle styling */
        .readonly-evidence .evidence-content {
            border-left: 3px solid #10b981;
        }

        .global-tools-bar {
            background: var(--color-white);
            border-bottom: 2px solid var(--color-gray-border-medium);
            padding: 16px 24px;
            display: flex;
            justify-content: center;
        }

        .global-tools-container {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .global-tool-btn {
            background: var(--color-blue-base);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .global-tool-btn:hover {
            background: var(--color-blue-dark);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }
        
        .global-tool-btn:active {
            background: var(--color-blue-dark);
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
        }

        .global-tool-btn.recording {
            background: var(--color-red-base);
            animation: pulse 1.5s infinite;
        }

        .global-tool-btn.processing, .ql-stt-button.processing {
            background: var(--color-orange-base);
            animation: pulse 1.5s infinite;
        }

        /* Recording Timer Display Styling */
        .timer-display {
            margin: 8px 0;
            font-size: 0.9rem;
        }

        .recording-timer {
            background: var(--color-gray-bg-light);
            border: 1px solid var(--color-gray-border-light);
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            min-width: 200px;
        }

        .timer-info {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--color-text-main);
        }

        .timer-progress {
            background: var(--color-gray-bg-medium);
            border-radius: 3px;
            height: 6px;
            overflow: hidden;
        }

        .progress-bar {
            background: var(--color-green-base);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .timer-warning .recording-timer {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .timer-warning .timer-info {
            color: #856404;
        }

        .timer-warning .progress-bar {
            background: var(--color-red-base);
        }

        /* Speech-to-Text Button Styling */
        .ql-stt-button {
            background: var(--color-blue-base);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
            min-width: 32px;
            height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .ql-stt-button:hover {
            background: var(--color-blue-light);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .ql-stt-button:active {
            background: var(--color-blue-dark);
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
        }

        .ql-stt-button.recording {
            background: var(--color-red-base);
            animation: pulse 1.5s infinite;
        }

        .ql-stt-button.recording:hover {
            background: var(--color-red-light);
        }

        .ql-stt-button:disabled {
            background: var(--color-gray-light);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* PDF Button States */
        .btn-pdf-failed { 
            background: #f97316; 
            border-color: #f97316; 
            position: relative;
        }
        .btn-pdf-failed:hover { 
            background: #ea580c; 
            border-color: #ea580c; 
        }
        .btn-pdf-failed:before {
            content: "⚠️ ";
            margin-right: 4px;
        }
        
        .btn-pdf-missing { 
            background: #6b7280; 
            border-color: #6b7280; 
            position: relative;
        }
        .btn-pdf-missing:hover { 
            background: #4b5563; 
            border-color: #4b5563; 
        }
        .btn-pdf-missing:before {
            content: "📄 ";
            margin-right: 4px;
        }

        /* === Sticky Navigation Bar === */
        .sticky-nav {
            position: sticky;
            top: 0;
            z-index: 100;
            background: var(--color-white);
            border-bottom: 2px solid var(--color-gray-border-medium);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: none; /* Hidden by default, shown when viewing rubric */
        }

        .sticky-nav.show {
            display: flex;
        }

        .nav-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            gap: 24px;
        }

        .nav-section {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .nav-back {
            color: var(--color-blue-base);
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .nav-back:hover {
            background: var(--color-blue-light-bg);
            color: var(--color-blue-text-dark);
        }

        /* Professional Sliding Toggle */
        .view-toggle {
            display: flex;
            align-items: center;
            background: var(--color-gray-bg-light);
            border-radius: 8px;
            padding: 4px;
            border: 2px solid var(--color-gray-border-light);
            position: relative;
        }

        .toggle-option {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--color-gray-text);
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
            white-space: nowrap;
        }

        .toggle-option.active {
            color: var(--color-blue-text-dark);
        }

        .toggle-slider {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            background: var(--color-white);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .staff-context {
            color: var(--color-gray-text);
            font-weight: 500;
            font-size: 0.9rem;
            padding: 8px 12px;
            background: var(--color-gray-bg-light);
            border-radius: 6px;
            border: 1px solid var(--color-gray-border-light);
        }

        .nav-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .nav-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            border: 2px solid;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }


        .nav-btn-finalize {
            background: var(--color-green-base);
            color: var(--color-white);
            border-color: var(--color-green-base);
        }

        .nav-btn-finalize:hover {
            background: var(--color-green-dark);
            border-color: var(--color-green-dark);
        }

        .role-badge {
            background: var(--color-blue-base);
            color: var(--color-white);
            border: 2px solid var(--color-blue-base);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            transition: all 0.2s ease;
        }

        /* === Rubric Styles (from rubric.html) === */
        .rubric-container { display: none; margin-top: 30px; }
        .domain-section { border-bottom: 3px solid var(--color-gray-border-medium); }
        .domain-header { background: linear-gradient(135deg, #7c9ac5, #5a82b8); color: white; padding: 15px 20px; font-size: 1.1rem; font-weight: 600; position: sticky; top: 76px; z-index: 50; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .component-section { border-bottom: 1px solid var(--color-gray-border-medium); position: relative; transition: background-color 0.2s; }
        .performance-levels-header { position: sticky; top: 132px; z-index: 40; background: white; border-bottom: 2px solid var(--color-gray-border-medium); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        
        /* Finalized View - Corrected Sticky Positioning */
        .finalized-view .domain-header { 
            top: 56px; /* Adjusted for sticky nav only (no global tools bar) */
        }
        
        .finalized-view .performance-levels-header {
            top: 112px; /* Domain header height + sticky nav */
        }
        .performance-levels { display: grid; grid-template-columns: 200px 1fr 1fr 1fr 1fr; min-height: 50px; }
        .performance-levels-content { display: grid; grid-template-columns: 200px 1fr 1fr 1fr 1fr; min-height: 120px; }
        .level-header { background: #e2e8f0; padding: 12px; font-weight: 600; text-align: center; border-bottom: 1px solid #cbd5e0; color: var(--color-gray-text); font-size: 0.9rem; }
        .level-content { padding: 20px; border-right: 1px solid var(--color-gray-border-medium); border-bottom: 1px solid var(--color-gray-border-medium); background: var(--color-white); color: var(--color-gray-text); font-size: 0.9rem; transition: background-color 0.2s; }
        .level-content:last-child { border-right: none; }
        .row-label { background: #64748b; padding: 20px; font-weight: 600; color: white; border-bottom: 1px solid var(--color-gray-border-medium); display: flex; align-items: center; font-size: 0.9rem; }

        /* Look-fors (Best Practices) */
        .look-fors-section { border-top: 1px solid var(--color-gray-border-medium); }
        .look-fors-header { background: linear-gradient(135deg, #3182ce, #2b77cb); color: white; padding: 10px 20px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-weight: 600; transition: background 0.3s ease; font-size: 0.85rem; }
        .look-fors-header:hover { background: linear-gradient(135deg, #2b77cb, #2c5aa0); }
        .chevron { transition: all 0.3s ease; font-size: 1rem; }
        .look-fors-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; background: var(--color-gray-bg-light); }
        .look-fors-content.expanded { max-height: 1000px; }
        .look-fors-grid { padding: 12px 20px; display: grid; grid-template-columns: 1fr; gap: 8px; }
        .look-for-item { display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: var(--color-white); border-radius: 4px; box-shadow: 0 1px 2px rgba(0,0,0,0.08); border-left: 3px solid var(--color-blue-base); }
        .look-for-item label { cursor: pointer; color: var(--color-gray-text); font-weight: 500; font-size: 0.85rem; line-height: 1.4; }

        /* Component Assignment & Highlighting */
        .component-section.component-assigned { border-left: 4px solid var(--color-green-base); background: var(--color-green-light-bg); }
        .component-section.component-not-assigned { border-left: 4px solid var(--color-gray-component-not-assigned-border); }
        .component-section.component-not-assigned .level-content { color: var(--color-text-deemphasized); }
        .component-section[data-assigned="true"]:hover { border-left-color: var(--color-green-dark); }
        .component-section:not([data-assigned="true"]):hover { border-left-color: var(--color-gray-border-light); background-color: var(--color-gray-bg-light); }
        .component-hidden { display: none; }
        
        /* Utility class for hiding elements completely */
        .hidden { display: none !important; }
        
        /* Interactive Rubric Styles */
        .level-content.editable { cursor: pointer; }
        .level-content.editable:hover { background-color: var(--color-blue-light-bg); }
        .level-content.selected { background-color: var(--color-blue-light-bg) !important; border: 2px solid var(--color-blue-base); font-weight: 600; color: var(--color-blue-text-dark); }

        /* Media Upload Styles */
        .media-upload-section { padding: 15px 20px; background-color: var(--color-gray-bg-light); border-top: 1px solid var(--color-gray-border-medium); }
        .media-upload-title { font-weight: 600; color: var(--color-gray-text); margin-bottom: 10px; font-size: 0.9rem; }
        .media-upload-area { display: flex; gap: 10px; align-items: center; }
        .media-upload-input { display: none; }
        .media-upload-label { background: var(--color-gray-bg-medium); color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; transition: background-color 0.2s; }
        .media-upload-label:hover { background: var(--color-gray-bg-dark); }
        .upload-status { font-size: 0.85rem; color: var(--color-gray-text); font-style: italic; }
        .evidence-list { margin-top: 10px; padding-left: 20px; }
        .evidence-item { margin-bottom: 5px; font-size: 0.9rem; }
        .evidence-item a { color: var(--color-blue-base); text-decoration: none; }
        .evidence-item a:hover { text-decoration: underline; }

        /* View Toggle Button */
        .view-toggle-button {
            background-color: var(--color-gray-bg-light);
            border: 1px solid var(--color-gray-border-light);
            padding: 8px 16px;
            margin: 0 0 20px 0;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            color: var(--color-gray-text);
            transition: all 0.2s ease;
        }
        .view-toggle-button:hover { background-color: #dee2e6; border-color: #adb5bd; }
        .filter-status {
            background: var(--color-blue-light-bg);
            border: 1px solid var(--color-blue-base);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: var(--color-blue-text-dark);
            font-weight: 500;
            display: none;
        }

        /* Toast Notification Styles */
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--color-red-base);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 9999;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            font-weight: 500;
            max-width: 350px;
            word-wrap: break-word;
        }
        .toast-notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast-notification.success {
            background-color: var(--color-green-base);
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .content { padding: 20px; }
            .actions-grid { grid-template-columns: 1fr; }
            .filter-row { flex-direction: column; align-items: stretch; }
            .filter-select, .filter-btn { min-width: auto; width: 100%; }
            .performance-levels, .performance-levels-content { grid-template-columns: 1fr; gap: 1px; }
            .level-header, .row-label, .level-content { border-right: none; padding: 15px; font-size: 0.9rem; }
            .toast-notification { top: 10px; right: 10px; left: 10px; right: 10px; max-width: none; }
            
            /* Responsive Navigation */
            .nav-container {
                flex-wrap: wrap;
                padding: 8px 16px;
                gap: 12px;
            }
            
            .nav-section {
                gap: 8px;
            }
            
            .nav-back {
                font-size: 0.8rem;
                padding: 6px 12px;
            }
            
            .toggle-option {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
            
            .staff-context {
                font-size: 0.8rem;
                padding: 6px 10px;
            }
            
            .nav-btn {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
            
            .role-badge {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
        }

        /* Evidence Section Styles */
        .evidence-section {
            margin-top: 10px;
        }

        .evidence-toggle-btn {
            background: linear-gradient(135deg, #4a4a4a, #3a3a3a);
            color: white;
            border: none;
            padding: 10px 20px;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            transition: background 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .evidence-toggle-btn:hover {
            background: linear-gradient(135deg, #3a3a3a, #2a2a2a);
        }

        .evidence-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: #f8fafc;
        }

        .evidence-content.expanded {
            max-height: 800px;
        }

        .notes-container {
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .notes-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            display: inline-block;
        }

        .notes-header-actions {
            float: right;
            margin-top: -5px;
        }

        .clear-notes-btn {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .clear-notes-btn:hover {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(245, 101, 101, 0.3);
        }

        .clear-notes-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .look-fors-container {
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .look-fors-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .look-fors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 8px;
        }

        .look-for-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
        }

        .look-for-item input[type="checkbox"] {
            margin-top: 2px;
            flex-shrink: 0;
        }

        .look-for-item label {
            font-size: 0.85rem;
            line-height: 1.4;
            cursor: pointer;
        }

        .media-upload-container {
            padding: 15px 20px;
        }

        .media-upload-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .media-upload-input {
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            width: 100%;
        }

        .media-upload-button {
            background: #3182ce;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .media-upload-button:hover {
            background: #2b77cb;
        }

        .media-links-container {
            margin-top: 10px;
        }

        .evidence-item {
            margin-bottom: 5px;
        }

        .evidence-item a {
            color: #3182ce;
            text-decoration: none;
            font-size: 0.85rem;
        }

        .evidence-item a:hover {
            text-decoration: underline;
        }

        /* Script Editor Modal Styles */
        .script-editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .script-editor-container {
            background: white;
            width: 95%;
            height: 90%;
            border-radius: 12px;
            position: relative;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .script-editor-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            border-radius: 12px;
        }

        .script-editor-loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        .script-editor-loading-text {
            color: #666;
            font-size: 16px;
            font-weight: 500;
        }

        .script-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 2px solid var(--color-gray-border-medium);
        }

        .script-editor-header h2 {
            font-size: 1.5rem;
            color: var(--color-gray-text-light);
        }

        .script-editor-controls {
            display: flex;
            gap: 12px;
        }

        .script-editor-controls .btn-primary {
            background-color: var(--color-green-base);
            border-color: var(--color-green-base);
            font-weight: 700;
            padding: 10px 20px;
        }

        .script-editor-controls .btn-primary:hover {
            background-color: var(--color-green-dark);
            border-color: var(--color-green-dark);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
        }
        
        .script-editor-controls .btn-secondary {
            padding: 10px 20px;
            font-weight: 500;
        }

        .script-editor-content {
            flex-grow: 1;
            padding: 0 24px 24px 24px;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Enable vertical scrolling within modal */
            overflow-x: hidden;
        }

        #scriptEditor {
            height: 100%;
            border: 1px solid var(--color-gray-border-light);
            border-radius: 6px;
            background-color: var(--color-white);
        }


        /* Script Editor Mode Toggle Styling */
        .script-editor-mode-toggle {
            display: flex;
            gap: 8px;
            margin: 12px 0;
            padding: 4px;
            background: #f3f4f6;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .mode-toggle-btn {
            flex: 1;
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            transition: all 0.2s ease;
        }

        .mode-toggle-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .mode-toggle-btn.active {
            background: white;
            color: #1f2937;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            border: 1px solid #d1d5db;
        }

        /* View-Only Mode Styling */
        .staff-responses-view-only {
            height: 100%;
            overflow-y: auto;
            padding: 16px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
        }

        .response-item {
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid #f3f4f6;
        }

        .response-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .response-question {
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            font-size: 15px;
        }

        .response-answer {
            color: #4b5563;
            line-height: 1.6;
            font-size: 14px;
            white-space: pre-wrap;
        }

        /* Quill toolbar customization */
        .script-editor-toolbar {
            padding: 12px 0;
        }

        #scriptEditor .ql-editor {
            font-size: 16px;
            line-height: 1.6;
            color: var(--color-text-default);
            height: 100%;
        }

        /* Component Tagging System Styles */
        .script-tagging-toolbar {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-bottom: 2px solid #e2e8f0;
            padding: 12px 16px;
        }

        .tagging-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .component-selector {
            min-width: 200px;
            max-width: 300px;
            padding: 8px 12px;
            border: 2px solid #cbd5e0;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            color: var(--color-text-default);
            transition: all 0.2s ease;
        }

        .component-selector:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .btn-tag, .btn-push, .btn-clear-tags {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-tag {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-tag:hover {
            background: linear-gradient(135deg, #3182ce 0%, #2c5aa0 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(49, 130, 206, 0.3);
        }

        .btn-push {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-push:hover {
            background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(72, 187, 120, 0.3);
        }

        .btn-clear-tags {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-clear-tags:hover {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(245, 101, 101, 0.3);
        }

        .tag-status {
            font-size: 12px;
            color: #4a5568;
            font-style: italic;
            padding: 4px 8px;
            background: #f7fafc;
            border-radius: 4px;
            border-left: 3px solid #4299e1;
        }

        /* Tagged content visual indicators */
        .script-editor-content .ql-editor [style*="background"] {
            position: relative;
            border-radius: 3px;
            padding: 1px 2px;
        }

        /* Component tag color legend (could be added later if needed) */
        .tag-legend {
            display: none; /* Hidden for now, but available for future use */
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        /* Responsive adjustments for tagging toolbar */
        @media (max-width: 768px) {
            .tagging-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .component-selector {
                min-width: unset;
                max-width: unset;
            }
            
            .btn-tag, .btn-push, .btn-clear-tags {
                justify-content: center;
            }
        }

        /* Professional Welcome Modal Styles */
        .welcome-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s ease;
            padding: 20px;
            box-sizing: border-box;
        }

        .welcome-modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .welcome-modal {
            background: var(--color-white);
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: translateY(30px) scale(0.9);
            transition: all 0.4s ease;
        }

        .welcome-modal-overlay.show .welcome-modal {
            transform: translateY(0) scale(1);
        }

        .welcome-modal-header {
            background: linear-gradient(135deg, var(--color-blue-base), var(--color-blue-dark));
            color: var(--color-white);
            padding: 40px 30px 30px;
            text-align: center;
            position: relative;
        }

        .welcome-modal-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            display: block;
            animation: welcomeIconPulse 2s ease-in-out infinite;
        }

        @keyframes welcomeIconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .welcome-modal-header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .welcome-subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            font-weight: 400;
            margin: 0;
        }

        .welcome-modal-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            line-height: 1.6;
        }

        .welcome-section {
            margin-bottom: 30px;
        }

        .welcome-feature {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 25px;
            padding: 20px;
            background: var(--color-gray-bg-light);
            border-radius: 12px;
            border-left: 4px solid var(--color-blue-base);
            transition: all 0.3s ease;
        }

        .welcome-feature:hover {
            background: var(--color-blue-light-bg);
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.1);
        }

        .feature-icon {
            font-size: 2rem;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .feature-content h3 {
            color: var(--color-gray-text-light);
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .feature-content p {
            color: var(--color-gray-text);
            font-size: 0.95rem;
            margin: 0;
        }

        .welcome-commitment {
            background: linear-gradient(135deg, var(--color-green-light-bg), var(--color-blue-light-bg));
            border: 2px solid var(--color-green-base);
            border-radius: 12px;
            padding: 25px;
            text-align: center;
        }

        .welcome-commitment h3 {
            color: var(--color-green-darker);
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .welcome-commitment p {
            color: var(--color-gray-text-light);
            font-size: 1rem;
            margin: 0;
            font-style: italic;
        }

        .welcome-modal-footer {
            padding: 25px 30px;
            background: var(--color-gray-bg-light);
            border-top: 1px solid var(--color-gray-border-light);
            text-align: center;
        }

        .welcome-continue-btn {
            background: linear-gradient(135deg, var(--color-green-base), var(--color-green-dark));
            color: var(--color-white);
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
            min-width: 280px;
        }

        .welcome-continue-btn:hover {
            background: linear-gradient(135deg, var(--color-green-dark), var(--color-green-darker));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .welcome-continue-btn .btn-icon {
            font-size: 1.2rem;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .welcome-modal-overlay {
                padding: 15px;
            }
            
            .welcome-modal {
                max-width: 100%;
                border-radius: 12px;
            }
            
            .welcome-modal-header {
                padding: 30px 20px 25px;
            }
            
            .welcome-modal-header h1 {
                font-size: 1.5rem;
            }
            
            .welcome-subtitle {
                font-size: 1rem;
            }
            
            .welcome-modal-content {
                padding: 20px;
            }
            
            .welcome-feature {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .feature-icon {
                align-self: center;
            }
            
            .welcome-continue-btn {
                min-width: 250px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Professional Welcome Modal -->
    <div class="welcome-modal-overlay" id="welcomeModalOverlay">
        <div class="welcome-modal" id="welcomeModal">
            <div class="welcome-modal-header">
                <div class="welcome-modal-icon">🌟</div>
                <h1>Welcome to the Observation Resources Website</h1>
                <p class="welcome-subtitle">Your Professional Growth Journey Begins Here</p>
            </div>
            
            <div class="welcome-modal-content">
                <div class="welcome-section">
                    <div class="welcome-feature">
                        <span class="feature-icon">📈</span>
                        <div class="feature-content">
                            <h3>Continuous Professional Development</h3>
                            <p>This platform is designed to support your ongoing professional growth through reflective observation and evidence-based feedback. Every interaction is an opportunity to enhance your teaching practice.</p>
                        </div>
                    </div>
                    
                    <div class="welcome-feature">
                        <span class="feature-icon">🤝</span>
                        <div class="feature-content">
                            <h3>Collaborative Learning Environment</h3>
                            <p>Engage in meaningful peer observations and receive constructive feedback that supports your development. Our framework promotes collegiality and shared expertise among educational professionals.</p>
                        </div>
                    </div>
                    
                    <div class="welcome-feature">
                        <span class="feature-icon">🎯</span>
                        <div class="feature-content">
                            <h3>Evidence-Based Growth</h3>
                            <p>Utilize comprehensive rubrics and structured observation tools to identify strengths and areas for growth. Transform observations into actionable insights for improved student outcomes.</p>
                        </div>
                    </div>
                    
                    <div class="welcome-feature">
                        <span class="feature-icon">✨</span>
                        <div class="feature-content">
                            <h3>Inspiring Excellence</h3>
                            <p>This experience is designed to be supportive, inspiring, and focused on celebrating your professional journey. Every observation is a step toward educational excellence.</p>
                        </div>
                    </div>
                </div>
                
                <div class="welcome-commitment">
                    <h3>Our Commitment to You</h3>
                    <p>We are dedicated to providing a positive, growth-oriented experience that recognizes your professionalism and supports your continued development as an educator. This tool represents our investment in your success and the success of all learners in our community.</p>
                </div>
            </div>
            
            <div class="welcome-modal-footer">
                <button class="welcome-continue-btn" onclick="closeWelcomeModal()">
                    <span class="btn-icon">🚀</span>
                    Continue Growing in My Profession
                </button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <!-- Sticky Navigation Bar -->
        <nav class="sticky-nav" id="stickyNav">
            <div class="nav-container">
                <div class="nav-section">
                    <a href="#" class="nav-back" onclick="goBackToObservations(); return false;">
                        ← Back
                    </a>
                    
                    <div class="view-toggle" id="viewToggle" style="display: none;">
                        <div class="toggle-slider" id="toggleSlider"></div>
                        <button class="toggle-option active" id="assignedToggle" onclick="setViewMode('assigned')">
                            Assigned Subdomains
                        </button>
                        <button class="toggle-option" id="fullToggle" onclick="setViewMode('full')">
                            Full Rubric
                        </button>
                    </div>
                </div>
                
                <div class="staff-context" id="staffContext" style="display: none;">
                    Viewing: <span id="staffName">--</span>
                </div>
                
                <div class="nav-section">
                    <div class="nav-actions" id="navActions" style="display: none;">
                        <button class="nav-btn nav-btn-finalize" id="finalizeBtn" onclick="handleFinalizeFromNav()">
                            ✅ Finalize & Submit
                        </button>
                    </div>
                    
                    <div class="role-badge">
                        <?= userContext.role ?>
                    </div>
                </div>
            </div>
        </nav>

        <div class="header"><h1>👥 Observation Dashboard</h1><p>Select how you'd like to view rubric information</p></div>
        <div class="content">
            <div id="quickActionsView">
                <div class="quick-actions"><h2 class="section-title"><span>🎯</span> Quick Actions</h2>
                    <div class="actions-grid">
                        <? if (userContext.hasSpecialAccess) { ?>
                        <div class="action-card" onclick="showCustomFilters()"><span class="action-icon">🔍</span><div class="action-title">Find Staff & Start Observation</div><div class="action-desc">Filter by role, year, or specific staff member</div></div>
                        <? } ?>
                        <? if (userContext.specialRoleType === 'peer_evaluator' || userContext.specialRoleType === 'full_access') { ?>
                        <div class="action-card" onclick="loadMyOwnView()"><span class="action-icon">📋</span><div class="action-title">My Own Rubric</div><div class="action-desc">View your personal assigned areas</div></div>
                        <? } ?>
                    </div>
                </div>
            </div>
            <div class="custom-filters" id="adminStaffListView" style="display: none;">
                <h2 class="section-title"><span>👥</span> Summative Year Staff</h2>
                
                <!-- Filter Toggle Buttons -->
                <div class="staff-filter-container">
                    <div class="filter-toggle-group">
                        <button class="filter-toggle-btn active" data-filter="all" onclick="filterStaffList('all')">All</button>
                        <button class="filter-toggle-btn" data-filter="tenured" onclick="filterStaffList('tenured')">Tenured</button>
                        <button class="filter-toggle-btn" data-filter="probationary" onclick="filterStaffList('probationary')">Probationary</button>
                    </div>
                </div>
                
                <!-- Staff List Container -->
                <div class="staff-list-container" id="adminStaffList">
                    <!-- Staff list will be populated here -->
                </div>
            </div>
            <div class="custom-filters" id="customFiltersView">
                <h2 class="section-title"><span>🔍</span> Find Staff Member</h2>
                <div class="filter-row"><select id="roleSelect" class="filter-select" onchange="handleRoleChange()"><option value="">1. Select Role...</option><? for (var i = 0; i < availableRoles.length; i++) { ?><option value="<?= availableRoles[i] ?>"><?= availableRoles[i] ?></option><? } ?></select></div>
                <div class="filter-row"><select id="yearSelect" class="filter-select" style="display: none;" onchange="handleYearChange()"><option value="">2. Select Year...</option><? if (userContext.role === 'Administrator') { ?><option value="3">Year 3</option><option value="0">Probationary</option><? } else { ?><option value="1">Year 1</option><option value="2">Year 2</option><option value="3">Year 3</option><option value="0">Probationary</option><? } ?></select></div>
                <div class="filter-row"><select id="staffSelect" class="filter-select" style="display: none;" onchange="handleStaffChange()"><option value="">3. Select Staff Member...</option></select></div>
                <div class="filter-row"><button class="filter-btn" id="loadBtn" onclick="loadSelectedView()" disabled>📖 Select Staff</button><button class="filter-btn btn-secondary" onclick="clearFilters()">🗑️ Clear & Go Back</button></div>
            </div>
            <div class="observation-selector" id="observationSelectorView"></div>
            <div class="error" id="error"><div id="errorMessage"></div><button class="filter-btn btn-secondary" onclick="hideError()" style="margin-top: 15px;">Dismiss</button></div>
            <div class="filter-status" id="filterStatus"><strong>Currently Viewing:</strong> <span id="filterStatusText"></span></div>
            <div class="rubric-container" id="rubricContainer"></div>
        </div>
    </div>
    <div class="toast-notification" id="toastNotification"></div>
    <script>
        // Probationary year constants from server (parsed as integers to match staff.year type)
        const PROB_YEAR_1 = parseInt(<?= probYear1 ?>);
        const PROB_YEAR_2 = parseInt(<?= probYear2 ?>);
        const PROB_YEAR_3 = parseInt(<?= probYear3 ?>);

        /**
         * Professional Welcome Modal Functions
         */
        
        // Show the welcome modal on page load (once per session)
        function showWelcomeModal() {
            // Check if modal has been shown this session
            if (sessionStorage.getItem('welcomeModalShown') === 'true') {
                return; // Don't show again this session
            }
            
            const overlay = document.getElementById('welcomeModalOverlay');
            if (overlay) {
                // Small delay to ensure page is fully loaded
                setTimeout(() => {
                    overlay.classList.add('show');
                    document.body.style.overflow = 'hidden'; // Prevent background scrolling
                }, 300);
            }
        }
        
        // Close the welcome modal
        function closeWelcomeModal() {
            const overlay = document.getElementById('welcomeModalOverlay');
            if (overlay) {
                overlay.classList.remove('show');
                document.body.style.overflow = ''; // Restore scrolling
                
                // Mark as shown for this session
                sessionStorage.setItem('welcomeModalShown', 'true');
                
                // Remove from DOM after animation completes
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 400);
            }
        }
        
        // Handle keyboard events for accessibility
        function handleModalKeydown(event) {
            if (event.key === 'Escape') {
                const overlay = document.getElementById('welcomeModalOverlay');
                if (overlay && overlay.classList.contains('show')) {
                    closeWelcomeModal();
                }
            }
        }
        
        // Initialize modal when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Add keyboard listener for escape key
            document.addEventListener('keydown', handleModalKeydown);
            
            // Show welcome modal after a brief delay
            showWelcomeModal();
            
            // Optional: Close modal if clicking outside (on overlay)
            const overlay = document.getElementById('welcomeModalOverlay');
            if (overlay) {
                overlay.addEventListener('click', function(event) {
                    // Only close if clicking directly on the overlay (not the modal content)
                    if (event.target === overlay) {
                        closeWelcomeModal();
                    }
                });
            }
        });

        /**
         * Escapes HTML entities in a string to prevent XSS and ensure safe HTML rendering.
         * This implementation matches the server-side Utils.js version for consistency.
         * @param {*} unsafe - The input to escape (will be converted to string if not already)
         * @returns {string} The escaped string with HTML entities replaced
         */
        function escapeHtml(unsafe) {
            // Handle null and undefined by returning empty string
            if (unsafe == null) {
                return '';
            }
            
            // Convert to string if not already a string
            const str = String(unsafe);
            
            // Define the character mapping for HTML entities
            const entityMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            };
            
            // Replace characters using the entity map
            return str.replace(/[&<>"']/g, function(match) {
                return entityMap[match];
            });
        }

        /**
         * Escapes characters in a string to ensure it's safe to use within a JavaScript
         * single-quoted string literal, such as in an onclick attribute.
         * @param {*} unsafe - The input to escape (will be converted to string if not already)
         * @returns {string} The escaped string, safe for JS string literals.
         */
        function escapeJsString(unsafe) {
            if (unsafe == null) {
                return '';
            }
            const str = String(unsafe);
            return str.replace(/[\\']/g, '\\$&')
                      .replace(/\n/g, '\\n')
                      .replace(/\r/g, '\\r');
        }

        function formatYearDisplay(year) {
            // Handle probationary years P1, P2, P3
            if (year === 4) {
                return 'P1';
            }
            if (year === 5) {
                return 'P2';
            }
            if (year === 6) {
                return 'P3';
            }

            // Backward compatibility: handle legacy probationary format
            if (year === 0 || year === 'Probationary') {
                return 'P1 (Legacy)';
            }

            // Handle null, undefined, or empty values
            if (year === null || year === undefined || year === '') {
                return 'N/A';
            }

            // Return the year as-is for valid numeric years (1, 2, 3)
            return year.toString();
        }

        function showLoading(message = 'Loading...') { 
            document.getElementById('loading-text').textContent = message; 
            document.getElementById('loading').style.display = 'flex'; 
            hideError(); 
        }
        function hideLoading() { document.getElementById('loading').style.display = 'none'; }
        function showError(error) { const msg = error.message || String(error); document.getElementById('errorMessage').textContent = msg; document.getElementById('error').style.display = 'block'; hideLoading(); }
        function hideError() { document.getElementById('error').style.display = 'none'; }
        function handleError(error) { console.error('AJAX Error:', error); showError(error); }

        function showToast(message, isSuccess = false, duration = 4000) {
            const toast = document.getElementById('toastNotification');
            toast.textContent = message;
            toast.className = 'toast-notification' + (isSuccess ? ' success' : '');
            toast.classList.add('show');
            setTimeout(function() {
                toast.classList.remove('show');
            }, duration);
        }

        let currentFilters = { role: null, year: null, staff: null };
        let currentObservationId = null;
        let observationViewMode = 'assigned';
        let currentObservedUser = { email: null, name: null };

        // Client-side cache for work product answers
        let workProductAnswersCache = new Map();

        // Helper function to clear work product answers cache
        function clearWorkProductAnswersCache() {
            workProductAnswersCache.clear();
            console.log('Work product answers cache cleared');
        }

        function showView(viewId) {
            stopAllPollers(); // Stop any running pollers when the view changes
            ['quickActionsView', 'customFiltersView', 'observationSelectorView', 'rubricContainer', 'adminStaffListView'].forEach(id => { 
                document.getElementById(id).style.display = 'none'; 
            }); 
            document.getElementById(viewId).style.display = 'block'; 
            
            const header = document.querySelector('.header');

            // Show/hide sticky nav and header based on view
            if (viewId === 'rubricContainer') {
                if (header) header.classList.add('hidden');
                // Nav will be shown by handleRubricData
            } else {
                if (header) header.classList.remove('hidden');
                hideStickyNav();
            }
        }
        function showCustomFilters() { showView('customFiltersView'); }
        function loadMyOwnView() { 
            console.log('loadMyOwnView called - making AJAX request');
            showLoading('Loading your assigned rubric...'); 
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .loadRubricData({ myOwnView: true }); 
        }

        function handleRoleChange() {
            const roleSelect = document.getElementById('roleSelect'); const yearSelect = document.getElementById('yearSelect'); currentFilters.role = roleSelect.value;
            yearSelect.value = ''; yearSelect.style.display = roleSelect.value ? 'block' : 'none'; handleYearChange();
        }
        function handleYearChange() {
            const yearSelect = document.getElementById('yearSelect'); const staffSelect = document.getElementById('staffSelect'); currentFilters.year = yearSelect.value;
            staffSelect.value = ''; staffSelect.style.display = yearSelect.value ? 'block' : 'none';
            if (yearSelect.value) { loadStaffOptions(); } else { handleStaffChange(); }
        }
        function handleStaffChange() { const staffSelect = document.getElementById('staffSelect'); currentFilters.staff = staffSelect.value; document.getElementById('loadBtn').disabled = !staffSelect.value; }
        function loadStaffOptions() {
            const staffSelect = document.getElementById('staffSelect'); staffSelect.innerHTML = '<option value="">Loading staff...</option>'; staffSelect.disabled = true;
            google.script.run.withSuccessHandler(populateStaffDropdown).withFailureHandler(handleError).getStaffListForDropdown(currentFilters.role, currentFilters.year);
        }
        function populateStaffDropdown(result) {
            const staffSelect = document.getElementById('staffSelect'); staffSelect.disabled = false;
            if (!result.success) { staffSelect.innerHTML = `<option value="">Error: ${result.error}</option>`; return; }
            staffSelect.innerHTML = '<option value="">3. Select Staff Member...</option>';
            if (result.staff?.length) {
                result.staff.forEach(staff => staffSelect.appendChild(new Option(staff.displayName, staff.email)));
            } else {
                staffSelect.appendChild(new Option('No staff found', '', true, true));
            }
        }
        function loadSelectedView() { if (!currentFilters.staff) return; showLoading('Loading...'); google.script.run.withSuccessHandler(handleRubricData).withFailureHandler(handleError).loadRubricData(currentFilters); }
        function clearFilters() { showView('quickActionsView'); hideError(); hideLoading(); document.getElementById('filterStatus').style.display = 'none'; }

        let activePollers = {};

        // Request deduplication system - prevents identical calls in succession
        let pendingRequests = new Map();

        // Feature flags for optimization controls
        const OPTIMIZATION_FLAGS = {
            enableAdaptivePolling: true,      // PDF polling with adaptive intervals
            enableConcurrentLimits: true,     // Limit concurrent pollers
            enableRequestDeduplication: true, // Skip duplicate requests
            enableAdaptiveAutoSave: true,     // Adaptive auto-save timing
            enableRequestMonitoring: true     // Track request frequency
        };

        // Request monitoring for rate limit detection
        let requestTracker = {
            requests: [],
            warningThreshold: 8,      // requests per minute
            criticalThreshold: 12     // requests per minute
        };

        function trackRequest(functionName) {
            if (!OPTIMIZATION_FLAGS.enableRequestMonitoring) return;

            const now = Date.now();
            requestTracker.requests.push({ functionName, timestamp: now });

            // Clean old requests (older than 1 minute)
            requestTracker.requests = requestTracker.requests.filter(
                req => now - req.timestamp < 60000
            );

            // Check for rate limit warnings
            const requestsPerMinute = requestTracker.requests.length;
            if (requestsPerMinute >= requestTracker.criticalThreshold) {
                console.warn(`⚠️ CRITICAL: ${requestsPerMinute} API requests in last minute. Possible rate limiting.`);
                showToast(`High API usage detected (${requestsPerMinute}/min). Consider refreshing if issues occur.`, false);
            } else if (requestsPerMinute >= requestTracker.warningThreshold) {
                console.warn(`⚠️ WARNING: ${requestsPerMinute} API requests in last minute. Approaching rate limits.`);
            }
        }

        function createRequestKey(functionName, args) {
            return `${functionName}:${JSON.stringify(args)}`;
        }

        function makeDeduplicatedRequest(functionName, args, successHandler, failureHandler) {
            // Track this request for monitoring
            trackRequest(functionName);

            // Check if deduplication is disabled - fall back to normal request
            if (!OPTIMIZATION_FLAGS.enableRequestDeduplication) {
                try {
                    google.script.run
                        .withSuccessHandler(successHandler)
                        .withFailureHandler(failureHandler)
                        [functionName](...args);
                    return true;
                } catch (error) {
                    if (failureHandler) failureHandler(error);
                    return false;
                }
            }

            const requestKey = createRequestKey(functionName, args);

            // Check if identical request is already pending
            if (pendingRequests.has(requestKey)) {
                console.log(`Skipping duplicate request: ${functionName}`);
                return false; // Request was deduplicated
            }

            // Mark request as pending
            pendingRequests.set(requestKey, Date.now());

            // Create wrapped handlers that clean up pending requests
            const wrappedSuccessHandler = (result) => {
                pendingRequests.delete(requestKey);
                if (successHandler) successHandler(result);
            };

            const wrappedFailureHandler = (error) => {
                pendingRequests.delete(requestKey);
                if (failureHandler) failureHandler(error);
            };

            // Make the actual request
            try {
                google.script.run
                    .withSuccessHandler(wrappedSuccessHandler)
                    .withFailureHandler(wrappedFailureHandler)
                    [functionName](...args);
                return true; // Request was made
            } catch (error) {
                // Clean up if the request failed to start
                pendingRequests.delete(requestKey);
                if (failureHandler) failureHandler(error);
                return false;
            }
        }

        // Clean up old pending requests (older than 30 seconds) to prevent memory leaks
        setInterval(() => {
            const now = Date.now();
            const thirtySecondsAgo = now - 30000;

            for (const [key, timestamp] of pendingRequests.entries()) {
                if (timestamp < thirtySecondsAgo) {
                    pendingRequests.delete(key);
                    console.log(`Cleaned up stale pending request: ${key}`);
                }
            }
        }, 30000);

        // Diagnostic functions for debugging (callable from browser console)
        window.diagnostics = {
            // Get current optimization status
            getOptimizationStatus: () => {
                const activePollerCount = Object.keys(activePollers).length;
                const pendingRequestCount = pendingRequests.size;
                const recentRequestCount = requestTracker.requests.filter(
                    req => Date.now() - req.timestamp < 60000
                ).length;

                return {
                    flags: OPTIMIZATION_FLAGS,
                    activePollers: activePollerCount,
                    pendingRequests: pendingRequestCount,
                    recentRequests: recentRequestCount,
                    isHighActivity: isHighActivityPeriod(),
                    currentAutoSaveDelay: getAutoSaveDebounceTime()
                };
            },

            // Disable all optimizations (emergency fallback)
            disableAllOptimizations: () => {
                Object.keys(OPTIMIZATION_FLAGS).forEach(key => {
                    OPTIMIZATION_FLAGS[key] = false;
                });
                console.log('🚨 All optimizations disabled');
                return window.diagnostics.getOptimizationStatus();
            },

            // Re-enable all optimizations
            enableAllOptimizations: () => {
                Object.keys(OPTIMIZATION_FLAGS).forEach(key => {
                    OPTIMIZATION_FLAGS[key] = true;
                });
                console.log('✅ All optimizations re-enabled');
                return window.diagnostics.getOptimizationStatus();
            },

            // Toggle specific optimization
            toggleOptimization: (flagName) => {
                if (OPTIMIZATION_FLAGS.hasOwnProperty(flagName)) {
                    OPTIMIZATION_FLAGS[flagName] = !OPTIMIZATION_FLAGS[flagName];
                    console.log(`🔄 ${flagName}: ${OPTIMIZATION_FLAGS[flagName]}`);
                    return window.diagnostics.getOptimizationStatus();
                } else {
                    console.error(`Unknown flag: ${flagName}. Available: ${Object.keys(OPTIMIZATION_FLAGS).join(', ')}`);
                }
            },

            // Get request history
            getRequestHistory: () => {
                return requestTracker.requests.map(req => ({
                    function: req.functionName,
                    timeAgo: Math.round((Date.now() - req.timestamp) / 1000) + 's'
                }));
            },

            // Clear all active pollers (emergency stop)
            emergencyStopPollers: () => {
                const pollerIds = Object.keys(activePollers);
                pollerIds.forEach(id => stopPdfPolling(id));
                console.log(`🛑 Emergency stopped ${pollerIds.length} pollers`);
                return pollerIds;
            }
        };

        // Log optimization status on page load
        setTimeout(() => {
            console.log('📊 PDF Polling Optimizations Loaded:');
            console.log(window.diagnostics.getOptimizationStatus());
            console.log('💡 Use window.diagnostics.getOptimizationStatus() to check status');
            console.log('🚨 Use window.diagnostics.disableAllOptimizations() if issues occur');
        }, 1000);

        function _setPdfButtonState(observationId, state, pdfUrl = null) {
            const pdfButton = document.getElementById(`pdf-button-${observationId}`);
            if (!pdfButton) return;

            switch (state) {
                case 'generating':
                    pdfButton.textContent = 'Generating PDF...';
                    pdfButton.className = 'filter-btn btn-export btn-pdf-missing';
                    pdfButton.disabled = true;
                    pdfButton.onclick = null;
                    break;
                case 'ready':
                    pdfButton.textContent = 'View PDF';
                    pdfButton.className = 'filter-btn btn-export';
                    pdfButton.disabled = false;
                    pdfButton.onclick = () => window.open(pdfUrl, '_blank');
                    break;
                case 'failed':
                    pdfButton.textContent = 'Retry PDF';
                    pdfButton.className = 'filter-btn btn-export btn-pdf-failed';
                    pdfButton.disabled = false;
                    pdfButton.onclick = () => handleRetryPdf(observationId);
                    break;
            }
        }

        function startPdfPolling(observationId) {
            if (activePollers[observationId]) {
                console.log(`Polling already active for ${observationId}`);
                return;
            }

            // Concurrent polling limit - max 3 active pollers per user (if enabled)
            if (OPTIMIZATION_FLAGS.enableConcurrentLimits) {
                const activePollerCount = Object.keys(activePollers).length;
                if (activePollerCount >= 3) {
                    console.log(`Maximum concurrent pollers reached (${activePollerCount}). Queueing ${observationId}.`);
                    showToast('Multiple PDFs generating. This one will start shortly.', true);
                    setTimeout(() => startPdfPolling(observationId), 3000);
                    return;
                }
            }

            console.log(`Starting PDF polling for ${observationId}`);
            const startTime = Date.now();
            let currentInterval = 5000; // Start with 5 seconds (same as before)
            let pollCount = 0;

            function schedulePoll() {
                const elapsed = Date.now() - startTime;

                // Adaptive intervals: 5s -> 8s -> 15s (if enabled)
                if (OPTIMIZATION_FLAGS.enableAdaptivePolling) {
                    if (elapsed > 60000) {
                        currentInterval = 15000; // 15 seconds after 1 minute
                    } else if (elapsed > 30000) {
                        currentInterval = 8000;  // 8 seconds after 30 seconds
                    }
                }

                const timeoutId = setTimeout(() => {
                    pollCount++;
                    console.log(`PDF poll #${pollCount} for ${observationId} (interval: ${currentInterval}ms)`);

                    // Use deduplication for PDF status checks
                    const requestMade = makeDeduplicatedRequest(
                        'getObservationStatusAndPdfUrl',
                        [observationId],
                        (res) => {
                            if (res.success) {
                                if (res.pdfUrl) {
                                    console.log(`PDF found for ${observationId} after ${pollCount} polls`);
                                    showToast('PDF is ready!', true);
                                    _setPdfButtonState(observationId, 'ready', res.pdfUrl);
                                    stopPdfPolling(observationId);
                                } else if (res.pdfStatus === 'failed') {
                                    console.log(`PDF generation failed for ${observationId}`);
                                    showToast('PDF generation failed. Please retry.', false);
                                    _setPdfButtonState(observationId, 'failed');
                                    stopPdfPolling(observationId);
                                } else {
                                    // Continue polling with adaptive interval
                                    if (activePollers[observationId]) {
                                        schedulePoll();
                                    }
                                }
                            } else {
                                console.warn(`Polling check failed for ${observationId}: ${res.error}`);
                                // Continue polling on server errors
                                if (activePollers[observationId]) {
                                    schedulePoll();
                                }
                            }
                        },
                        (err) => {
                            console.error(`Polling error for ${observationId}:`, err);
                            // Continue polling on network errors
                            if (activePollers[observationId]) {
                                schedulePoll();
                            }
                        }
                    );

                    // If request was deduplicated, schedule next poll anyway
                    if (!requestMade && activePollers[observationId]) {
                        console.log(`PDF status request deduplicated for ${observationId}, scheduling next poll`);
                        schedulePoll();
                    }
                }, currentInterval);

                // Update the active poller with new timeout ID
                if (activePollers[observationId]) {
                    if (activePollers[observationId].timeoutId) {
                        clearTimeout(activePollers[observationId].timeoutId);
                    }
                    activePollers[observationId].timeoutId = timeoutId;
                }
            }

            // Overall timeout (2 minutes instead of 1 to account for slower intervals)
            const overallTimeoutId = setTimeout(() => {
                console.log(`Polling timed out for ${observationId} after ${pollCount} polls`);
                const pdfButton = document.getElementById(`pdf-button-${observationId}`);
                if (pdfButton && pdfButton.disabled) {
                     showToast('PDF generation is taking longer than expected. Please check back later or retry.', false);
                    _setPdfButtonState(observationId, 'failed');
                }
                stopPdfPolling(observationId);
            }, 120000); // 2 minutes

            activePollers[observationId] = {
                timeoutId: null, // Will be updated by schedulePoll
                overallTimeoutId: overallTimeoutId,
                startTime: startTime
            };

            // Start first poll immediately
            schedulePoll();
        }

        function stopPdfPolling(observationId) {
            if (activePollers[observationId]) {
                // Clear both the current poll timeout and overall timeout
                if (activePollers[observationId].timeoutId) {
                    clearTimeout(activePollers[observationId].timeoutId);
                }
                if (activePollers[observationId].overallTimeoutId) {
                    clearTimeout(activePollers[observationId].overallTimeoutId);
                }
                // Legacy support: clear intervalId if it exists (for backwards compatibility)
                if (activePollers[observationId].intervalId) {
                    clearInterval(activePollers[observationId].intervalId);
                }
                delete activePollers[observationId];
                console.log(`Stopped polling for ${observationId}`);
            }
        }

        function stopAllPollers() {
            Object.keys(activePollers).forEach(observationId => {
                stopPdfPolling(observationId);
            });
        }

        // Global variable to store current observations data for filtering
        let currentObservationsData = [];
        let currentObservationFilter = 'all';

        function renderObservationCards(result, observedEmail, observedName) {
            hideLoading();
            if (!result.success) return showError(result.error);

            // Store the observations data globally for filtering
            currentObservationsData = result.observations;

            const container = document.getElementById('observationSelectorView');
            const safeObservedNameHtml = escapeHtml(observedName);
            const safeObservedEmailJs = escapeJsString(observedEmail);

            // Action buttons section
            let actionButtonsHtml = `
                <div class="action-buttons-section">
                    <div class="action-card" onclick="handleNewObservation('${safeObservedEmailJs}')">
                        <span class="action-icon">➕</span>
                        <div class="action-title">Start New Observation</div>
                        <div class="action-desc">Begin a new evaluation for this staff member.</div>
                    </div>`;

            <? if (showWorkProductButton) { ?>
            actionButtonsHtml += `
                    <div class="action-card" onclick="handleNewWorkProductObservation('${safeObservedEmailJs}')">
                        <span class="action-icon">📋</span>
                        <div class="action-title">Create Work Product</div>
                        <div class="action-desc">Request reflective responses from this staff member.</div>
                    </div>`;
            <? } ?>

            actionButtonsHtml += `</div>`;

            // Filter toggle section
            const filterHtml = `
                <div class="observation-filter-section">
                    <div class="observation-filter-toggle">
                        <button class="observation-filter-btn active" data-filter="all" onclick="filterObservations('all')">All</button>
                        <button class="observation-filter-btn" data-filter="draft" onclick="filterObservations('draft')">Draft</button>
                        <button class="observation-filter-btn" data-filter="finalized" onclick="filterObservations('finalized')">Finalized</button>
                    </div>
                </div>`;

            // Generate the observations list
            const observationsListHtml = generateObservationsList(result.observations, observedEmail, observedName);

            // Back button
            const backButtonText = userContext.role === 'Administrator' ? 'Back to Staff List' : 'Back to Filters';
            const backButtonAction = userContext.role === 'Administrator' ? "showView('adminStaffListView')" : "showView('customFiltersView')";
            const backButtonHtml = `
                <div style="margin-top: 20px;">
                    <button class="filter-btn btn-secondary" onclick="${backButtonAction}">${backButtonText}</button>
                </div>`;

            container.innerHTML = `
                <h2 class="section-title"><span>📝</span> Observations for ${safeObservedNameHtml}</h2>
                ${actionButtonsHtml}
                ${filterHtml}
                <div id="observations-list-display">
                    ${observationsListHtml}
                </div>
                ${backButtonHtml}`;

            showView('observationSelectorView');
        }

        function generateObservationsList(observations, observedEmail, observedName) {
            const safeObservedEmailJs = escapeJsString(observedEmail);
            const safeObservedNameJs = escapeJsString(observedName);

            if (!observations || observations.length === 0) {
                return `<div class="observations-list-container">
                    <div class="empty-observations-message">No observations found for this staff member.</div>
                </div>`;
            }

            let listHtml = `
                <div class="observations-list-container">
                    <div class="observations-list-header">
                        <div>Title</div>
                        <div>Date</div>
                        <div>Type</div>
                        <div>Created By</div>
                        <div>Status</div>
                        <div>Actions</div>
                    </div>`;

            observations.forEach(obs => {
                const date = new Date(obs.createdAt).toLocaleDateString();
                const safeObsIdJs = escapeJsString(obs.observationId);
                const safeObsIdHtml = escapeHtml(obs.observationId);
                const safeStatusHtml = escapeHtml(obs.status);
                const safeTypeHtml = escapeHtml(obs.type || 'Standard');

                // Generate observation title
                let title = obs.observationName || `${obs.observedName} Observation`;
                const safeTitleHtml = escapeHtml(title);

                // Generate action buttons based on status
                let buttonsHtml = '';
                if (obs.status === 'Draft') {
                    buttonsHtml = `
                        <button class="filter-btn btn-edit" onclick="handleEditObservation('${safeObsIdJs}')">Edit</button>
                        <button class="filter-btn btn-finalize" onclick="handleFinalizeObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Finalize</button>
                        <button class="filter-btn btn-delete" onclick="handleDeleteObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Delete</button>`;
                } else if (obs.status === 'Finalized') {
                    let pdfButtonHtml = '';
                    if (obs.pdfUrl) {
                        pdfButtonHtml = `<button class="filter-btn btn-export" onclick="window.open('${escapeJsString(obs.pdfUrl)}', '_blank')">View PDF</button>`;
                    } else if (obs.pdfStatus === 'failed') {
                        pdfButtonHtml = `<button class="filter-btn btn-export btn-pdf-failed" id="pdf-button-${safeObsIdHtml}" onclick="handleRetryPdf('${safeObsIdJs}')">Retry PDF</button>`;
                    } else {
                        pdfButtonHtml = `<button class="filter-btn btn-export btn-pdf-missing" id="pdf-button-${safeObsIdHtml}" disabled>Generating PDF...</button>`;
                        setTimeout(() => startPdfPolling(obs.observationId), 100);
                    }

                    buttonsHtml = `
                        <button class="filter-btn btn-view" onclick="handleViewObservation('${safeObsIdJs}')">View</button>
                        ${pdfButtonHtml}
                        <button class="filter-btn btn-delete" onclick="handleDeleteFinalizedObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Delete</button>`;
                }

                // Get observer name with escaping
                const safeObserverNameHtml = escapeHtml(obs.observerName || 'Unknown');

                listHtml += `
                    <div class="observations-list-item" data-status="${obs.status.toLowerCase()}">
                        <div class="obs-list-title">${safeTitleHtml}</div>
                        <div class="obs-list-date">${date}</div>
                        <div class="obs-list-type">${safeTypeHtml}</div>
                        <div class="obs-list-creator">${safeObserverNameHtml}</div>
                        <div class="obs-list-status">
                            <div class="status-badge ${obs.status === 'Draft' ? 'status-draft' : 'status-finalized'}">${safeStatusHtml}</div>
                        </div>
                        <div class="obs-list-actions">
                            ${buttonsHtml}
                        </div>
                    </div>`;
            });

            listHtml += `</div>`;
            return listHtml;
        }

        function filterObservations(filter) {
            currentObservationFilter = filter;

            // Update active button state
            document.querySelectorAll('.observation-filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-filter') === filter);
            });

            // Filter observations
            let filteredObservations = currentObservationsData;
            if (filter === 'draft') {
                filteredObservations = currentObservationsData.filter(obs => obs.status === 'Draft');
            } else if (filter === 'finalized') {
                filteredObservations = currentObservationsData.filter(obs => obs.status === 'Finalized');
            }

            // Re-render the observations list
            const listDisplay = document.getElementById('observations-list-display');
            if (listDisplay) {
                listDisplay.innerHTML = generateObservationsList(filteredObservations, currentObservedUser.email, currentObservedUser.name);
            }
        }

        function displayObservationOptions(observedEmail, observedName) {
            currentObservedUser.email = observedEmail;
            currentObservedUser.name = observedName;
            
            
            showLoading(`Loading options for ${observedName}`);
            google.script.run
                .withSuccessHandler(result => {
                    renderObservationCards(result, observedEmail, observedName);
                })
                .withFailureHandler(handleError)
                .getObservationOptions(observedEmail);
        }

        function handleNewObservation(observedEmail) {
            console.log('Starting new observation for:', observedEmail);

            // Clear all existing observation state before creating new observation
            clearObservationState();

            showLoading('Creating new observation draft...');
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .createNewObservationForEvaluator(observedEmail);
        }

        function handleNewWorkProductObservation(observedEmail) {
            console.log('Starting new work product observation for:', observedEmail);
            clearObservationState();
            showLoading('Creating work product observation...');
            google.script.run
              .withSuccessHandler(handleRubricData)
              .withFailureHandler(handleError)
              .createWorkProductObservationForEvaluator(observedEmail);
        }
        function handleEditObservation(obsId) { 
            console.log('Loading observation for editing:', obsId);
            
            // Clear all existing observation state before loading different observation
            clearObservationState();
            
            showLoading('Loading observation...'); 
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .loadObservationForEditing(obsId); 
        }
        function handleDeleteObservation(obsId, email, name) { if (confirm('Are you sure you want to delete this draft? This cannot be undone.')) { showLoading('Deleting draft...'); google.script.run.withSuccessHandler(res => { if(res.success) { displayObservationOptions(email, name); } else { showError(res.error); } }).withFailureHandler(handleError).deleteObservation(obsId); } }

        function handleFinalizeObservation(obsId, email, name) {
            if (confirm('Are you sure you want to finalize this observation? You will not be able to edit it further.')) {
                showLoading('Finalizing observation, please wait...');
                google.script.run
                    .withSuccessHandler(res => {
                        hideLoading();
                        if (res.success) {
                            showToast('Observation finalized. Generating PDF...', true);
                            // Refresh the view to show the "Generating..." button
                            displayObservationOptions(email, name);
                        } else {
                            showError(res.error);
                        }
                    })
                    .withFailureHandler(handleError)
                    .finalizeObservation(obsId);
            }
        }

        function handleFinalizeFromNav() {
            if (!currentObservationId || !currentObservedUser.email || !currentObservedUser.name) {
                showError('Unable to finalize: Missing observation context.');
                return;
            }
            
            if (confirm('Are you sure you want to finalize this observation? You will not be able to edit it further.')) {
                showLoading('Finalizing observation, please wait...');
                google.script.run
                    .withSuccessHandler(res => {
                        hideLoading();
                        if (res.success) {
                            showToast('Observation finalized. Generating PDF...', true);
                            // Navigate back to observation list
                            displayObservationOptions(currentObservedUser.email, currentObservedUser.name);
                        } else {
                            showError(res.error);
                        }
                    })
                    .withFailureHandler(handleError)
                    .finalizeObservation(currentObservationId);
            }
        }

        function handleViewObservation(obsId) {
            console.log('Loading finalized observation for viewing:', obsId);
            
            // Clear all existing observation state before loading different observation
            clearObservationState();
            
            showLoading('Loading observation...');
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .loadFinalizedObservationForViewing(obsId);
        }

        function handleDeleteFinalizedObservation(obsId, email, name) {
            if (confirm('Are you sure you want to PERMANENTLY DELETE this finalized observation? This action cannot be undone.')) {
                showLoading('Deleting observation...');
                google.script.run.withSuccessHandler(res => {
                    if(res.success) {
                        displayObservationOptions(email, name);
                    } else {
                        showError(res.error);
                    }
                }).withFailureHandler(handleError).deleteFinalizedObservation(obsId);
            }
        }

        function handleViewPdf(obsId) {
            showLoading('Retrieving PDF...');
            google.script.run.withSuccessHandler(res => {
                hideLoading();
                if (res.success) {
                    window.open(res.pdfUrl, '_blank');
                } else {
                    showError(res.error);
                }
            }).withFailureHandler(handleError).getObservationPdfUrl(obsId);
        }

        function handleRetryPdf(obsId) {
            if (confirm('This will attempt to regenerate the PDF for this observation. Continue?')) {
                showLoading('Requesting PDF regeneration...');
                _setPdfButtonState(obsId, 'generating');

                google.script.run.withSuccessHandler(res => {
                    hideLoading();
                    if (res.success) {
                        showToast('PDF regeneration started successfully!', true);
                        startPdfPolling(obsId);
                    } else {
                         showError('PDF regeneration failed: ' + res.error);
                         _setPdfButtonState(obsId, 'failed');
                    }
                }).withFailureHandler(error => {
                    handleError(error);
                    _setPdfButtonState(obsId, 'failed');
                }).regenerateObservationPdf(obsId);
            }
        }

        function toggleLookFors(componentId) {
            const content = document.getElementById(`lookForsContent-${componentId}`);
            const chevron = document.getElementById(`chevron-${componentId}`);

            if (content && chevron) {
                const isExpanded = content.classList.toggle('expanded');
                chevron.textContent = isExpanded ? '▼' : '▶';
                try {
                    if (!window.pageLoadInfo) return;
                    const storageKey = `lookForsState_${window.pageLoadInfo.cacheVersion}`;
                    const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');
                    allStates[componentId] = isExpanded;
                    sessionStorage.setItem(storageKey, JSON.stringify(allStates));
                } catch (e) {
                    console.warn('SessionStorage not available for look-fors state.');
                }
            }
        }

        function restoreLookForsState() {
            try {
                if (!window.pageLoadInfo) return;
                const storageKey = `lookForsState_${window.pageLoadInfo.cacheVersion}`;
                const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');

                for (const componentId in allStates) {
                    if (allStates[componentId] === true) {
                        const content = document.getElementById(`lookForsContent-${componentId}`);
                        const chevron = document.getElementById(`chevron-${componentId}`);
                        if (content && chevron) {
                            content.classList.add('expanded');
                            chevron.textContent = '▼';
                        }
                    }
                }
            } catch (e) {
                console.warn('Could not restore look-fors state:', e);
            }
        }

        function goBackToObservations() {
            if (currentObservedUser.email && currentObservedUser.name) {
                displayObservationOptions(currentObservedUser.email, currentObservedUser.name);
            } else {
                // Return to appropriate view based on user role
                if (userContext.role === 'Administrator') {
                    showView('adminStaffListView');
                } else {
                    showView('customFiltersView');
                }
            }
        }

        function handleRubricData(result) {
            hideLoading();
            console.log('handleRubricData received:', result);
            
            if (!result.success) return showError(result.error);
            if (result.action === 'show_observation_selector') {
                currentObservedUser.email = result.observedEmail;
                currentObservedUser.name = result.observedName;
                hideStickyNav(); // Hide nav when going back to selector
                return displayObservationOptions(result.observedEmail, result.observedName);
            }
            
            if (result.action === 'redirect') {
                console.log('Processing redirect with params:', result.redirectParams);
                const url = new URL(window.location);
                Object.keys(result.redirectParams).forEach(key => {
                    url.searchParams.set(key, result.redirectParams[key]);
                });
                console.log('Redirecting to:', url.toString());
                window.location.href = url.toString();
                return;
            }
            
            if (result.action === 'show_html') {
                console.log('Processing show_html action - replacing page content');
                // Replace the entire page content with the generated HTML
                document.open();
                document.write(result.htmlContent);
                document.close();
                return;
            }

            const { observation, rubricData } = result;
            
            // Clear previous Quill instances and notes data before loading new observation
            if (observation) {
                console.log('Loading new observation data, ensuring clean state...');
                clearQuillInstances();
            }
            
            currentObservationId = observation ? observation.observationId : null;
            clearWorkProductAnswersCache(); // Clear cache when switching observations
            if (observation) {
                currentObservedUser.email = observation.observedEmail;
                currentObservedUser.name = observation.observedName;
                console.log('Observation context set:', {
                    observationId: currentObservationId,
                    observedUser: currentObservedUser
                });
            }
            observationViewMode = (rubricData.userContext && rubricData.userContext.viewMode) || 'assigned';

            // Store observation type and show work product section if needed
            window.currentObservationType = result.observation?.Type || 'Standard';
            toggleWorkProductAnswersSection(window.currentObservationType === 'Work Product');

            // Auto-load answers for work product observations
            if (window.currentObservationType === 'Work Product') {
                refreshWorkProductAnswers();
            }

            // Store rubricData globally for nav functions
            window.rubricData = rubricData;
            
            // Show sticky navigation when viewing rubric
            showStickyNav(observation);

            window.pageLoadInfo = {
                cacheVersion: rubricData.userContext ? rubricData.userContext.cacheVersion : 'unknown'
            };
            
            updateFilterStatus(rubricData, observation);
            const rubricHtml = generateInteractiveRubricHtml(rubricData, observation);
            
            const rubricContainer = document.getElementById('rubricContainer');
            if (rubricContainer) {
                rubricContainer.innerHTML = rubricHtml;
            } else {
                console.error('ERROR: rubricContainer element not found!');
            }

            // Switch to rubric view immediately after HTML injection
            showView('rubricContainer');

            // Initialize notes data from observation if available
            if (observation && observation.observationData) {
                console.log('Loading observation notes data for', Object.keys(observation.observationData).length, 'components');
                Object.keys(observation.observationData).forEach(componentId => {
                    const componentData = observation.observationData[componentId];
                    if (componentData && componentData.notes) {
                        window.globalObservationNotes[componentId] = componentData.notes;
                        console.log(`Loaded notes for component ${componentId}`);
                    }
                });

                // Schedule recovery for components with notes data
                setTimeout(() => {
                    ensureEditorsForNotesData(rubricData.userContext.isEvaluator);
                }, 500);
            } else {
                console.log('No observation data to load');
            }

            // Show global tools bar for evaluators after DOM injection
            if (rubricData.userContext && rubricData.userContext.isEvaluator) {
                updateComponentVisibility();

                // Show global tools bar after HTML is in the DOM
                const globalToolsBar = document.getElementById('globalToolsBar');
                if (globalToolsBar) {
                    globalToolsBar.style.display = 'block';
                } else {
                    console.error('ERROR: globalToolsBar element not found after HTML injection!');
                }
            } else {
                // For read-only finalized observations, still need to apply component visibility
                // based on the assigned view mode
                updateComponentVisibility();
            }
            restoreLookForsState();
        }

        function generateInteractiveRubricHtml(data, observation) {
            if (!data) {
                console.error('ERROR: No data provided to generateInteractiveRubricHtml');
                return '<div class="error">No rubric data available</div>';
            }
            
            if (!data.domains || !Array.isArray(data.domains) || data.domains.length === 0) {
                console.error('ERROR: No domains found in rubric data:', data);
                return '<div class="error">No rubric domains available</div>';
            }
            
            const isEvaluator = data.userContext && data.userContext.isEvaluator;
            const isFinalized = observation && observation.status === 'Finalized';
            const isReadOnlyView = isFinalized && !isEvaluator;
            
            let html = `<div class="${isReadOnlyView ? 'finalized-view' : ''}" style="background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">`;

            // Header section - different for editing vs finalized viewing
            if (isEvaluator) {
                const today = new Date().toISOString().slice(0, 10);
                const defaultObsName = `${observation.observedName.split(' ').pop()}, ${observation.observedName.split(' ')[0]}_${today}`;
                html += `
                <div class="observation-metadata-display">
                    <div class="filter-row">
                        <span class="obs-field-display obs-name-field">${escapeHtml(observation.observationName || defaultObsName)}</span>
                        <span class="obs-field-display obs-date-field">${escapeHtml(observation.observationDate || today)}</span>
                    </div>
                </div>`;
            } else if (isReadOnlyView) {
                // Read-only header for finalized observations
                html += `
                <div class="finalized-observation-header">
                    <div class="finalized-status">
                        <span class="status-indicator">✅ Finalized Observation</span>
                    </div>
                    <div class="observation-details">
                        <span class="obs-name">${escapeHtml(observation.observationName || 'Observation')}</span>
                        <span class="obs-date">${escapeHtml(observation.observationDate || '')}</span>
                    </div>
                </div>`;
            }

            // Global tools bar visibility will be handled after DOM injection

            html += `
            <div class="global-tools-bar" id="globalToolsBar" style="display: none;">
                <div class="global-tools-container">
                    <button class="global-tool-btn" id="recordAudioBtn" onclick="toggleAudioRecording()">
                        🎤 Record Audio
                    </button>
                    <div id="audioTimerDisplay" class="timer-display"></div>
                    <button class="global-tool-btn" id="recordVideoBtn" onclick="toggleVideoRecording()">
                        📹 Record Video
                    </button>
                    <div id="videoTimerDisplay" class="timer-display"></div>
                    <button class="global-tool-btn" id="scriptEditorBtn" onclick="openScriptEditor()">
                        📝 Script Editor
                    </button>
                </div>
            </div>`;

            // Old navigation buttons removed - now handled by sticky nav

            data.domains.forEach((domain, domainIdx) => {
                html += `<div class="domain-section" id="domain-${domainIdx}"><div class="domain-header">${domain.name}</div>`;
                html += `<div class="performance-levels-header"><div class="performance-levels"><div class="level-header"></div><div class="level-header">Developing</div><div class="level-header">Basic</div><div class="level-header">Proficient</div><div class="level-header">Distinguished</div></div></div>`;
                
                if (!domain.components || !Array.isArray(domain.components)) {
                    console.error(`Domain ${domainIdx} has no components or invalid components:`, domain.components);
                    html += `<div class="error">Domain components not available</div>`;
                    return;
                }
                
                domain.components.forEach((comp, compIdx) => {
                    const componentId = comp.componentId;
                    const isAssigned = comp.isAssigned || false;
                    const selectedProficiency = observation?.observationData?.[componentId]?.proficiency;
                    const evidence = observation?.evidenceLinks?.[componentId] || [];

                    html += `<div class="component-section ${isAssigned ? 'component-assigned' : 'component-not-assigned'}" data-component-id="${componentId}" data-is-assigned="${isAssigned}"><div class="performance-levels-content">`;
                    html += `<div class="row-label">${comp.title}</div>`;
                    ['developing', 'basic', 'proficient', 'distinguished'].forEach(level => {
                        const isSelected = selectedProficiency === level;
                        html += `<div class="level-content ${isEvaluator ? 'editable' : ''} ${isSelected ? 'selected' : ''}" data-level="${level}" onclick="${isEvaluator ? `selectProficiency(this, '${componentId}', '${level}')` : ''}">${comp[level] || ''}</div>`;
                    });
                    html += `</div>`;

                    // Look-fors section (collapsible blue header, directly below subdomain rows)
                    if (comp.bestPractices && comp.bestPractices.length > 0) {
                        const lookForsId = `domain-${domainIdx}-component-${compIdx}`;
                        html += `<div class="look-fors-section">`;
                        html += `<div class="look-fors-header" onclick="toggleLookFors('${lookForsId}')">`;
                        html += `<span>Best Practices aligned with 5D+ and PELSB Standards</span>`;
                        html += `<span class="chevron" id="chevron-${lookForsId}">▶</span>`;
                        html += `</div>`;
                        html += `<div class="look-fors-content" id="lookForsContent-${lookForsId}">`;
                        html += `<div class="look-fors-grid">`;
                        comp.bestPractices.forEach((practice, practiceIdx) => {
                            const practiceId = `practice-${domainIdx}-${compIdx}-${practiceIdx}`;
                            const sanitizedPractice = escapeHtml(practice);
                            const onchangeHandler = isEvaluator ? `onchange="handleLookForChange(this, '${componentId}')"` : '';
                            
                            // Check if this practice is already selected in existing observation data
                            const existingLookfors = observation?.observationData?.[componentId]?.lookfors || [];
                            const isChecked = existingLookfors.includes(practice);
                            const checkedAttribute = isChecked ? 'checked' : '';
                            
                            html += `<div class="look-for-item">`;
                            html += `<input type="checkbox" id="${practiceId}" ${checkedAttribute} ${onchangeHandler}><label for="${practiceId}">${sanitizedPractice}</label>`;
                            html += `</div>`;
                        });
                        html += `</div></div></div>`;
                    }

                    // Notes & Evidence section (for evaluators only - contains notes editor and media upload)
                    // Check if we should show Notes & Evidence (for evaluators AND finalized observation viewing)
                    const hasObservationData = observation?.observationData?.[componentId];
                    const hasNotes = hasObservationData?.notes && hasObservationData.notes.trim() !== '' && hasObservationData.notes !== '<p><br></p>';
                    const hasEvidence = evidence && evidence.length > 0;
                    
                    if (isEvaluator || (isReadOnlyView && (hasNotes || hasEvidence))) {
                        html += `<div class="evidence-section ${isReadOnlyView ? 'readonly-evidence' : ''}">`;
                        html += `<div class="evidence-toggle-btn" onclick="toggleEvidenceSection('evidence-${componentId}')">`;
                        html += `<span>📝 Notes & Evidence</span>`;
                        html += `<span class="chevron" id="evidence-chevron-${componentId}">▶</span>`;
                        html += `</div>`;
                        html += `<div class="evidence-content ${isReadOnlyView ? 'expanded' : ''}" id="evidence-${componentId}">`;
                        
                        // Notes container
                        const sanitizedComponentId = componentId.replace(/[^a-zA-Z0-9]/g, '');
                        html += `<div class="notes-container">`;
                        html += `<h4>Observation Notes</h4>`;
                        
                        if (isEvaluator) {
                            // Editable notes for evaluators
                            html += `<div class="notes-header-actions">`;
                            html += `<button class="clear-notes-btn" onclick="clearNotes('${componentId}')" title="Clear all notes for this component">🗑️ Clear All</button>`;
                            html += `</div>`;
                            html += `<div id="notes-editor-${sanitizedComponentId}"></div>`;
                        } else if (isReadOnlyView && hasNotes) {
                            // Read-only notes display for finalized observations
                            html += `<div class="readonly-notes-content">`;
                            html += hasObservationData.notes;
                            html += `</div>`;
                        } else if (isReadOnlyView) {
                            // No notes message for finalized observations
                            html += `<div class="no-notes-message">No observation notes recorded.</div>`;
                        }
                        
                        html += `</div>`;
                        
                        // Evidence section - different for editing vs viewing
                        if (hasEvidence || isEvaluator) {
                            let evidenceHtml = '';
                            evidence.forEach(item => { evidenceHtml += `<div class="evidence-item"><a href="${item.url}" target="_blank" rel="noopener noreferrer">${item.name}</a></div>`; });
                            
                            html += `<div class="media-upload-container">`;
                            
                            if (isEvaluator) {
                                // Editable evidence upload for evaluators
                                html += `<h4>Upload Evidence</h4>`;
                                html += `<input type="file" class="media-upload-input" id="media-upload-${componentId}" onchange="uploadSelectedFile('${componentId}')" style="display: none;">`;
                                html += `<button class="media-upload-button" onclick="triggerFileUpload('${componentId}')">📎 Select & Upload File</button>`;
                            } else {
                                // Read-only evidence for finalized observations
                                html += `<h4>Evidence Files</h4>`;
                            }
                            
                            html += `<div class="media-links-container" data-component-id="${componentId}">`;
                            html += `<ul>${evidenceHtml}</ul>`;
                            html += `</div></div>`;
                        }
                        
                        // Close evidence-content and evidence-section
                        html += `</div></div>`;
                    }
                    html += `</div>`;
                });
                html += `</div>`;
            });
            html += `</div>`;
            
            return html;
        }

        function updateFilterStatus(rubricData, observation) {
            const status = document.getElementById('filterStatus');
            
            if (observation) {
                // Hide status div completely when viewing observations - main heading provides context
                status.style.display = 'none';
                return;
            }
            
            // Keep existing logic for other contexts (role viewing, etc.)
            const statusText = document.getElementById('filterStatusText');
            let text = 'Viewing Your Own Rubric';
            if (rubricData?.userContext?.filterInfo) {
                text = `Viewing as: ${rubricData.userContext.filterInfo.viewingAs} (${rubricData.userContext.filterInfo.viewingRole}, Year ${rubricData.userContext.filterInfo.viewingYear})`;
            }
            statusText.innerHTML = text;
            status.style.display = 'block';
        }


        function selectProficiency(element, componentId, proficiency) {
            if (!currentObservationId || !componentId || !proficiency) {
                console.error('Missing data for proficiency selection:', { currentObservationId, componentId, proficiency });
                return;
            }

            const parentRow = element.closest('.performance-levels-content');
            const currentlySelected = parentRow.querySelector('.level-content.selected');

            // --- Instant UI Update ---
            if (currentlySelected) {
                currentlySelected.classList.remove('selected');
            }
            element.classList.add('selected');

            // --- Background Save ---
            google.script.run
                .withSuccessHandler(function(response) {
                    if (response.success) {
                        console.log('Proficiency saved:', { componentId, proficiency });
                        // Optionally show a subtle success indicator
                    } else {
                        console.error('Failed to save proficiency:', response.error);
                        // --- Revert UI on Failure ---
                        element.classList.remove('selected');
                        if (currentlySelected) {
                            currentlySelected.classList.add('selected');
                        }
                        showToast('Error saving selection: ' + response.error);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Server error saving proficiency:', error);
                    // --- Revert UI on Failure ---
                    element.classList.remove('selected');
                    if (currentlySelected) {
                        currentlySelected.classList.add('selected');
                    }
                    showToast('Server error: ' + error.message);
                })
                .saveProficiencySelection(currentObservationId, componentId, proficiency);
        }
        function uploadFile(fileInput, componentId) {
            const file = fileInput.files[0]; if (!file) return;
            const statusEl = document.getElementById(`upload-status-${componentId}`); statusEl.textContent = 'Uploading...';
            const reader = new FileReader();
            reader.onload = e => {
                const base64Data = e.target.result.split(',')[1];
                google.script.run.withSuccessHandler(result => {
                    if (result.success) {
                        statusEl.textContent = 'Upload complete.'; fileInput.value = '';
                        const listEl = document.getElementById(`evidence-list-${componentId}`);
                        listEl.innerHTML += `<div class="evidence-item"><a href="${result.fileUrl}" target="_blank">${result.fileName}</a></div>`;
                        setTimeout(() => { statusEl.textContent = 'Select another file?'; }, 3000);
                    } else { handleError(result); statusEl.textContent = 'Upload failed.'; }
                }).withFailureHandler(handleError).uploadMediaEvidence(currentObservationId, componentId, base64Data, file.name, file.type);
            };
            reader.readAsDataURL(file);
        }
        function toggleObservationView() { observationViewMode = observationViewMode === 'assigned' ? 'full' : 'assigned'; updateComponentVisibility(); }
        function updateComponentVisibility() {
            const components = document.querySelectorAll('.component-section');
            if (observationViewMode === 'assigned') {
                components.forEach(comp => { comp.style.display = comp.dataset.isAssigned === 'true' ? '' : 'none'; });
            } else {
                components.forEach(comp => { comp.style.display = ''; });
            }
        }
        
        // Global Quill management system - consolidated for both interfaces
        window.globalQuillInstances = window.globalQuillInstances || {};
        window.globalObservationNotes = window.globalObservationNotes || {};
        
        function toggleEvidenceSection(contentId) {
            console.log('toggleEvidenceSection called with:', contentId);
            
            // Validate observation context
            if (!currentObservationId) {
                console.warn('Cannot toggle evidence section: No active observation');
                showToast('No active observation - cannot edit evidence', false);
                return;
            }
            
            const content = document.getElementById(contentId);
            if (!content) {
                console.error('Evidence content element not found:', contentId);
                return;
            }
            console.log('Found evidence content element:', content);

            const isExpanded = content.classList.toggle('expanded');
            console.log('Evidence section expanded state:', isExpanded);
            const componentId = contentId.replace('evidence-', '');
            console.log('Component ID:', componentId);

            // Toggle chevron
            const chevron = document.getElementById(`evidence-chevron-${componentId}`);
            if (chevron) {
                chevron.textContent = isExpanded ? '▼' : '▶';
            }

            // Initialize Quill on first expansion if not already initialized
            if (isExpanded && !window.globalQuillInstances[componentId]) {
                console.log('Initializing Quill editor for component:', componentId);
                const success = initializeQuillEditor(componentId);
                if (!success) {
                    console.error('Failed to initialize Quill editor for component:', componentId);
                    showToast(`Failed to initialize text editor for ${componentId}`, false);
                }
            } else if (isExpanded) {
                console.log('Quill instance already exists for component:', componentId);
                
                // Validate existing instance is functional
                const existingEditor = window.globalQuillInstances[componentId];
                if (!existingEditor || !existingEditor.root) {
                    console.warn('Existing Quill instance appears broken, re-initializing...');
                    delete window.globalQuillInstances[componentId];
                    const success = initializeQuillEditor(componentId);
                    if (!success) {
                        console.error('Failed to re-initialize Quill editor for component:', componentId);
                        showToast(`Failed to initialize text editor for ${componentId}`, false);
                    }
                }
            }

            // Store state in sessionStorage for persistence
            try {
                const storageKey = 'evidenceState_' + (window.pageLoadInfo?.cacheVersion || 'default');
                const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');
                allStates[componentId] = isExpanded;
                sessionStorage.setItem(storageKey, JSON.stringify(allStates));
            } catch (e) {
                console.warn('Could not save evidence section state:', e);
            }
        }

        // Consolidated Quill initialization function - make globally available
        window.initializeQuillEditor = function(componentId) {
            console.log('Attempting to initialize Quill editor for:', componentId);
            
            // Validate observation context
            if (!currentObservationId) {
                console.warn(`Cannot initialize Quill editor for ${componentId}: No active observation`);
                return false;
            }
            
            const sanitizedComponentId = componentId.replace(/[^a-zA-Z0-9]/g, '');
            const editorId = 'notes-editor-' + sanitizedComponentId;
            const editorElement = document.getElementById(editorId);
            
            if (!editorElement) {
                console.error('Notes editor element not found:', editorId);
                return false;
            }

            // Check if this component already has a Quill instance in our global registry
            if (window.globalQuillInstances[componentId]) {
                const existingEditor = window.globalQuillInstances[componentId];
                console.log('Quill instance already exists in global registry for:', componentId);
                
                // Verify the existing editor is still valid and attached to the correct element
                if (existingEditor && existingEditor.root && existingEditor.root.parentNode === editorElement) {
                    // Load existing notes content if available and not already loaded
                    if (window.globalObservationNotes[componentId] && 
                        (!existingEditor.root.innerHTML || existingEditor.root.innerHTML === '<p><br></p>')) {
                        existingEditor.root.innerHTML = window.globalObservationNotes[componentId];
                        console.log('Loaded existing notes for component:', componentId);
                    }
                    return true;
                } else {
                    // Existing editor is invalid, clean it up
                    console.warn(`Cleaning up invalid Quill instance for ${componentId}`);
                    delete window.globalQuillInstances[componentId];
                }
            }

            // Check if DOM element already has a Quill instance (prevent duplicates)
            if (editorElement.__quill) {
                console.log('Quill already initialized on DOM element:', editorId);
                const existingEditor = editorElement.__quill;
                
                // Verify this editor is functional
                if (existingEditor && existingEditor.root) {
                    window.globalQuillInstances[componentId] = existingEditor;
                    
                    // Load existing notes content if available and not already loaded
                    if (window.globalObservationNotes[componentId] && 
                        (!existingEditor.root.innerHTML || existingEditor.root.innerHTML === '<p><br></p>')) {
                        existingEditor.root.innerHTML = window.globalObservationNotes[componentId];
                        console.log('Loaded existing notes for component:', componentId);
                    }
                    
                    // Ensure auto-save is set up (check if already has listeners to avoid duplicates)
                    if (!existingEditor._hasAutoSaveListener) {
                        let timeout;
                        existingEditor.on('text-change', () => {
                            clearTimeout(timeout);
                            timeout = setTimeout(() => {
                                saveNotes(componentId, existingEditor.root.innerHTML);
                            }, 1500);
                        });
                        existingEditor._hasAutoSaveListener = true;
                        console.log('Auto-save listener attached to existing editor for:', componentId);
                    }
                    
                    return true;
                } else {
                    // DOM element has broken Quill instance, clean it up
                    console.warn(`Cleaning up broken Quill instance on DOM element for ${componentId}`);
                    delete editorElement.__quill;
                }
            }
            
            console.log('Found editor element:', editorId);
            try {
                // Check if Quill is available
                if (typeof Quill === 'undefined') {
                    console.error('Quill library failed to load from CDN');
                    showToast('Rich text editor unavailable. Please refresh the page.');
                    return false;
                }
                
                const editor = new Quill(editorElement, {
                    theme: 'snow',
                    modules: {
                        toolbar: [
                            [{ 'header': [1, 2, false] }],
                            ['bold', 'italic', 'underline'],
                            [{'list': 'ordered'}, {'list': 'bullet'}],
                            ['clean']
                        ]
                    }
                });
                console.log('Quill editor created successfully');

                // Load existing notes 
                if (window.globalObservationNotes[componentId]) {
                    editor.root.innerHTML = window.globalObservationNotes[componentId];
                    console.log('Loaded existing notes for component:', componentId);
                }

                // Add debounced auto-save
                let timeout;
                editor.on('text-change', () => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        saveNotes(componentId, editor.root.innerHTML);
                    }, 1500); // Save 1.5 seconds after typing stops
                });
                editor._hasAutoSaveListener = true;

                window.globalQuillInstances[componentId] = editor;
                console.log('Quill editor initialized for component:', componentId);
                return true;
            } catch (error) {
                console.error('Error initializing Quill editor:', error);
                return false;
            }
        }
        
        function saveNotes(componentId, content) {
            if (!currentObservationId) {
                console.error('Cannot save notes: No observation context available.');
                showToast('Error: No active observation found. Cannot save notes.');
                return;
            }

            // Update local data using global storage
            window.globalObservationNotes[componentId] = content;

            google.script.run
                .withSuccessHandler(() => console.log(`Notes saved for ${componentId}`))
                .withFailureHandler(error => {
                    console.error('Failed to save notes:', error);
                    showToast('Error saving notes. Please check your connection.');
                })
                .saveObservationNotes(currentObservationId, componentId, content);
        }

        // Clear all notes for a specific component
        window.clearNotes = function(componentId) {
            if (!confirm(`Are you sure you want to clear all notes for this component?\n\nThis action cannot be undone.`)) {
                return;
            }

            const editor = window.globalQuillInstances[componentId];
            if (editor) {
                editor.setContents([], 'user'); // Clear content and trigger change event
                console.log(`Notes cleared for component: ${componentId}`);
                showToast(`Notes cleared for ${componentId}`, true);
                
                // Immediately save the cleared state
                window.globalObservationNotes[componentId] = '';
                saveNotes(componentId, '');
            } else {
                console.warn(`No editor found for component: ${componentId}`);
                showToast(`No notes to clear for ${componentId}`, false);
            }
        }

        // Recovery mechanism to ensure all components with notes data have editors
        function ensureEditorsForNotesData(isEvaluator) {
            if (!isEvaluator || !window.globalObservationNotes) {
                return;
            }
            
            console.log('Running recovery mechanism for orphaned notes data...');
            
            Object.keys(window.globalObservationNotes).forEach(componentId => {
                const notesContent = window.globalObservationNotes[componentId];
                if (notesContent && notesContent.trim() !== '' && notesContent !== '<p><br></p>') {
                    // Check if editor exists
                    if (!window.globalQuillInstances[componentId]) {
                        console.log(`Found orphaned notes data for ${componentId}, attempting to initialize editor...`);
                        
                        // Check if the evidence section exists but is collapsed
                        const evidenceSectionId = `evidence-${componentId}`;
                        const evidenceSection = document.getElementById(evidenceSectionId);
                        
                        if (evidenceSection) {
                            // Expand the section if collapsed
                            const content = document.getElementById(evidenceSectionId);
                            if (content && !content.classList.contains('expanded')) {
                                console.log(`Expanding collapsed section for ${componentId} to recover notes...`);
                                toggleEvidenceSection(evidenceSectionId);
                            }
                            
                            // Try to initialize the editor with a slight delay
                            setTimeout(() => {
                                if (!window.globalQuillInstances[componentId]) {
                                    console.log(`Force initializing editor for ${componentId}...`);
                                    const success = window.initializeQuillEditor(componentId);
                                    if (success) {
                                        console.log(`Successfully recovered notes editor for ${componentId}`);
                                    } else {
                                        console.warn(`Failed to recover notes editor for ${componentId}`);
                                    }
                                }
                            }, 200);
                        } else {
                            console.warn(`Evidence section not found for ${componentId}, cannot recover notes`);
                        }
                    } else {
                        // Editor exists, ensure content is loaded
                        const editor = window.globalQuillInstances[componentId];
                        if (editor && (!editor.root.innerHTML || editor.root.innerHTML === '<p><br></p>')) {
                            editor.root.innerHTML = notesContent;
                            console.log(`Restored content to existing editor for ${componentId}`);
                        }
                    }
                }
            });
        }

        function triggerFileUpload(componentId) {
            const fileInput = document.getElementById(`media-upload-${componentId}`);
            if (!fileInput) {
                console.error('File input not found for component:', componentId);
                return;
            }
            
            // Trigger the file picker
            fileInput.click();
        }

        function uploadSelectedFile(componentId) {
            const fileInput = document.getElementById(`media-upload-${componentId}`);
            if (!fileInput) {
                console.error('File input not found for component:', componentId);
                return;
            }

            const file = fileInput.files[0];
            if (!file) {
                return; // No file selected, user probably cancelled
            }

            if (!currentObservationId) {
                showToast('No observation selected. Please save the observation first.');
                return;
            }

            showToast('Uploading file...', false);

            // Convert file to base64 for Google Apps Script
            const reader = new FileReader();
            reader.onload = function(e) {
                const fileData = {
                    name: file.name,
                    mimeType: file.type,
                    content: e.target.result.split(',')[1], // Remove data:mime;base64, prefix
                    size: file.size
                };

                google.script.run
                    .withSuccessHandler(function(result) {
                        if (result.success) {
                            showToast('File uploaded successfully!', true);
                            updateMediaLinks(componentId, result.fileUrl, result.fileName);
                            fileInput.value = ''; // Clear the input
                        } else {
                            showToast('Upload failed: ' + result.error);
                        }
                    })
                    .withFailureHandler(function(error) {
                        console.error('Upload error:', error);
                        showToast('Upload failed. Please try again.');
                    })
                    .uploadMediaEvidence(currentObservationId, componentId, fileData.content, fileData.name, fileData.mimeType);
            };
            reader.onerror = function() {
                showToast('Error reading file. Please try again.');
            };
            reader.readAsDataURL(file);
        }

        function updateMediaLinks(componentId, fileUrl, fileName) {
            const linksContainer = document.querySelector(`[data-component-id="${componentId}"] ul`);
            if (linksContainer) {
                const listItem = document.createElement('li');
                listItem.className = 'evidence-item';
                listItem.innerHTML = `<a href="${fileUrl}" target="_blank">${fileName}</a>`;
                linksContainer.appendChild(listItem);
            }
        }
        
        function handleLookForChange(checkbox, componentId) {
            const lookForText = checkbox.nextElementSibling.textContent;
            const isChecked = checkbox.checked;

            if (!currentObservationId) {
                console.error('Cannot save look-for selection: Observation context not available.');
                checkbox.checked = !isChecked; // Revert the checkbox state
                showToast('Error: No active observation found. Cannot save selection.');
                return;
            }

            google.script.run
                .withSuccessHandler(() => {
                    console.log(`Saved look-for: ${componentId} -> ${lookForText}`);
                })
                .withFailureHandler(error => {
                    console.error('Save failed:', error);
                    checkbox.checked = !isChecked; // Revert the checkbox state on failure
                    showToast('Failed to save look-for selection. Please check your connection.');
                })
                .saveLookForSelection(currentObservationId, componentId, lookForText, isChecked);
        }
        
        // === New Sticky Navigation Functions ===
        
        function setViewMode(mode) {
            observationViewMode = mode;
            updateViewToggle();
            updateComponentVisibility();
        }
        
        function updateViewToggle() {
            const assignedToggle = document.getElementById('assignedToggle');
            const fullToggle = document.getElementById('fullToggle');
            const slider = document.getElementById('toggleSlider');
            
            if (!assignedToggle || !fullToggle || !slider) return;
            
            // Update active states
            assignedToggle.classList.toggle('active', observationViewMode === 'assigned');
            fullToggle.classList.toggle('active', observationViewMode === 'full');
            
            // Animate slider position
            const toggleWidth = assignedToggle.offsetWidth;
            if (observationViewMode === 'assigned') {
                slider.style.width = toggleWidth + 'px';
                slider.style.transform = 'translateX(0)';
            } else {
                slider.style.width = fullToggle.offsetWidth + 'px';
                slider.style.transform = `translateX(${toggleWidth}px)`;
            }
        }
        
        function showStickyNav(observation) {
            const stickyNav = document.getElementById('stickyNav');
            const viewToggle = document.getElementById('viewToggle');
            const staffContext = document.getElementById('staffContext');
            const staffName = document.getElementById('staffName');
            const navActions = document.getElementById('navActions');
            const finalizeBtn = document.getElementById('finalizeBtn');
            
            if (!stickyNav) return;
            
            stickyNav.classList.add('show');
            
            if (observation) {
                // Show staff context
                if (staffContext && staffName) {
                    staffName.textContent = observation.observedName || 'N/A';
                    staffContext.style.display = 'block';
                }
                
                // Show view toggle for evaluators
                if (viewToggle && window.rubricData?.userContext?.isEvaluator) {
                    viewToggle.style.display = 'flex';
                    updateViewToggle();
                }
                
                // Show action buttons for draft observations
                if (navActions && observation.status === 'Draft') {
                    navActions.style.display = 'flex';
                }
                
                // Update finalize button text based on status
                if (finalizeBtn) {
                    if (observation.status === 'Draft') {
                        finalizeBtn.textContent = '✅ Finalize & Submit';
                        finalizeBtn.onclick = handleFinalizeFromNav;
                    } else {
                        finalizeBtn.style.display = 'none';
                    }
                }
            }
        }
        
        function hideStickyNav() {
            const stickyNav = document.getElementById('stickyNav');
            if (stickyNav) {
                stickyNav.classList.remove('show');
            }
        }
        
        
        // Update existing functions to work with new nav
        const originalToggleObservationView = toggleObservationView;
        toggleObservationView = function() {
            originalToggleObservationView();
            updateViewToggle();
        };

        const userContext = <?!= JSON.stringify(userContext) ?>;

        document.addEventListener('DOMContentLoaded', () => {
            if (userContext.role === 'Administrator') {
                showView('adminStaffListView');
                loadAdminStaffList();
            } else {
                showView('quickActionsView');
            }
        });

        function loadAdminStaffList() {
            showLoading('Loading staff list...');
            google.script.run
                .withSuccessHandler(populateAdminStaffList)
                .withFailureHandler(handleError)
                .getStaffListForDropdown(null, null);
        }

        // Store staff data globally for filtering
        let allStaffData = [];

        function populateAdminStaffList(result) {
            hideLoading();
            if (!result.success) {
                showError(result.error);
                return;
            }

            // Store the staff data for filtering
            allStaffData = result.staff || [];
            
            // Initially show all staff (default filter)
            renderStaffList(allStaffData);
        }

        function renderStaffList(staffToShow) {
            const container = document.getElementById('adminStaffList');
            container.innerHTML = ''; // Clear existing content

            if (staffToShow && staffToShow.length > 0) {
                staffToShow.forEach(staff => {
                    const listItem = document.createElement('div');
                    listItem.className = 'staff-list-item';
                    listItem.onclick = () => displayObservationOptions(staff.email, staff.name);

                    // Determine if probationary (P1, P2, P3: years 4, 5, 6) or tenured (years 1, 2, 3)
                    const isProbationary = [PROB_YEAR_1, PROB_YEAR_2, PROB_YEAR_3].includes(staff.year) ||
                                         staff.year === 0 || staff.year === 'Probationary'; // backward compatibility
                    
                    // Set data attribute for filtering
                    listItem.setAttribute('data-staff-type', isProbationary ? 'probationary' : 'tenured');

                    const mainSection = document.createElement('div');
                    mainSection.className = 'staff-item-main';

                    const icon = document.createElement('span');
                    icon.className = 'staff-item-icon';
                    icon.textContent = '👤';

                    const infoSection = document.createElement('div');
                    infoSection.className = 'staff-item-info';

                    const name = document.createElement('div');
                    name.className = 'staff-item-name';
                    name.textContent = staff.name;

                    const details = document.createElement('div');
                    details.className = 'staff-item-details';
                    details.textContent = `${staff.role}`;

                    const yearBadge = document.createElement('div');
                    yearBadge.className = `staff-item-year-badge ${isProbationary ? 'probationary' : 'tenured'}`;
                    yearBadge.textContent = formatYearDisplay(staff.year);

                    infoSection.appendChild(name);
                    infoSection.appendChild(details);
                    mainSection.appendChild(icon);
                    mainSection.appendChild(infoSection);
                    
                    listItem.appendChild(mainSection);
                    listItem.appendChild(yearBadge);
                    container.appendChild(listItem);
                });
            } else {
                const noStaffMessage = document.createElement('div');
                noStaffMessage.style.textAlign = 'center';
                noStaffMessage.style.padding = '40px 20px';
                noStaffMessage.style.color = 'var(--color-text-deemphasized)';
                noStaffMessage.style.fontSize = '1.1rem';
                noStaffMessage.textContent = 'No staff members found for the selected filter.';
                container.appendChild(noStaffMessage);
            }
        }

        function filterStaffList(filterType) {
            // Update active button
            document.querySelectorAll('.filter-toggle-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-filter="${filterType}"]`).classList.add('active');

            // Filter the staff data
            let filteredStaff = allStaffData;

            switch (filterType) {
                case 'all':
                    filteredStaff = allStaffData;
                    break;
                case 'tenured':
                    // Tenured = years 1, 2, 3 (exclude probationary years 4, 5, 6 and legacy 0)
                    filteredStaff = allStaffData.filter(staff =>
                        ![PROB_YEAR_1, PROB_YEAR_2, PROB_YEAR_3, 0, 'Probationary'].includes(staff.year)
                    );
                    break;
                case 'probationary':
                    // Probationary = P1, P2, P3 (years 4, 5, 6) plus legacy format
                    filteredStaff = allStaffData.filter(staff =>
                        [PROB_YEAR_1, PROB_YEAR_2, PROB_YEAR_3, 0, 'Probationary'].includes(staff.year)
                    );
                    break;
                default:
                    filteredStaff = allStaffData;
            }

            // Re-render the list with filtered data
            renderStaffList(filteredStaff);
        }

        // Consolidated recording state management
        const recordingState = {
            audio: { 
                recorder: null, 
                stream: null, 
                isRecording: false,
                timer: null,
                startTime: null,
                sessionCount: 0,
                totalSessionTime: 0
            },
            video: { 
                recorder: null, 
                stream: null, 
                isRecording: false,
                timer: null,
                startTime: null,
                sessionCount: 0,
                totalSessionTime: 0
            }
        };

        // Recording constants
        const RECORDING_MAX_DURATION_MS = 10 * 60 * 1000; // 10 minutes
        const WARNING_TIMES = [30000, 10000]; // 30 seconds, 10 seconds

        // Global AudioContext for reuse across recordings (performance optimization)
        let globalAudioContext = null;
        function getAudioContext() {
            if (!globalAudioContext) {
                globalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return globalAudioContext;
        }

        // Convert Float32Array samples to Int16Array for LameJS MP3 encoder
        function convertFloat32ToInt16(float32Array) {
            const int16Array = new Int16Array(float32Array.length);
            for (let i = 0; i < float32Array.length; i++) {
                // Clamp values to [-1, 1] and convert to 16-bit signed integer
                const clampedValue = Math.max(-1, Math.min(1, float32Array[i]));
                int16Array[i] = Math.round(clampedValue * 32767);
            }
            return int16Array;
        }

        // Recording timer functions
        function startRecordingTimer(type) {
            const state = recordingState[type];
            state.startTime = Date.now();
            state.sessionCount++;
            
            updateTimerDisplay(type);
            
            state.timer = setInterval(() => {
                updateTimerDisplay(type);
                checkRecordingWarnings(type);
            }, 1000);
        }

        function stopRecordingTimer(type) {
            const state = recordingState[type];
            if (state.timer) {
                clearInterval(state.timer);
                state.timer = null;
            }
            
            if (state.startTime) {
                const sessionDuration = Date.now() - state.startTime;
                state.totalSessionTime += sessionDuration;
                state.startTime = null;
            }
            
            hideTimerDisplay(type);
        }

        function updateTimerDisplay(type) {
            const state = recordingState[type];
            if (!state.startTime) return;
            
            const elapsed = Date.now() - state.startTime;
            const remaining = Math.max(0, RECORDING_MAX_DURATION_MS - elapsed);
            const remainingSeconds = Math.ceil(remaining / 1000);
            const minutes = Math.floor(remainingSeconds / 60);
            const seconds = remainingSeconds % 60;
            
            const displayElement = document.getElementById(`${type}TimerDisplay`);
            if (displayElement) {
                const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                const percentage = ((RECORDING_MAX_DURATION_MS - remaining) / RECORDING_MAX_DURATION_MS) * 100;
                
                displayElement.innerHTML = `
                    <div class="recording-timer">
                        <div class="timer-info">
                            🔴 Recording ${state.sessionCount} (${formattedTime} remaining)
                        </div>
                        <div class="timer-progress">
                            <div class="progress-bar" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
                
                // Add warning styling for last 30 seconds
                if (remaining <= 30000) {
                    displayElement.classList.add('timer-warning');
                } else {
                    displayElement.classList.remove('timer-warning');
                }
            }
            
            // Auto-stop when time limit reached
            if (remaining <= 0) {
                autoStopRecording(type);
            }
        }

        function hideTimerDisplay(type) {
            const displayElement = document.getElementById(`${type}TimerDisplay`);
            if (displayElement) {
                displayElement.innerHTML = '';
                displayElement.classList.remove('timer-warning');
            }
        }

        function checkRecordingWarnings(type) {
            const state = recordingState[type];
            if (!state.startTime) return;
            
            const elapsed = Date.now() - state.startTime;
            const remaining = RECORDING_MAX_DURATION_MS - elapsed;
            
            for (const warningTime of WARNING_TIMES) {
                if (remaining <= warningTime && remaining > warningTime - 1000) {
                    const seconds = Math.ceil(warningTime / 1000);
                    showToast(`Recording will stop in ${seconds} seconds`, false, 3000);
                    break;
                }
            }
        }

        function autoStopRecording(type) {
            const state = recordingState[type];
            const config = recordingConfig[type];
            
            if (state.isRecording) {
                // Stop the recording
                state.recorder.stop();
                state.stream.getTracks().forEach(track => track.stop());
                state.isRecording = false;
                
                // Update button
                const btn = document.getElementById(config.buttonId);
                btn.textContent = config.stopText;
                btn.classList.remove('recording');
                
                stopRecordingTimer(type);
                
                // Show auto-stop notification and restart option
                showRecordingStoppedNotification(type);
            }
        }

        function showRecordingStoppedNotification(type) {
            const typeText = type === 'audio' ? 'Audio' : 'Video';
            const totalMinutes = Math.floor(recordingState[type].totalSessionTime / 60000);
            const totalSeconds = Math.floor((recordingState[type].totalSessionTime % 60000) / 1000);
            
            const message = `${typeText} recording stopped (10-minute limit reached). 
                            Session ${recordingState[type].sessionCount} saved. 
                            Total recorded: ${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;
            
            showToast(message, true, 5000);
            
            // Show restart button
            showRestartRecordingOption(type);
        }

        function showRestartRecordingOption(type) {
            const config = recordingConfig[type];
            const btn = document.getElementById(config.buttonId);
            const typeText = type === 'audio' ? 'Audio' : 'Video';
            
            // Temporarily change button to show restart option
            const originalText = btn.textContent;
            btn.textContent = `▶️ Continue ${typeText} Recording`;
            btn.style.backgroundColor = '#4CAF50';
            
            // Reset button styling after 10 seconds
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.backgroundColor = '';
            }, 10000);
        }

        // Session overview functions
        function getSessionSummary(type) {
            const state = recordingState[type];
            const totalMinutes = Math.floor(state.totalSessionTime / 60000);
            const totalSeconds = Math.floor((state.totalSessionTime % 60000) / 1000);
            const formattedTime = `${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;
            
            return {
                sessionCount: state.sessionCount,
                totalTime: formattedTime,
                totalTimeMs: state.totalSessionTime
            };
        }

        function logSessionSummary() {
            const audioSummary = getSessionSummary('audio');
            const videoSummary = getSessionSummary('video');
            
            console.log('Recording Session Summary:', {
                audio: audioSummary,
                video: videoSummary
            });
            
            if (audioSummary.sessionCount > 0 || videoSummary.sessionCount > 0) {
                let message = 'Recording Session Summary:\n';
                if (audioSummary.sessionCount > 0) {
                    message += `Audio: ${audioSummary.sessionCount} recordings, ${audioSummary.totalTime} total\n`;
                }
                if (videoSummary.sessionCount > 0) {
                    message += `Video: ${videoSummary.sessionCount} recordings, ${videoSummary.totalTime} total`;
                }
                showToast(message, true, 8000);
            }
        }

        // Function to reset recording session data (useful when starting a new observation)
        function resetRecordingSessions() {
            for (const type of ['audio', 'video']) {
                const state = recordingState[type];
                
                // Stop any active recordings first
                if (state.isRecording) {
                    try {
                        state.recorder.stop();
                        state.stream.getTracks().forEach(track => track.stop());
                    } catch (e) {
                        console.warn(`Error stopping ${type} recording:`, e);
                    }
                }
                
                // Clear timers
                if (state.timer) {
                    clearInterval(state.timer);
                    state.timer = null;
                }
                
                // Reset state
                state.recorder = null;
                state.stream = null;
                state.isRecording = false;
                state.startTime = null;
                state.sessionCount = 0;
                state.totalSessionTime = 0;
                
                // Reset UI
                const config = recordingConfig[type];
                const btn = document.getElementById(config.buttonId);
                if (btn) {
                    btn.textContent = config.stopText;
                    btn.classList.remove('recording');
                    btn.style.backgroundColor = '';
                }
                
                hideTimerDisplay(type);
            }
            
            console.log('Recording sessions reset');
        }

        // Development helper function for testing (can be removed in production)
        function testRecordingSystem() {
            console.log('Testing 10-minute recording system...');
            
            // Test timer display updates
            console.log('Audio session summary:', getSessionSummary('audio'));
            console.log('Video session summary:', getSessionSummary('video'));
            
            // Test UI elements exist
            const audioBtn = document.getElementById('recordAudioBtn');
            const videoBtn = document.getElementById('recordVideoBtn');
            const audioTimer = document.getElementById('audioTimerDisplay');
            const videoTimer = document.getElementById('videoTimerDisplay');
            
            console.log('UI Elements Check:', {
                audioBtn: !!audioBtn,
                videoBtn: !!videoBtn,
                audioTimer: !!audioTimer,
                videoTimer: !!videoTimer
            });
            
            if (audioBtn && videoBtn && audioTimer && videoTimer) {
                console.log('✅ All recording system components properly initialized');
                return true;
            } else {
                console.error('❌ Missing recording system components');
                return false;
            }
        }

        // Recording configuration
        const recordingConfig = {
            audio: {
                constraints: { audio: true },
                buttonId: 'recordAudioBtn',
                startText: '🛑 Stop Audio',
                stopText: '🎤 Record Audio',
                errorMessage: 'Error accessing microphone: '
            },
            video: {
                constraints: { video: true, audio: true },
                buttonId: 'recordVideoBtn', 
                startText: '🛑 Stop Video',
                stopText: '📹 Record Video',
                errorMessage: 'Error accessing camera: '
            }
        };

        async function toggleRecording(type) {
            const state = recordingState[type];
            const config = recordingConfig[type];
            const btn = document.getElementById(config.buttonId);

            if (!state.isRecording) {
                try {
                    state.stream = await navigator.mediaDevices.getUserMedia(config.constraints);

                    const options = {};
                    if (type === 'audio') {
                        // Use audio/webm as it's the most commonly supported format
                        options.mimeType = 'audio/webm';
                    } else if (type === 'video') {
                        if (MediaRecorder.isTypeSupported('video/mp4')) {
                            options.mimeType = 'video/mp4';
                        } else {
                            console.warn('video/mp4 not supported, falling back to video/webm');
                            options.mimeType = 'video/webm';
                        }
                    }

                    state.recorder = new MediaRecorder(state.stream, options);

                    const chunks = [];
                    state.recorder.ondataavailable = event => chunks.push(event.data);

                    state.recorder.onerror = (event) => {
                        console.error('Recording error:', event);
                        showToast(`Recording failed: ${event.error || 'Unknown error'}. Try shorter recordings.`, false);
                        // Reset recording state
                        state.isRecording = false;
                        btn.textContent = config.stopText;
                        btn.classList.remove('recording');
                        stopRecordingTimer(type);
                    };

                    state.recorder.onstop = () => {
                        const blob = new Blob(chunks, { type: state.recorder.mimeType });
                        if (type === 'audio') {
                            encodeAudioToMp3(blob);
                        } else {
                            uploadRecording(blob, 'video');
                        }
                    };

                    state.recorder.start();
                    state.isRecording = true;
                    btn.textContent = config.startText;
                    btn.classList.add('recording');
                    
                    // Start the recording timer
                    startRecordingTimer(type);

                } catch (error) {
                    showToast(config.errorMessage + error.message, false);
                }
            } else {
                state.recorder.stop();
                state.stream.getTracks().forEach(track => track.stop());
                state.isRecording = false;
                btn.textContent = config.stopText;
                btn.classList.remove('recording');
                
                // Stop the recording timer
                stopRecordingTimer(type);
            }
        }

        // Wrapper functions for backwards compatibility
        async function toggleAudioRecording() {
            await toggleRecording('audio');
        }

        async function toggleVideoRecording() {
            await toggleRecording('video');
        }

        function encodeAudioToMp3(audioBlob, bitrate = 192) {
            console.log('Starting MP3 encoding...', { blobSize: audioBlob.size, bitrate });
            
            // Fallback function if MP3 encoding fails
            function fallbackToWebm() {
                console.warn('MP3 encoding failed, uploading original WebM audio');
                showToast('MP3 conversion failed, saving as WebM format', false);
                uploadRecording(audioBlob, 'audio');
            }
            
            const reader = new FileReader();
            reader.onload = function(event) {
                const arrayBuffer = event.target.result;
                console.log('AudioBlob read as ArrayBuffer:', { size: arrayBuffer.byteLength });
                
                const audioContext = getAudioContext(); // Reuse global AudioContext
                audioContext.decodeAudioData(arrayBuffer, (audioBuffer) => {
                    const numChannels = audioBuffer.numberOfChannels;
                    const duration = audioBuffer.duration;
                    const sampleRate = audioBuffer.sampleRate;
                    const totalSamples = audioBuffer.length;
                    
                    console.log('AudioBuffer decoded:', { 
                        channels: numChannels, 
                        duration: duration + 's',
                        sampleRate,
                        totalSamples
                    });
                    
                    // Validate audio buffer has content
                    if (totalSamples === 0 || duration === 0) {
                        console.error('AudioBuffer is empty');
                        fallbackToWebm();
                        return;
                    }
                    
                    // Lamejs supports mono (1) or stereo (2)
                    const channels = numChannels > 2 ? 2 : numChannels;
                    
                    if (numChannels > 2) {
                        console.warn('Only the first two channels will be encoded to MP3 (stereo).');
                    }

                    try {
                        const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, bitrate);
                        const mp3Data = [];
                        const sampleBlockSize = 1152;
                        let totalProcessedSamples = 0;

                        if (channels === 2) {
                            // Stereo encoding
                            const left = audioBuffer.getChannelData(0);
                            const right = audioBuffer.getChannelData(1);
                            
                            for (let i = 0; i < left.length; i += sampleBlockSize) {
                                const leftChunk = left.subarray(i, i + sampleBlockSize);
                                const rightChunk = right.subarray(i, i + sampleBlockSize);
                                
                                // Convert Float32 to Int16 for LameJS
                                const leftInt16 = convertFloat32ToInt16(leftChunk);
                                const rightInt16 = convertFloat32ToInt16(rightChunk);
                                
                                const mp3buf = mp3encoder.encodeBuffer(leftInt16, rightInt16);
                                if (mp3buf.length > 0) {
                                    mp3Data.push(mp3buf);
                                    totalProcessedSamples += leftChunk.length;
                                }
                            }
                        } else {
                            // Mono encoding or mixdown from stereo
                            let samples;
                            if (numChannels === 2) {
                                // Mix down stereo to mono
                                const left = audioBuffer.getChannelData(0);
                                const right = audioBuffer.getChannelData(1);
                                samples = new Float32Array(left.length);
                                for (let i = 0; i < left.length; i++) {
                                    samples[i] = 0.5 * (left[i] + right[i]);
                                }
                                console.log('Mixed stereo to mono');
                            } else {
                                samples = audioBuffer.getChannelData(0);
                            }
                            
                            for (let i = 0; i < samples.length; i += sampleBlockSize) {
                                const sampleChunk = samples.subarray(i, i + sampleBlockSize);
                                
                                // Convert Float32 to Int16 for LameJS
                                const int16Chunk = convertFloat32ToInt16(sampleChunk);
                                
                                const mp3buf = mp3encoder.encodeBuffer(int16Chunk);
                                if (mp3buf.length > 0) {
                                    mp3Data.push(mp3buf);
                                    totalProcessedSamples += sampleChunk.length;
                                }
                            }
                        }
                        
                        const mp3buf = mp3encoder.flush();
                        if (mp3buf.length > 0) {
                            mp3Data.push(mp3buf);
                        }

                        console.log('MP3 encoding completed:', { 
                            chunks: mp3Data.length, 
                            processedSamples: totalProcessedSamples,
                            expectedSamples: totalSamples
                        });

                        if (mp3Data.length === 0) {
                            console.error('No MP3 data generated');
                            fallbackToWebm();
                            return;
                        }

                        const mp3Blob = new Blob(mp3Data, { type: 'audio/mpeg' });
                        console.log('MP3 Blob created:', { size: mp3Blob.size });
                        
                        if (mp3Blob.size === 0) {
                            console.error('MP3 Blob is empty');
                            fallbackToWebm();
                            return;
                        }
                        
                        uploadRecording(mp3Blob, 'audio');
                        
                    } catch (encodingError) {
                        console.error('MP3 encoding error:', encodingError);
                        fallbackToWebm();
                    }
                    
                }, (decodeError) => {
                    console.error('AudioContext decode error:', decodeError);
                    showToast('Failed to decode audio: ' + decodeError.message, false);
                    fallbackToWebm();
                });
            };
            
            reader.onerror = function(readerError) {
                console.error('FileReader error:', readerError);
                fallbackToWebm();
            };
            
            reader.readAsArrayBuffer(audioBlob);
        }

        function uploadRecording(blob, type) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const sessionNumber = recordingState[type].sessionCount;
            let extension;
            
            if (type === 'audio') {
                // Check blob type to determine if it's MP3 or WebM (fallback)
                if (blob.type === 'audio/mpeg' || blob.type === 'audio/mp3') {
                    extension = 'mp3';
                } else {
                    extension = 'webm'; // WebM fallback
                    console.log('Audio saved as WebM (MP3 encoding failed or not applied)');
                }
            } else if (type === 'video') {
                if (blob.type.includes('mp4')) {
                    extension = 'mp4';
                } else {
                    extension = 'webm';
                }
            } else {
                extension = 'bin'; // fallback for unknown type
            }
            const filename = `${type}-recording-${sessionNumber}-${timestamp}.${extension}`;
            
            console.log('Uploading recording:', { 
                type, 
                extension, 
                blobType: blob.type, 
                size: blob.size, 
                filename 
            });

            // Convert blob to base64
            const reader = new FileReader();
            reader.onload = function() {
                const base64Data = reader.result.split(',')[1];

                google.script.run
                    .withSuccessHandler(function(result) {
                        if (result.success) {
                            showToast(`${type} recording saved successfully!`, true);
                            // Add to global recordings list
                            addGlobalRecording(result.fileUrl, filename, type);
                        } else {
                            showToast(`Error saving ${type} recording: ` + result.error, false);
                        }
                    })
                    .withFailureHandler(function(error) {
                        showToast(`Failed to save ${type} recording: ` + error.message, false);
                    })
                    .uploadGlobalRecording(currentObservationId, base64Data, filename, type);
            };
            reader.readAsDataURL(blob);
        }

        function addGlobalRecording(fileUrl, filename, type) {
            // Placeholder for now
            console.log(`Recording saved: ${type} at ${fileUrl} with name ${filename}`);
        }

        // === Observation State Management Functions ===
        
        /**
         * Clears all observation-related state to prevent cross-contamination between observations
         */
        function clearObservationState() {
            console.log('Clearing all observation state...');
            
            // Clear observation context
            currentObservationId = null;
            clearWorkProductAnswersCache(); // Clear cache when clearing observation
            currentObservedUser = { email: null, name: null };

            // Clear script editor state
            clearScriptEditor();
            
            // Clear Quill editor instances and notes
            clearQuillInstances();
            
            // Clear any UI state
            resetObservationUI();
            
            console.log('Observation state cleared successfully');
        }
        
        /**
         * Clears script editor state and destroys the Quill instance
         */
        function clearScriptEditor() {
            // Clearing script editor state
            
            // CRITICAL: Clean up speech recognition first
            cleanupSpeechRecognition();
            
            // Clear auto-save timer
            if (scriptSaveDebounceTimer) {
                clearTimeout(scriptSaveDebounceTimer);
                scriptSaveDebounceTimer = null;
            }
            
            // Destroy Quill instance if it exists
            if (scriptQuill) {
                try {
                    // Destroying existing script Quill instance
                    
                    // Remove all event listeners
                    scriptQuill.off('text-change');
                    
                    // Get container element before destroying Quill
                    const container = document.getElementById('scriptEditor');
                    
                    // Clear the editor content
                    scriptQuill.setContents([], 'silent');
                    
                    // More thorough destruction of Quill instance
                    if (typeof scriptQuill.destroy === 'function') {
                        scriptQuill.destroy();
                    }
                    
                    // Nullify the JavaScript reference
                    scriptQuill = null;
                    
                    // CRITICAL: Clean up DOM elements completely
                    if (container) {
                        // Cleaning up script editor DOM
                        resetScriptEditorContainer();
                    }
                    
                } catch (error) {
                    console.warn('Error destroying script Quill instance:', error);
                    
                    // Emergency cleanup - force reset container even if Quill destruction failed
                    scriptQuill = null;
                    resetScriptEditorContainer();
                }
            }
            
            // Reset script state variables
            scriptContent = {};
            isScriptDirty = false;
            isSavingScript = false;
            
            // Reset UI state
            updateSaveButtonState();
            
            console.log('Script editor state cleared');
        }
        
        /**
         * Destroys all Quill editor instances and clears notes data
         */
        function clearQuillInstances() {
            console.log('Clearing all Quill instances and notes data...');
            
            // Destroy all existing Quill instances
            if (window.globalQuillInstances) {
                Object.keys(window.globalQuillInstances).forEach(componentId => {
                    const editor = window.globalQuillInstances[componentId];
                    if (editor && typeof editor.off === 'function') {
                        try {
                            // Remove all event listeners
                            editor.off('text-change');
                            // Clear the editor content
                            editor.setContents([], 'silent');
                            
                            // Clear the __quill reference from the DOM element
                            const editorElement = document.getElementById(`notesEditor-${componentId}`);
                            if (editorElement && editorElement.__quill) {
                                delete editorElement.__quill;
                            }
                        } catch (error) {
                            console.warn(`Error destroying Quill instance for ${componentId}:`, error);
                        }
                    }
                });
            }
            
            // Reset global storage objects
            window.globalQuillInstances = {};
            window.globalObservationNotes = {};
            
            console.log('All Quill instances and notes data cleared');
        }
        
        /**
         * Resets observation-related UI elements to default state
         */
        function resetObservationUI() {
            console.log('Resetting observation UI...');
            
            // Close script editor modal if open
            const scriptModal = document.getElementById('scriptEditorModal');
            if (scriptModal) {
                scriptModal.style.display = 'none';
            }
            
            // Reset any expanded evidence sections
            const evidenceSections = document.querySelectorAll('[id^="evidence-content-"]');
            evidenceSections.forEach(section => {
                section.style.display = 'none';
            });
            
            // Reset chevron indicators
            const chevrons = document.querySelectorAll('[id^="evidence-chevron-"]');
            chevrons.forEach(chevron => {
                chevron.textContent = '▶';
            });
            
            // Clear any temporary UI states from sessionStorage related to evidence
            try {
                const storagePrefix = 'evidenceState_';
                Object.keys(sessionStorage).forEach(key => {
                    if (key.startsWith(storagePrefix)) {
                        sessionStorage.removeItem(key);
                    }
                });
            } catch (error) {
                console.warn('Error clearing evidence state from sessionStorage:', error);
            }
            
            console.log('Observation UI reset completed');
        }
        
        /**
         * Removes all orphaned Quill elements globally from the document
         * This prevents toolbar duplication issues when recreating editors
         */
        function removeOrphanedQuillElements() {
            let removedCount = 0;
            
            try {
                // Find all Quill toolbars globally (not just in script editor)
                const orphanedToolbars = document.querySelectorAll('.ql-toolbar');
                orphanedToolbars.forEach(toolbar => {
                    console.log('Removing orphaned Quill toolbar:', toolbar);
                    toolbar.remove();
                    removedCount++;
                });
                
                // Find all Quill containers globally
                const orphanedContainers = document.querySelectorAll('.ql-container');
                orphanedContainers.forEach(container => {
                    // Only remove if not inside our target script editor
                    const scriptEditor = document.getElementById('scriptEditor');
                    if (!scriptEditor || !scriptEditor.contains(container)) {
                        console.log('Removing orphaned Quill container:', container);
                        container.remove();
                        removedCount++;
                    }
                });
                
                // Find all Quill editors globally
                const orphanedEditors = document.querySelectorAll('.ql-editor');
                orphanedEditors.forEach(editor => {
                    // Only remove if not inside our target script editor
                    const scriptEditor = document.getElementById('scriptEditor');
                    if (!scriptEditor || !scriptEditor.contains(editor)) {
                        console.log('Removing orphaned Quill editor:', editor);
                        editor.remove();
                        removedCount++;
                    }
                });
                
                if (removedCount > 0) {
                    console.log(`Removed ${removedCount} orphaned Quill elements globally`);
                }
                
                return removedCount;
                
            } catch (error) {
                console.error('Error removing orphaned Quill elements:', error);
                return 0;
            }
        }

        /**
         * Completely resets the script editor container to pristine state
         * This utility function ensures no leftover Quill DOM elements remain
         */
        function resetScriptEditorContainer() {
            // Resetting script editor container
            
            // Clean up speech recognition first
            cleanupSpeechRecognition();
            
            // FIRST: Remove any orphaned Quill elements globally (fixes toolbar duplication)
            const orphanedCount = removeOrphanedQuillElements();
            if (orphanedCount > 0) {
                console.log(`Fixed toolbar duplication: removed ${orphanedCount} orphaned elements`);
            }
            
            const container = document.getElementById('scriptEditor');
            if (!container) {
                console.warn('Script editor container not found');
                return false;
            }
            
            try {
                // Count existing toolbars for diagnostics
                const existingToolbars = document.querySelectorAll('#scriptEditor .ql-toolbar').length;
                if (existingToolbars > 0) {
                    console.log(`Found ${existingToolbars} existing toolbars in container before cleanup`);
                }
                
                // Remove all Quill-generated content
                container.innerHTML = '';
                
                // Reset all CSS classes (Quill adds classes like 'ql-container')
                container.className = '';
                
                // Remove any Quill-specific data attributes
                container.removeAttribute('data-quill');
                container.removeAttribute('contenteditable');
                
                // Remove any Quill-added inline styles
                container.removeAttribute('style');
                
                // Clear any remaining Quill references
                if (container.__quill) {
                    delete container.__quill;
                }
                
                // Final verification: ensure no toolbars remain
                const remainingToolbars = document.querySelectorAll('#scriptEditor .ql-toolbar').length;
                if (remainingToolbars > 0) {
                    console.warn(`Warning: ${remainingToolbars} toolbars still remain after cleanup`);
                }
                
                console.log('Script editor container reset successfully');
                return true;
                
            } catch (error) {
                console.error('Error resetting script editor container:', error);
                
                // Emergency fallback - try to at least clear innerHTML
                try {
                    container.innerHTML = '';
                } catch (e) {
                    console.error('Emergency container reset also failed:', e);
                }
                return false;
            }
        }
        
        /**
         * Diagnostic function to detect and fix broken observation state
         */
        function diagnoseAndRecoverObservationState() {
            console.log('Running observation state diagnostics...');
            
            const issues = [];
            const fixes = [];
            
            // Check for orphaned currentObservationId without proper context
            if (currentObservationId && !currentObservedUser.email) {
                issues.push('currentObservationId set but no observed user context');
                currentObservationId = null;
                fixes.push('Cleared orphaned observation ID');
            }
            
            // Check for broken script editor state
            if (scriptQuill && !currentObservationId) {
                issues.push('Script editor exists but no observation context');
                clearScriptEditor();
                fixes.push('Cleared orphaned script editor');
            }
            
            // Check for leftover Quill DOM elements without corresponding JS instance
            const scriptContainer = document.getElementById('scriptEditor');
            if (scriptContainer && !scriptQuill) {
                const hasQuillElements = scriptContainer.querySelector('.ql-toolbar, .ql-container, .ql-editor');
                if (hasQuillElements) {
                    issues.push('Found orphaned Quill DOM elements in script editor');
                    resetScriptEditorContainer();
                    fixes.push('Cleaned up orphaned script editor DOM elements');
                }
            }
            
            // Check for broken Quill instances
            if (window.globalQuillInstances) {
                Object.keys(window.globalQuillInstances).forEach(componentId => {
                    const editor = window.globalQuillInstances[componentId];
                    if (!editor || !editor.root || !editor.root.parentNode) {
                        issues.push(`Broken Quill instance for component ${componentId}`);
                        delete window.globalQuillInstances[componentId];
                        fixes.push(`Removed broken Quill instance for ${componentId}`);
                    }
                });
            }
            
            // Check for notes data without observation context
            if (window.globalObservationNotes && !currentObservationId) {
                const notesCount = Object.keys(window.globalObservationNotes).length;
                if (notesCount > 0) {
                    issues.push(`${notesCount} orphaned notes entries without observation context`);
                    window.globalObservationNotes = {};
                    fixes.push('Cleared orphaned notes data');
                }
            }
            
            // Check for mismatched DOM and JS state
            const scriptModal = document.getElementById('scriptEditorModal');
            if (scriptModal && scriptModal.style.display !== 'none' && !scriptQuill) {
                issues.push('Script modal open but no Quill instance');
                scriptModal.style.display = 'none';
                fixes.push('Closed orphaned script modal');
            }
            
            if (issues.length > 0) {
                console.warn('Observation state issues detected:', issues);
                console.log('Applied fixes:', fixes);
                showToast(`Recovered from ${issues.length} state issue(s)`, true);
            } else {
                console.log('Observation state is healthy');
            }
            
            return { issues, fixes };
        }
        
        /**
         * Emergency state reset function for when things go really wrong
         */
        function emergencyStateReset() {
            console.warn('EMERGENCY: Performing complete state reset...');
            
            try {
                // Force clear all state
                currentObservationId = null;
                clearWorkProductAnswersCache(); // Clear cache when clearing observation
                currentObservedUser = { email: null, name: null };

                // Destroy script editor
                if (scriptQuill) {
                    try {
                        scriptQuill.off('text-change');
                        scriptQuill = null;
                    } catch (e) {
                        console.warn('Error destroying script Quill:', e);
                        scriptQuill = null;
                    }
                }
                
                // Force clean script editor container
                resetScriptEditorContainer();
                
                scriptContent = {};
                isScriptDirty = false;
                isSavingScript = false;
                
                if (scriptSaveDebounceTimer) {
                    clearTimeout(scriptSaveDebounceTimer);
                    scriptSaveDebounceTimer = null;
                }
                
                // Destroy all Quill instances
                if (window.globalQuillInstances) {
                    Object.keys(window.globalQuillInstances).forEach(componentId => {
                        try {
                            const editor = window.globalQuillInstances[componentId];
                            if (editor && editor.off) {
                                editor.off('text-change');
                            }
                            const element = document.getElementById(`notesEditor-${componentId}`);
                            if (element && element.__quill) {
                                delete element.__quill;
                            }
                        } catch (e) {
                            console.warn(`Error cleaning up Quill for ${componentId}:`, e);
                        }
                    });
                }
                window.globalQuillInstances = {};
                window.globalObservationNotes = {};
                
                // Reset UI
                const scriptModal = document.getElementById('scriptEditorModal');
                if (scriptModal) {
                    scriptModal.style.display = 'none';
                }
                
                console.log('Emergency state reset completed');
                showToast('Emergency state reset completed', true);
                
            } catch (error) {
                console.error('Error during emergency reset:', error);
                showToast('Emergency reset encountered errors - please refresh page', false);
            }
        }
        
        // === Periodic State Monitoring ===
        
        let stateMonitorInterval = null;
        
        /**
         * Starts periodic monitoring of observation state
         */
        function startStateMonitoring() {
            if (stateMonitorInterval) {
                clearInterval(stateMonitorInterval);
            }
            
            stateMonitorInterval = setInterval(() => {
                try {
                    diagnoseAndRecoverObservationState();
                } catch (error) {
                    console.error('Error during state monitoring:', error);
                }
            }, 30000); // Check every 30 seconds
            
            console.log('State monitoring started');
        }
        
        /**
         * Stops periodic state monitoring
         */
        function stopStateMonitoring() {
            if (stateMonitorInterval) {
                clearInterval(stateMonitorInterval);
                stateMonitorInterval = null;
                console.log('State monitoring stopped');
            }
        }
        
        // Start monitoring when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Clean up old session storage backups on page load
            cleanupOldSessionBackups();
            
            setTimeout(() => {
                startStateMonitoring();
            }, 5000); // Start monitoring after 5 seconds
        });
        
        // === Debug and Testing Functions ===
        
        /**
         * Debug function to check script editor state and DOM
         * Can be called from browser console: window.debugScriptEditor()
         */
        window.debugScriptEditor = function() {
            const container = document.getElementById('scriptEditor');
            const result = {
                hasContainer: !!container,
                hasScriptQuill: !!scriptQuill,
                containerHTML: container ? container.innerHTML : null,
                containerClasses: container ? Array.from(container.classList) : null,
                quillToolbars: document.querySelectorAll('#scriptEditor .ql-toolbar').length,
                quillContainers: document.querySelectorAll('#scriptEditor .ql-container').length,
                quillEditors: document.querySelectorAll('#scriptEditor .ql-editor').length,
                containerAttributes: container ? Array.from(container.attributes).map(attr => `${attr.name}="${attr.value}"`) : null
            };
            
            console.log('Script Editor Debug Info:', result);
            
            if (result.quillToolbars > 1) {
                console.warn(`🚨 TOOLBAR DUPLICATION DETECTED: ${result.quillToolbars} toolbars found!`);
            } else if (result.quillToolbars === 1) {
                console.log('✅ Script editor state is clean (1 toolbar)');
            } else {
                console.log('ℹ️ No toolbars found (editor not initialized)');
            }
            
            return result;
        };
        
        /**
         * Test function to simulate opening/closing script editor multiple times
         * Can be called from browser console: window.testScriptEditorCleanup()
         */
        window.testScriptEditorCleanup = function(iterations = 3) {
            // Development testing function - remove in production
            
            if (!currentObservationId) {
                console.error('Cannot test: No active observation. Please load an observation first.');
                return;
            }
            
            for (let i = 0; i < iterations; i++) {
                console.log(`\n--- Test iteration ${i + 1} ---`);
                
                // Open script editor
                openScriptEditor();
                window.debugScriptEditor();
                
                // Close script editor
                closeScriptEditor();
                
                // Force clear to simulate observation switching
                clearScriptEditor();
                window.debugScriptEditor();
            }
            
            console.log('\n🏁 Test completed. Check results above.');
        };

        // === Work Product Answer Functions ===

        function refreshWorkProductAnswers(forceRefresh = false) {
            if (!currentObservationId) {
                showToast('No observation selected');
                return;
            }

            // Check if this is a work product observation
            if (!window.currentObservationType || window.currentObservationType !== 'Work Product') {
                return;
            }

            // Check client-side cache first (unless force refresh is requested)
            if (!forceRefresh) {
                const cachedAnswers = workProductAnswersCache.get(currentObservationId);
                if (cachedAnswers) {
                    console.log('Using cached work product answers for observation:', currentObservationId);
                    displayWorkProductAnswers(cachedAnswers);
                    return;
                }
            } else {
                // Clear specific cache entry for force refresh
                workProductAnswersCache.delete(currentObservationId);
                console.log('Force refresh requested - cleared cache for observation:', currentObservationId);
            }

            showLoading('Loading staff responses...');
            google.script.run
                .withSuccessHandler(function(result) {
                    // Cache the result if successful
                    if (result.success) {
                        workProductAnswersCache.set(currentObservationId, result);
                    }
                    displayWorkProductAnswers(result);
                })
                .withFailureHandler(function(error) {
                    hideLoading();
                    console.error('Failed to load answers:', error);
                    showToast('Failed to load staff responses');
                })
                .getWorkProductAnswersForClient(currentObservationId);
        }

        function displayWorkProductAnswers(result) {
            hideLoading();
            const container = document.getElementById('workProductAnswersDisplay');
            if (!container) return;

            if (!result.success) {
                container.innerHTML = '<p style="color: #dc2626;">Error loading answers: ' + result.error + '</p>';
                return;
            }

            if (!result.answers || result.answers.length === 0) {
                container.innerHTML = '<p style="color: #6b7280; font-style: italic;">No staff responses yet.</p>';
                return;
            }

            // Load questions to match with answers
            google.script.run
                .withSuccessHandler(function(questionsResult) {
                    if (questionsResult.success) {
                        displayAnswersWithQuestions(result.answers, questionsResult.questions);
                    }
                })
                .getWorkProductQuestionsForClient();
        }

        function displayAnswersWithQuestions(answers, questions) {
            const container = document.getElementById('workProductAnswersDisplay');
            if (!container) return;

            let html = '';
            questions.forEach(question => {
                const answer = answers.find(a => a.questionId === question.questionId);
                const answerText = answer ? answer.answerText : 'No response yet';

                html += `
                    <div style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 4px; border-left: 3px solid #10b981;">
                        <strong style="color: #374151;">${question.questionText}</strong>
                        <div style="margin-top: 5px; color: #6b7280; white-space: pre-wrap;">${answerText}</div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Show/hide work product answers section based on observation type
        function toggleWorkProductAnswersSection(show) {
            const section = document.getElementById('workProductAnswersSection');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            }
        }

        // === Script Editor Mode Switching Functions ===

        // Global state for script editor mode
        let scriptEditorMode = 'view'; // 'view' or 'edit'
        let cachedStaffResponses = null; // Cache staff responses for mode switching

        function switchToViewMode() {
            console.log('Switching to View-Only mode');
            scriptEditorMode = 'view';

            // Update button states
            document.getElementById('viewModeBtn').classList.add('active');
            document.getElementById('editModeBtn').classList.remove('active');

            // Hide Quill editor and component tagging toolbar
            document.getElementById('scriptEditor').style.display = 'none';
            document.querySelector('.script-tagging-toolbar').style.display = 'none';

            // Show staff responses in view-only format
            showStaffResponsesViewOnly();
        }

        function switchToEditMode() {
            console.log('Switching to Edit & Tag mode');
            scriptEditorMode = 'edit';

            // Update button states
            document.getElementById('editModeBtn').classList.add('active');
            document.getElementById('viewModeBtn').classList.remove('active');

            // Show Quill editor and component tagging toolbar
            document.getElementById('scriptEditor').style.display = 'block';
            document.querySelector('.script-tagging-toolbar').style.display = 'block';

            // Hide view-only display and populate Quill editor
            hideStaffResponsesViewOnly();
            populateQuillWithStaffResponses();
        }

        function showStaffResponsesViewOnly() {
            // Create or show the view-only container
            let viewContainer = document.getElementById('staffResponsesViewOnly');
            if (!viewContainer) {
                viewContainer = document.createElement('div');
                viewContainer.id = 'staffResponsesViewOnly';
                viewContainer.className = 'staff-responses-view-only';

                // Insert before the script editor
                const scriptEditor = document.getElementById('scriptEditor');
                scriptEditor.parentNode.insertBefore(viewContainer, scriptEditor);
            }

            viewContainer.style.display = 'block';

            // Load and display staff responses if we have them
            if (cachedStaffResponses) {
                displayStaffResponsesInViewMode(cachedStaffResponses);
            } else {
                // Load staff responses
                loadStaffResponsesForView();
            }
        }

        function hideStaffResponsesViewOnly() {
            const viewContainer = document.getElementById('staffResponsesViewOnly');
            if (viewContainer) {
                viewContainer.style.display = 'none';
            }
        }

        function loadStaffResponsesForView() {
            if (!currentObservationId || !window.currentObservationType || window.currentObservationType !== 'Work Product') {
                return;
            }

            const viewContainer = document.getElementById('staffResponsesViewOnly');
            if (viewContainer) {
                viewContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #6b7280;">Loading staff responses...</div>';
            }

            google.script.run
                .withSuccessHandler(function(result) {
                    if (result.success) {
                        cachedStaffResponses = result;
                        displayStaffResponsesInViewMode(result);
                    } else {
                        if (viewContainer) {
                            viewContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #dc2626;">Error loading responses: ' + result.error + '</div>';
                        }
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Failed to load staff responses:', error);
                    if (viewContainer) {
                        viewContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #dc2626;">Failed to load staff responses</div>';
                    }
                })
                .getWorkProductAnswersForClient(currentObservationId);
        }

        function displayStaffResponsesInViewMode(result) {
            const viewContainer = document.getElementById('staffResponsesViewOnly');
            if (!viewContainer) return;

            if (!result.answers || result.answers.length === 0) {
                viewContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #6b7280;">No staff responses available yet.</div>';
                return;
            }

            // Load questions for display
            google.script.run
                .withSuccessHandler(function(questionsResult) {
                    if (questionsResult.success) {
                        const questionsMap = {};
                        questionsResult.questions.forEach(q => {
                            questionsMap[q.questionId] = q.questionText;
                        });

                        let html = '';
                        result.answers.forEach(answer => {
                            const questionText = questionsMap[answer.questionId] || `Question ${answer.questionId}`;
                            html += `
                                <div class="response-item">
                                    <div class="response-question">${questionText}</div>
                                    <div class="response-answer">${answer.answerText || '<em style="color: #9ca3af;">No response provided</em>'}</div>
                                </div>
                            `;
                        });

                        viewContainer.innerHTML = html;
                    } else {
                        viewContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #dc2626;">Error loading questions for display</div>';
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Failed to load questions:', error);
                    // Fallback: show answers without question text
                    let html = '';
                    result.answers.forEach(answer => {
                        html += `
                            <div class="response-item">
                                <div class="response-question">Question ${answer.questionId}</div>
                                <div class="response-answer">${answer.answerText || '<em style="color: #9ca3af;">No response provided</em>'}</div>
                            </div>
                        `;
                    });
                    viewContainer.innerHTML = html;
                })
                .getWorkProductQuestionsForClient();
        }

        function populateQuillWithStaffResponses() {
            if (!scriptQuill || !cachedStaffResponses) {
                return;
            }

            // Load questions and populate Quill editor
            google.script.run
                .withSuccessHandler(function(questionsResult) {
                    if (questionsResult.success && cachedStaffResponses.answers) {
                        const questionsMap = {};
                        questionsResult.questions.forEach(q => {
                            questionsMap[q.questionId] = q.questionText;
                        });

                        let content = '';
                        cachedStaffResponses.answers.forEach((answer, index) => {
                            const questionText = questionsMap[answer.questionId] || `Question ${answer.questionId}`;
                            content += `${questionText}\n\n${answer.answerText || 'No response provided'}\n\n---\n\n`;
                        });

                        scriptQuill.setText(content);
                        console.log('Populated Quill editor with staff responses');
                    }
                })
                .getWorkProductQuestionsForClient();
        }

        function initializeScriptEditorMode() {
            // Show mode toggle only for work product observations
            if (window.currentObservationType === 'Work Product') {
                document.getElementById('scriptEditorModeToggle').style.display = 'block';
                // Start in view mode by default
                switchToViewMode();
            } else {
                document.getElementById('scriptEditorModeToggle').style.display = 'none';
                // For non-work product observations, ensure normal mode
                scriptEditorMode = 'edit';
                document.getElementById('scriptEditor').style.display = 'block';
                document.querySelector('.script-tagging-toolbar').style.display = 'block';
                hideStaffResponsesViewOnly();
            }
        }

        // Stop monitoring when page unloads
        window.addEventListener('beforeunload', function(e) {
            stopStateMonitoring();
            
            // CRITICAL: Auto-save script content if STT is running or content is dirty
            if ((sttIsRecording || isScriptDirty) && scriptQuill && currentObservationId) {
                // Attempt synchronous save - this is limited but better than losing data
                try {
                    const content = scriptQuill.getContents();
                    const htmlContent = scriptQuill.root.innerHTML;
                    
                    // Store in sessionStorage as backup
                    sessionStorage.setItem(`script_backup_${currentObservationId}`, JSON.stringify({
                        content: content,
                        html: htmlContent,
                        timestamp: Date.now()
                    }));
                    
                    console.log('Script content backed up to sessionStorage before unload');
                } catch (error) {
                    console.error('Error backing up script content:', error);
                }
                
                // Show browser warning
                e.preventDefault();
                e.returnValue = 'Speech-to-text is running and script content may not be saved. Are you sure you want to leave?';
                return 'Speech-to-text is running and script content may not be saved. Are you sure you want to leave?';
            }
            
            // CRITICAL: Clean up speech recognition on page unload
            cleanupSpeechRecognition();
        });

        // === Script Editor Functions ===
        const SCRIPT_EDITOR_CONSTANTS = <?!= JSON.stringify(scriptEditorSettings) ?>;
        let scriptQuill = null;
        let scriptContent = {};
        const SILENT_SAVE_DEBOUNCE_MS = 5000;
        const SILENT_SAVE_DEBOUNCE_HIGH_ACTIVITY_MS = 8000; // Extended debounce during high activity
        let isScriptDirty = false;
        let scriptSaveDebounceTimer;
        let isSavingScript = false;

        // Function to detect high activity periods
        function isHighActivityPeriod() {
            // High activity if:
            // 1. Multiple PDF pollers active
            const activePollerCount = Object.keys(activePollers).length;
            // 2. Recent API requests (more than 3 in last 10 seconds)
            const recentRequestCount = Array.from(pendingRequests.values()).filter(
                timestamp => Date.now() - timestamp < 10000
            ).length;

            return activePollerCount >= 2 || recentRequestCount >= 3;
        }

        // Get appropriate debounce time based on current activity
        function getAutoSaveDebounceTime() {
            if (!OPTIMIZATION_FLAGS.enableAdaptiveAutoSave) {
                // Fall back to original logic if adaptive auto-save is disabled
                return (typeof sttIsRecording !== 'undefined' && sttIsRecording)
                    ? SILENT_SAVE_DEBOUNCE_MS * 2
                    : SILENT_SAVE_DEBOUNCE_MS;
            }

            if (typeof sttIsRecording !== 'undefined' && sttIsRecording) {
                return SILENT_SAVE_DEBOUNCE_MS * 2.4; // 12 seconds during speech recording (was 10s)
            } else if (isHighActivityPeriod()) {
                return SILENT_SAVE_DEBOUNCE_HIGH_ACTIVITY_MS; // 8 seconds during high activity
            } else {
                return SILENT_SAVE_DEBOUNCE_MS; // 5 seconds normal
            }
        }

        function updateSaveButtonState() {
            const saveBtn = document.getElementById('saveScriptBtn');
            if (!saveBtn) return;

            if (isScriptDirty) {
                saveBtn.textContent = 'Save all changes';
                saveBtn.disabled = false;
                saveBtn.classList.remove('btn-secondary');
                saveBtn.classList.add('btn-primary');
            } else {
                saveBtn.textContent = 'Saved!';
                saveBtn.disabled = true;
                saveBtn.classList.remove('btn-primary');
                saveBtn.classList.add('btn-secondary');
            }
        }

        // Encapsulated speech recognition state
        let sttRecognitionInstance = null;
        let sttIsRecording = false;
        let sttTimeoutId = null;
        let sttAutoRestartTimeoutId = null;
        let sttIsInitializing = false; // Prevent race conditions during initialization
        let sttLastTranscriptIndex = 0; // Track processed results to avoid duplicates
        let sttFinalTextEndPosition = null; // Track where final text ends for final-only transcription
        // For long observation sessions (20-40 minutes), we need continuous recognition
        // Chrome has built-in timeouts (~60s), so we auto-restart to maintain continuity
        const STT_AUTO_RESTART_INTERVAL_MS = 50000; // 50 second auto-restart to prevent browser timeout
        const STT_SESSION_CLEANUP_INTERVAL_MS = 5 * 60 * 1000; // Clean up old session storage every 5 minutes

        // Cleanup function to ensure proper speech recognition cleanup
        function cleanupSpeechRecognition() {
            if (sttRecognitionInstance) {
                try {
                    sttRecognitionInstance.stop();
                } catch (e) {
                    console.warn('Error stopping speech recognition:', e);
                }
                sttRecognitionInstance = null;
            }
            sttIsRecording = false;
            sttIsInitializing = false;
            sttLastTranscriptIndex = 0;
            
            // Reset final text position
            sttFinalTextEndPosition = null;
            
            // Clear timeout if it exists
            if (sttTimeoutId) {
                clearTimeout(sttTimeoutId);
                sttTimeoutId = null;
            }
            
            // Clear auto-restart interval
            if (sttAutoRestartTimeoutId) {
                clearInterval(sttAutoRestartTimeoutId);
                sttAutoRestartTimeoutId = null;
            }
            
            // Reset button state if it exists
            const sttButton = document.querySelector('.ql-stt-button');
            if (sttButton) {
                sttButton.classList.remove('recording', 'processing');
                sttButton.innerHTML = '🎤';
                sttButton.title = 'Start speech-to-text recording';
                sttButton.setAttribute('aria-label', 'Start speech-to-text recording');
            }
        }

        function handleSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                // Enhanced browser detection for better user guidance
                const userAgent = navigator.userAgent;
                let browserInfo = 'Please use Chrome, Edge, or Safari';
                let additionalInfo = '';

                if (userAgent.includes('Firefox')) {
                    browserInfo = 'Firefox does not support speech recognition';
                    additionalInfo = ' - please switch to Chrome, Edge, or Safari for this feature';
                } else if (userAgent.includes('Chrome') && !userAgent.includes('Edge')) {
                    additionalInfo = ' - ensure you\'re using the latest version of Chrome';
                } else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
                    additionalInfo = ' - ensure Safari has microphone permissions enabled';
                } else if (userAgent.includes('Edge')) {
                    additionalInfo = ' - ensure you\'re using the latest version of Edge';
                } else {
                    additionalInfo = ' - this browser is not supported for speech recognition';
                }

                showToast(`Speech recognition is not supported. ${browserInfo}${additionalInfo}.`, false);
                
                // Disable the button visually if speech recognition is not supported
                const sttButton = document.querySelector('.ql-stt-button');
                if (sttButton) {
                    sttButton.disabled = true;
                    sttButton.innerHTML = '🎤❌';
                    sttButton.title = `Speech recognition not supported in this browser. ${browserInfo}.`;
                    sttButton.style.opacity = '0.5';
                }
                return;
            }

            const sttButton = document.querySelector('.ql-stt-button');
            if (!sttButton) {
                console.error('Speech-to-text button not found in the DOM.');
                return;
            }

            // Prevent race conditions during initialization
            if (sttIsInitializing) {
                // Prevent race conditions - ignoring duplicate initialization
                return;
            }

            // If already recording, stop the recording
            if (sttIsRecording) {
                cleanupSpeechRecognition();
                return;
            }

            // Set initializing state to prevent race conditions
            sttIsInitializing = true;
            sttButton.classList.add('processing');
            sttButton.innerHTML = '⏳';
            sttButton.title = 'Initializing speech recognition...';

            // Check microphone permissions before starting
            if (navigator.permissions) {
                navigator.permissions.query({ name: 'microphone' }).then(permissionStatus => {
                    // Double-check state in case user clicked button multiple times during async operation
                    if (sttIsRecording || !sttIsInitializing) {
                        sttIsInitializing = false;
                        return; // Already recording or canceled, ignore this request
                    }
                    
                    if (permissionStatus.state === 'denied') {
                        showToast('Microphone permission denied. Please allow microphone access and try again.', false);
                        sttIsInitializing = false;
                        sttButton.classList.remove('processing');
                        sttButton.innerHTML = '🎤';
                        sttButton.title = 'Start speech-to-text recording';
                        return;
                    }
                    startSpeechRecognition(sttButton);
                }).catch(() => {
                    // Fallback if permissions API not available
                    if (sttIsInitializing && !sttIsRecording) {
                        startSpeechRecognition(sttButton);
                    }
                });
            } else {
                // Fallback for browsers without permissions API
                if (sttIsInitializing && !sttIsRecording) {
                    startSpeechRecognition(sttButton);
                }
            }
        }

        // Final-only transcription helper function

        function insertFinalTranscript(finalText) {
            if (!scriptQuill) return;
            
            try {
                // Determine where to insert final text (accumulative transcription)
                let insertPosition;
                if (sttFinalTextEndPosition !== null) {
                    // Continue appending after previous final text
                    insertPosition = sttFinalTextEndPosition;
                } else {
                    // First final text - use current cursor position
                    const currentRange = scriptQuill.getSelection(true);
                    insertPosition = currentRange ? currentRange.index : 0;
                }
                
                // Insert final text with space
                const textToInsert = finalText + ' ';
                scriptQuill.insertText(insertPosition, textToInsert, 'user');
                
                // Update the final text end position for next insertion
                sttFinalTextEndPosition = insertPosition + textToInsert.length;
                
                // Position cursor after the new final text
                scriptQuill.setSelection(sttFinalTextEndPosition, 0, 'user');
                
            } catch (e) {
                console.warn('Error inserting final transcript:', e);
            }
        }

        function startSpeechRecognition(sttButton) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            try {
                sttRecognitionInstance = new SpeechRecognition();
                sttRecognitionInstance.lang = navigator.language || 'en-US';
                sttRecognitionInstance.continuous = true; // Continuous for long observation sessions (20-40 min)
                sttRecognitionInstance.interimResults = false; // Final results only for reliable transcription
                sttRecognitionInstance.maxAlternatives = 1;
                
                // Reset transcript index for new session
                sttLastTranscriptIndex = 0;
                
                // Initialize final text position for live captions
                const currentRange = scriptQuill.getSelection(true);
                sttFinalTextEndPosition = currentRange ? currentRange.index : 0;

                sttRecognitionInstance.addEventListener('start', () => {
                    sttIsRecording = true;
                    sttIsInitializing = false;
                    sttButton.classList.remove('processing');
                    sttButton.classList.add('recording');
                    sttButton.innerHTML = '🔴';
                    sttButton.title = 'Recording - Click to stop';
                    sttButton.setAttribute('aria-label', 'Stop speech-to-text recording');
                    showToast('Speech recognition started - speak now', true);
                });
            } catch (error) {
                console.error('Failed to create speech recognition instance:', error);
                showToast('Failed to initialize speech recognition. Please try again.', false);
                sttIsInitializing = false;
                sttButton.classList.remove('processing');
                sttButton.innerHTML = '🎤';
                sttButton.title = 'Start speech-to-text recording';
                return;
            }

            sttRecognitionInstance.addEventListener('result', e => {
                if (e.results && e.results.length > 0) {
                    // CRITICAL: Check if scriptQuill still exists before processing any results
                    if (!scriptQuill || typeof scriptQuill.getSelection !== 'function') {
                        console.warn('Script editor no longer available, stopping speech recognition');
                        cleanupSpeechRecognition();
                        return;
                    }
                    
                    // Process final results only - much simpler!
                    let hasNewFinalResults = false;
                    
                    // Process all NEW final results (avoid duplicates)
                    for (let i = sttLastTranscriptIndex; i < e.results.length; i++) {
                        if (e.results[i].length > 0 && e.results[i].isFinal) {
                            const transcript = e.results[i][0].transcript.trim();
                            if (transcript.length > 0) {
                                insertFinalTranscript(transcript);
                                hasNewFinalResults = true;
                            }
                        }
                    }
                    
                    // Update button if we processed new results
                    if (hasNewFinalResults) {
                        sttButton.innerHTML = '🔴';
                        sttButton.title = 'Recording - Click to stop';
                    }
                    
                    // Track processed results to avoid duplicates
                    sttLastTranscriptIndex = e.results.length;
                }
            });

            sttRecognitionInstance.addEventListener('error', (event) => {
                console.error('Speech recognition error:', event.error, event);
                const errorMessages = {
                    'not-allowed': 'Microphone access denied. Please allow microphone permissions and refresh the page.',
                    'no-speech': 'No speech detected. Speech recognition will continue automatically.',
                    'audio-capture': 'No microphone found. Please check your microphone connection and try again.',
                    'network': 'Network error occurred. Check your internet connection. Speech recognition will attempt to restart.',
                    'service-not-allowed': 'Speech service not allowed. This may be due to browser security settings.',
                    'bad-grammar': 'Speech recognition failed. This is usually temporary - please continue speaking.',
                    'language-not-supported': 'Your browser language is not supported. Try speaking in English or change your browser language.',
                    'aborted': 'Speech recognition was stopped.'
                };
                
                const message = errorMessages[event.error] || `Speech recognition error: ${event.error}. Please try again.`;
                
                // Don't show toast for common recoverable errors in continuous mode
                const recoverableErrors = ['no-speech', 'bad-grammar'];
                if (!recoverableErrors.includes(event.error)) {
                    showToast(message, false);
                }
                
                // Auto-retry for network errors in continuous mode
                if (event.error === 'network' && sttIsRecording) {
                    console.log('Network error detected, attempting auto-recovery in 2 seconds...');
                    setTimeout(() => {
                        if (sttIsRecording && !sttRecognitionInstance) {
                            // Attempting auto-recovery after network error
                            handleSpeechRecognition();
                        }
                    }, 2000);
                } else {
                    cleanupSpeechRecognition();
                }
            });

            sttRecognitionInstance.addEventListener('end', () => {
                // No interim text to clean up - final results only!
                
                // For continuous long sessions, auto-restart unless manually stopped
                if (sttIsRecording) {
                    // Update button to show restarting
                    const sttButton = document.querySelector('.ql-stt-button');
                    if (sttButton) {
                        sttButton.innerHTML = '⟳';
                        sttButton.title = 'Restarting recognition...';
                    }
                    
                    // Small delay before restart to prevent rapid cycling
                    setTimeout(() => {
                        if (sttIsRecording && scriptQuill) {
                            try {
                                sttRecognitionInstance.start();
                            } catch (error) {
                                console.error('Failed to restart speech recognition:', error);
                                showToast('Speech recognition stopped. Click microphone to restart.', false);
                                cleanupSpeechRecognition();
                            }
                        }
                    }, 500);
                } else {
                    cleanupSpeechRecognition();
                }
            });

            // Set up auto-restart interval for long sessions (20-40 minutes)
            // This prevents browser-level timeouts while maintaining continuous recording
            sttAutoRestartTimeoutId = setInterval(() => {
                if (sttIsRecording && sttRecognitionInstance) {
                    // Performing scheduled restart to maintain continuity
                    try {
                        sttRecognitionInstance.stop(); // This will trigger 'end' event and auto-restart
                    } catch (error) {
                        console.warn('Error during scheduled STT restart:', error);
                    }
                }
            }, STT_AUTO_RESTART_INTERVAL_MS);

            try {
                sttRecognitionInstance.start();
                // Processing indicator is already set, will be updated on start event
            } catch (error) {
                console.error('Failed to start speech recognition:', error);
                showToast('Failed to start speech recognition. Please try again.', false);
                cleanupSpeechRecognition();
            }
        }

        function createQuillEditorWithSpeech() {
            const toolbarOptions = [...SCRIPT_EDITOR_CONSTANTS.TOOLBAR_OPTIONS, ['stt-button']];
            
            // Initialize Quill editor using constants
            scriptQuill = new Quill('#scriptEditor', {
                theme: 'snow',
                modules: {
                    toolbar: {
                        container: toolbarOptions,
                        handlers: {
                            'stt-button': handleSpeechRecognition
                        }
                    }
                }
            });

            // Add our custom button with accessibility attributes
            const sttButton = document.querySelector('.ql-stt-button');
            if (sttButton) {
                sttButton.innerHTML = '🎤';
                sttButton.setAttribute('title', 'Start speech-to-text recording');
                sttButton.setAttribute('aria-label', 'Speech-to-text recording');
                sttButton.setAttribute('role', 'button');
                sttButton.setAttribute('tabindex', '0');
            }

            console.log('Script Quill editor initialized successfully');
            
            // DIAGNOSTIC: Check toolbar count after initialization
            const postInitToolbars = document.querySelectorAll('.ql-toolbar').length;
            const scriptEditorToolbars = document.querySelectorAll('#scriptEditor .ql-toolbar').length;
            console.log(`Post-initialization toolbar count: ${postInitToolbars} total, ${scriptEditorToolbars} in script editor`);
            
            if (postInitToolbars > 1) {
                console.warn(`WARNING: Found ${postInitToolbars} toolbars after initialization - toolbar duplication detected!`);
                // Log details of each toolbar for debugging
                document.querySelectorAll('.ql-toolbar').forEach((toolbar, index) => {
                    console.warn(`Toolbar ${index + 1}:`, {
                        parent: toolbar.parentElement?.id || 'unknown',
                        classes: Array.from(toolbar.classList),
                        location: toolbar.parentElement?.outerHTML?.substring(0, 100) || 'unknown'
                    });
                });
            } else if (postInitToolbars === 1) {
                console.log('✓ Toolbar duplication fix successful: exactly 1 toolbar found');
            } else {
                console.error('ERROR: No toolbars found after initialization - this should not happen');
            }

            // Load existing content for current observation
            loadScriptContent();

            // Auto-save on content change (STT-aware)
            scriptQuill.on('text-change', function(delta, oldDelta, source) {
                if (source === 'user') {
                    isScriptDirty = true;
                    updateSaveButtonState();
                    clearTimeout(scriptSaveDebounceTimer);
                    
                    // Use adaptive debounce time based on activity level
                    const debounceTime = getAutoSaveDebounceTime();

                    scriptSaveDebounceTimer = setTimeout(() => {
                        // No interim text to worry about - just save!
                        silentSaveScriptContent();
                    }, debounceTime);
                }
            });
        }

        function initializeQuillWithSpeech() {
            try {
                console.log('Creating new Quill instance on clean container...');
                createQuillEditorWithSpeech();

            } catch (error) {
                console.error('Error initializing script editor:', error);

                // If initialization fails, try emergency reset and retry ONCE
                console.log('Attempting emergency reset and retry...');
                resetScriptEditorContainer();

                try {
                    createQuillEditorWithSpeech();

                } catch (retryError) {
                    console.error('Script editor initialization failed even after reset:', retryError);
                    showToast('Failed to initialize script editor: ' + retryError.message, false);
                    modal.style.display = 'none';
                    return;
                }
            }
        }

        function openScriptEditor() {
            // Validate observation context before opening
            if (!currentObservationId) {
                showToast('Cannot open script editor: No active observation', false);
                console.error('Cannot open script editor: No active observation context');
                return;
            }
            
            if (!currentObservedUser.email) {
                showToast('Cannot open script editor: Invalid observation context', false);
                console.error('Cannot open script editor: Invalid observed user context');
                return;
            }
            
            // Opening script editor
            
            // Run diagnostics to check for any state issues
            diagnoseAndRecoverObservationState();
            
            const modal = document.getElementById('scriptEditorModal');
            const loadingOverlay = document.getElementById('scriptEditorLoadingOverlay');

            modal.style.display = 'flex';
            loadingOverlay.style.display = 'flex'; // Show loading overlay immediately
            document.body.style.overflow = 'hidden'; // Prevent background scrolling

            // Disable existing Quill editor if it exists to prevent interaction during loading
            if (scriptQuill) {
                scriptQuill.disable();
            }

            // Clear any pending auto-save timer when opening editor
            clearTimeout(scriptSaveDebounceTimer);

            if (!scriptQuill) {
                // DEFENSIVE CHECK: Ensure container is clean before creating new Quill instance
                const container = document.getElementById('scriptEditor');
                if (!container) {
                    console.error('Script editor container not found');
                    showToast('Script editor container not found', false);
                    modal.style.display = 'none';
                    return;
                }
                
                // ENHANCED CLEANUP: Check for toolbar duplication issues before initialization
                
                // 1. Check for leftover Quill elements in container
                const hasQuillElements = container.querySelector('.ql-toolbar, .ql-container, .ql-editor');
                if (hasQuillElements) {
                    console.warn('Found leftover Quill elements in container, cleaning up...');
                    resetScriptEditorContainer();
                }
                
                // 2. Check for orphaned toolbars globally (main fix for toolbar duplication)
                const globalToolbars = document.querySelectorAll('.ql-toolbar').length;
                if (globalToolbars > 0) {
                    console.warn(`Found ${globalToolbars} orphaned toolbars globally, performing global cleanup...`);
                    removeOrphanedQuillElements();
                }
                
                // 3. Check for any Quill-related classes or attributes on container
                if (container.classList.length > 0 || container.hasAttribute('data-quill')) {
                    console.warn('Container has Quill-related attributes, resetting...');
                    resetScriptEditorContainer();
                }
                
                // 4. Final diagnostic before initialization
                const finalToolbarCount = document.querySelectorAll('.ql-toolbar').length;
                if (finalToolbarCount > 0) {
                    console.warn(`Warning: Still found ${finalToolbarCount} toolbars after cleanup - this may cause duplication`);
                } else {
                    console.log('Pre-initialization cleanup complete - no existing toolbars found');
                }

                initializeQuillWithSpeech();

            } else {
                // Ensure existing editor has the right content for current observation
                // Reusing existing script editor
                loadScriptContent();
            }
            
            isScriptDirty = false;
            updateSaveButtonState();
        }

        async function closeScriptEditor() {
            // CRITICAL: Auto-save content before closing if STT is running or content is dirty
            if (sttIsRecording || isScriptDirty) {
                // Auto-saving content before closing
                
                try {
                    // Force save the current content
                    const success = await saveScriptContent();
                    if (success) {
                        showToast('Script content auto-saved before closing', true);
                    } else {
                        console.warn('Auto-save failed, prompting user');
                        if (!confirm('Failed to auto-save changes. Close anyway and lose changes?')) {
                            return;
                        }
                    }
                } catch (error) {
                    console.error('Error during auto-save:', error);
                    if (!confirm('Error saving changes. Close anyway and lose changes?')) {
                        return;
                    }
                }
            }
            
            // Clear any pending auto-save timer
            clearTimeout(scriptSaveDebounceTimer);
            
            // CRITICAL: Clean up speech recognition when closing editor
            cleanupSpeechRecognition();
            
            const modal = document.getElementById('scriptEditorModal');
            modal.style.display = 'none';
            document.body.style.overflow = ''; // Restore background scrolling

            // Hide loading overlay if still visible
            hideScriptEditorLoading();
            
            isScriptDirty = false;
        }

        function manualSaveScriptContent() {
            if (!scriptQuill || !currentObservationId || isSavingScript) return;

            showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SAVING, false);
            saveScriptContent().then(success => {
                if (success) {
                    showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SAVED, true);
                }
            }).catch(error => {
                // Log errors, but don't show a toast as saveScriptContent already does.
                console.warn("Could not manually save script:", error.message);
            });
        }

        function silentSaveScriptContent() {
            if (!scriptQuill || !currentObservationId || !isScriptDirty || isSavingScript) return;
            // Auto-saving script content
            saveScriptContent().catch(error => {
                // Silent saves should not bother the user, so just log.
                console.warn("Could not silently save script:", error.message);
            });
        }

        function saveScriptContent() {
            return new Promise((resolve, reject) => {
                if (isSavingScript) {
                    reject(new Error('A save operation is already in progress.'));
                    return;
                }
                if (!scriptQuill || !currentObservationId) {
                    reject(new Error('Quill editor or observation ID is not available.'));
                    return;
                }

                isSavingScript = true;
                const content = scriptQuill.getContents();
                scriptContent = content; // Keep local copy

                google.script.run
                    .withSuccessHandler(function(result) {
                        isSavingScript = false;
                        if (result.success) {
                            isScriptDirty = false;
                            updateSaveButtonState();
                            resolve(true);
                        } else {
                            console.error('Failed to save script content:', result.error);
                            showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.ERROR_SAVING + result.error, false);
                            reject(new Error(result.error || 'Unknown save error'));
                        }
                    })
                    .withFailureHandler(function(error) {
                        isSavingScript = false;
                        console.error('Error saving script content:', error);
                        showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SERVER_ERROR + error.message, false);
                        reject(error);
                    })
                    .updateObservationScript(currentObservationId, content);
            });
        }

        function hideScriptEditorLoading() {
            const loadingOverlay = document.getElementById('scriptEditorLoadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
            
            // Re-enable the Quill editor
            if (scriptQuill) {
                scriptQuill.enable();
            }
            
            // FINAL DIAGNOSTIC: Verify toolbar duplication fix after editor is fully loaded
            const finalToolbarCount = document.querySelectorAll('.ql-toolbar').length;
            const sttButtonCount = document.querySelectorAll('.ql-stt-button').length;
            
            console.log(`Script editor fully loaded - Final toolbar check: ${finalToolbarCount} toolbars, ${sttButtonCount} STT buttons`);
            
            if (finalToolbarCount > 1) {
                console.error(`TOOLBAR DUPLICATION DETECTED: ${finalToolbarCount} toolbars found after editor load`);
            } else if (sttButtonCount === 0) {
                console.warn('Warning: STT button not found - microphone functionality may be missing from toolbar');
            } else if (sttButtonCount > 1) {
                console.warn(`Warning: Multiple STT buttons found (${sttButtonCount}) - duplicate functionality detected`);
            } else {
                console.log('✓ Script editor loaded successfully with single toolbar and STT button');
            }
        }

        // Clean up old session storage backups to prevent memory bloat
        function cleanupOldSessionBackups() {
            // Check if sessionStorage is available
            if (typeof Storage === 'undefined' || !window.sessionStorage) {
                console.warn('SessionStorage is not available in this browser');
                return;
            }

            try {
                const keysToRemove = [];
                const maxAge = 30 * 60 * 1000; // 30 minutes
                const now = Date.now();
                
                // Get all keys first to avoid issues with changing storage during iteration
                const allKeys = [];
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i);
                    if (key && key.startsWith('script_backup_')) {
                        allKeys.push(key);
                    }
                }
                
                // Process each backup key
                allKeys.forEach(key => {
                    try {
                        const item = sessionStorage.getItem(key);
                        if (!item) {
                            keysToRemove.push(key);
                            return;
                        }

                        const data = JSON.parse(item);
                        if (!data || !data.timestamp || typeof data.timestamp !== 'number') {
                            // Invalid backup data structure, mark for removal
                            keysToRemove.push(key);
                        } else if ((now - data.timestamp) > maxAge) {
                            // Expired backup, mark for removal
                            keysToRemove.push(key);
                        }
                    } catch (parseError) {
                        // JSON parse failed, invalid backup data - mark for removal
                        console.warn(`Invalid session backup data for key ${key}:`, parseError.message);
                        keysToRemove.push(key);
                    }
                });
                
                // Remove old/invalid backups safely
                keysToRemove.forEach(key => {
                    try {
                        sessionStorage.removeItem(key);
                    } catch (removeError) {
                        console.warn(`Failed to remove session backup key ${key}:`, removeError.message);
                    }
                });
                
                if (keysToRemove.length > 0) {
                    // Cleaned up session storage backups
                }
                
                // Check for storage quota issues
                try {
                    const testKey = 'storage_test_' + Date.now();
                    sessionStorage.setItem(testKey, 'test');
                    sessionStorage.removeItem(testKey);
                } catch (quotaError) {
                    if (quotaError.name === 'QuotaExceededError' || quotaError.name === 'QUOTA_EXCEEDED_ERR') {
                        console.warn('SessionStorage quota exceeded - consider clearing more data');
                    }
                }
                
            } catch (error) {
                console.warn('Error during session storage cleanup:', error.message);
                
                // If there's a critical error, try a more aggressive cleanup
                if (error.name === 'SecurityError' || error.name === 'InvalidAccessError') {
                    console.warn('SessionStorage access denied - backup features may not work');
                } else {
                    // Try to clear at least some backup keys if possible
                    try {
                        const keys = Object.keys(sessionStorage).filter(key => key.startsWith('script_backup_'));
                        if (keys.length > 10) { // If too many backups, clear half
                            keys.slice(0, Math.floor(keys.length / 2)).forEach(key => {
                                try { sessionStorage.removeItem(key); } catch (e) { /* ignore */ }
                            });
                            // Emergency cleanup performed
                        }
                    } catch (emergencyError) {
                        // Complete failure - disable backup features
                        console.error('Complete session storage failure - backup features disabled');
                    }
                }
            }
        }

        function loadScriptContent() {
            if (!currentObservationId) {
                console.warn('Cannot load script content: currentObservationId is not set');
                hideScriptEditorLoading(); // Hide loading on error
                return;
            }
            
            // Validate that we have a valid observation context
            if (!currentObservedUser.email) {
                console.warn('Cannot load script content: No observed user context');
                hideScriptEditorLoading(); // Hide loading on error
                return;
            }
            
            // Loading script content
            
            google.script.run
                .withSuccessHandler(function(content) {
                    // Double-check that we still have the same observation ID (prevent race conditions)
                    if (!scriptQuill || !currentObservationId) {
                        console.warn('Script editor or observation context lost during load');
                        return;
                    }
                    
                    console.log('Script content loaded successfully', { 
                        observationId: currentObservationId,
                        hasContent: !!(content && typeof content === 'object' && Object.keys(content).length > 0)
                    });
                    
                    // Clean up old session storage backups
                    cleanupOldSessionBackups();
                    
                    // Check for sessionStorage backup first (in case of unexpected closure)
                    const backupKey = `script_backup_${currentObservationId}`;
                    const backup = sessionStorage.getItem(backupKey);
                    let useBackup = false;
                    
                    if (backup) {
                        try {
                            const backupData = JSON.parse(backup);
                            const backupAge = Date.now() - backupData.timestamp;
                            const maxAge = 30 * 60 * 1000; // 30 minutes
                            
                            if (backupAge < maxAge) {
                                const useBackupResponse = confirm(
                                    'Found unsaved script content from a previous session. ' +
                                    'This might contain speech-to-text data that wasn\'t saved. ' +
                                    'Do you want to restore it?'
                                );
                                
                                if (useBackupResponse) {
                                    scriptQuill.setContents(backupData.content, 'silent');
                                    scriptContent = backupData.content;
                                    isScriptDirty = true; // Mark as dirty so user can save
                                    useBackup = true;
                                    showToast('Restored unsaved script content from previous session', true);
                                    // Restored from backup
                                }
                            }
                            
                            // Clean up old backup
                            sessionStorage.removeItem(backupKey);
                            
                        } catch (error) {
                            console.error('Error processing sessionStorage backup:', error);
                            sessionStorage.removeItem(backupKey);
                        }
                    }
                    
                    if (!useBackup) {
                        if (content && typeof content === 'object' && Object.keys(content).length > 0) {
                            scriptQuill.setContents(content, 'silent');
                            scriptContent = content;
                        } else {
                            // Load empty content for new observations
                            scriptQuill.setContents([], 'silent');
                            scriptContent = {};
                        }
                    }
                    isScriptDirty = false;
                    updateSaveButtonState();

                    // Load component tags and restore highlighting AFTER content is loaded
                    // Small delay to ensure Quill content is fully processed
                    setTimeout(() => {
                        loadComponentTags();
                        // Initialize script editor mode system AFTER everything is loaded
                        initializeScriptEditorMode();
                    }, 50);
                })
                .withFailureHandler(function(error) {
                    console.error('Error loading script content:', error);
                    showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.LOAD_ERROR + error.message, false);
                    
                    // Clear script editor on error to prevent showing wrong content
                    if (scriptQuill) {
                        scriptQuill.setContents([], 'silent');
                        scriptContent = {};
                        isScriptDirty = false;
                        updateSaveButtonState();
                    }
                    
                    // Hide loading overlay and re-enable editor even on error
                    hideScriptEditorLoading();
                })
                .getObservationScript(currentObservationId);
        }


        // === Component Tagging System ===
        let componentTags = {};
        const TAG_COLORS = {
            '1a:': '#e3f2fd', '1b:': '#f3e5f5', '1c:': '#e8f5e8', '1d:': '#fff3e0',
            '1e:': '#fce4ec', '1f:': '#e0f2f1', '2a:': '#e1f5fe', '2b:': '#f1f8e9',
            '2c:': '#fef7e0', '2d:': '#ede7f6', '2e:': '#fcf2ff', '3a:': '#e8eaf6',
            '3b:': '#f9fbe7', '3c:': '#fff8e1', '3d:': '#ffebee', '4a:': '#e0f7fa',
            '4b:': '#f0f4c3', '4c:': '#ffe0b2', '4d:': '#d1c4e9', '4e:': '#ffcdd2',
            '4f:': '#b2dfdb'
        };

        function populateComponentSelector() {
            const selector = document.getElementById('componentSelector');
            if (!selector) {
                console.warn('Component selector element not found');
                return;
            }
            
            // Check if rubric data is available (using the same source as the main rubric)
            if (window.rubricData && window.rubricData.domains && window.rubricData.domains.length > 0) {
                // Data is available, populate the selector
                selector.innerHTML = '<option value="">Select Component to Tag</option>';
                
                let hasComponents = false;
                window.rubricData.domains.forEach(domain => {
                    if (domain.components && domain.components.length > 0) {
                        domain.components.forEach(component => {
                            // Administrators see all components, Peer Evaluators see only assigned components
                            const shouldShowComponent = (userContext.role === 'Administrator') || component.isAssigned;
                            if (shouldShowComponent) {
                                const option = document.createElement('option');
                                option.value = component.componentId;
                                option.textContent = `${domain.name}: ${component.title}`;
                                selector.appendChild(option);
                                hasComponents = true;
                            }
                        });
                    }
                });
                
                if (!hasComponents) {
                    selector.innerHTML = '<option value="">No components available</option>';
                    console.warn('Rubric data exists but contains no components');
                }
            } else {
                // Rubric data not available - this should not happen if called after rubric is loaded
                selector.innerHTML = '<option value="">Rubric data not loaded</option>';
                console.warn('Component selector called but rubric data not available:', {
                    hasWindow: typeof window !== 'undefined',
                    hasRubricData: !!window.rubricData,
                    hasDomains: window.rubricData && !!window.rubricData.domains,
                    domainsLength: window.rubricData && window.rubricData.domains ? window.rubricData.domains.length : 'N/A'
                });
            }
        }

        function tagSelectedText() {
            if (!scriptQuill) {
                showToast('Script editor not initialized', false);
                return;
            }
            
            const range = scriptQuill.getSelection();
            if (!range || range.length === 0) {
                showToast('Please select text to tag', false);
                return;
            }
            
            const componentId = document.getElementById('componentSelector').value;
            if (!componentId) {
                showToast('Please select a component', false);
                return;
            }
            
            // Get the selected text
            const selectedText = scriptQuill.getText(range.index, range.length);
            if (!selectedText.trim()) {
                showToast('Selected text is empty', false);
                return;
            }
            
            // Apply visual formatting to tagged text
            const tagColor = TAG_COLORS[componentId] || '#e3f2fd';
            scriptQuill.formatText(range.index, range.length, 'background', tagColor);
            scriptQuill.formatText(range.index, range.length, 'color', '#1565c0');
            
            // Store tag information
            const tagData = {
                componentId: componentId,
                start: range.index,
                length: range.length,
                text: selectedText.trim(),
                timestamp: new Date().toISOString(),
                color: tagColor
            };
            
            if (!componentTags[componentId]) {
                componentTags[componentId] = [];
            }
            componentTags[componentId].push(tagData);
            
            // Update status
            document.getElementById('tagStatus').textContent = 
                `Tagged "${selectedText.substring(0, 30)}${selectedText.length > 30 ? '...' : ''}" to ${componentId}`;
            
            // Save tags
            saveComponentTags();
            
            showToast('Text tagged successfully', true);
        }

        function pushTaggedToNotes() {
            const allTags = Object.keys(componentTags);
            if (allTags.length === 0) {
                showToast('No tagged evidence to push.', false);
                return;
            }

            let pushedCount = 0;
            allTags.forEach(componentId => {
                const tags = componentTags[componentId];
                if (tags && tags.length > 0) {
                    let notesEditor = window.globalQuillInstances && window.globalQuillInstances[componentId];
                    if (!notesEditor) {
                        const evidenceSectionId = `evidence-${componentId}`;
                        const evidenceSection = document.getElementById(evidenceSectionId);
                        if (evidenceSection) {
                            toggleEvidenceSection(evidenceSectionId);
                            const attemptPush = (retries = 8) => { // Increased retries
                                if (retries <= 0) {
                                    console.warn(`Could not initialize notes editor for ${componentId} after multiple attempts.`);
                                    showToast(`Could not push to ${componentId} notes - editor initialization failed`, false);
                                    return;
                                }
                                
                                // Try to force initialization if editor doesn't exist
                                if (!window.globalQuillInstances[componentId]) {
                                    console.log(`Attempting to force initialize editor for ${componentId}, retries left: ${retries}`);
                                    window.initializeQuillEditor(componentId);
                                }
                                
                                notesEditor = window.globalQuillInstances && window.globalQuillInstances[componentId];
                                if (notesEditor) {
                                    completePushToNotes(componentId, tags, notesEditor);
                                } else {
                                    setTimeout(() => attemptPush(retries - 1), 300); // Increased delay
                                }
                            };
                            attemptPush();
                        } else {
                            console.warn(`Evidence section not found for ${componentId}.`);
                            showToast(`Could not find notes section for ${componentId}`, false);
                        }
                    } else {
                        completePushToNotes(componentId, tags, notesEditor);
                    }
                    pushedCount++;
                }
            });

            if (pushedCount > 0) {
                showToast(`Pushed all tagged evidence to their respective notes sections.`, true);
                document.getElementById('tagStatus').textContent = `Pushed all tagged evidence to notes.`;
            } else {
                showToast('No tagged evidence to push.', false);
            }
        }
        
        function completePushToNotes(componentId, tags, notesEditor) {
            // Combine all tagged text for this component
            const taggedContent = tags.map(tag => tag.text).join('\n\n');
            
            // Get current notes content
            const currentContent = notesEditor.root.innerHTML;
            const separator = currentContent && currentContent !== '<p><br></p>' ? '\n\n' : '';
            const scriptHeader = '<p><strong>From Script:</strong></p>';
            const newContent = currentContent + separator + scriptHeader + '<p>' + taggedContent.replace(/\n/g, '</p><p>') + '</p>';
            
            // Update notes editor
            notesEditor.root.innerHTML = newContent;
            
            // Trigger save
            setTimeout(() => {
                const event = new Event('input', { bubbles: true });
                notesEditor.root.dispatchEvent(event);
            }, 100);
            
            document.getElementById('tagStatus').textContent = 
                `Pushed ${tags.length} tagged item(s) to ${componentId} notes`;
            
            showToast(`Tagged content added to ${componentId} notes`, true);
        }

        function clearComponentTags() {
            const componentId = document.getElementById('componentSelector').value;
            if (!componentId) {
                // Clear all tags
                if (confirm('Clear all component tags from the script?')) {
                    componentTags = {};
                    // Remove all formatting - this is a simplified approach
                    if (scriptQuill) {
                        const length = scriptQuill.getLength();
                        scriptQuill.removeFormat(0, length);
                    }
                    saveComponentTags();
                    document.getElementById('tagStatus').textContent = 'All tags cleared';
                    showToast('All tags cleared', true);
                }
            } else {
                // Clear tags for specific component
                if (componentTags[componentId] && componentTags[componentId].length > 0) {
                    if (confirm(`Clear all tags for component ${componentId}?`)) {
                        delete componentTags[componentId];
                        saveComponentTags();
                        document.getElementById('tagStatus').textContent = `Tags cleared for ${componentId}`;
                        showToast(`Tags cleared for ${componentId}`, true);
                    }
                }
            }
        }

        function saveComponentTags() {
            if (!currentObservationId) return;
            
            google.script.run
                .withSuccessHandler(function(result) {
                    if (result.success) {
                        console.log('Component tags saved successfully');
                    } else {
                        console.error('Failed to save component tags:', result.error);
                        showToast('Failed to save tags: ' + result.error, false);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Error saving component tags:', error);
                    showToast('Error saving tags: ' + error.message, false);
                })
                .saveComponentTags(currentObservationId, componentTags);
        }

        function loadComponentTags() {
            if (!currentObservationId) return;
            
            google.script.run
                .withSuccessHandler(function(tags) {
                    if (tags) {
                        componentTags = tags;
                        // Restore visual formatting for tagged text
                        restoreVisualHighlighting();
                        console.log('Component tags loaded:', componentTags);
                    }

                    // Hide loading overlay now that content and highlights are fully loaded
                    hideScriptEditorLoading();
                })
                .withFailureHandler(function(error) {
                    console.error('Error loading component tags:', error);

                    // Hide loading overlay even if tag loading fails
                    hideScriptEditorLoading();
                })
                .getComponentTags(currentObservationId);
        }

        function restoreVisualHighlighting() {
            if (!scriptQuill || !componentTags) {
                // Cannot restore highlighting - missing dependencies
                return;
            }

            // Ensure Quill is ready and has content
            if (!scriptQuill.getLength || scriptQuill.getLength() <= 1) {
                console.log('Script editor has no content, skipping highlight restoration');
                return;
            }

            console.log('Restoring visual highlighting for tagged components...');
            const documentLength = scriptQuill.getLength() - 1; // Exclude final newline
            let restoredCount = 0;
            
            // Iterate through all component tags and restore their visual formatting
            Object.keys(componentTags).forEach(componentId => {
                const tags = componentTags[componentId];
                if (tags && Array.isArray(tags)) {
                    tags.forEach((tag, tagIndex) => {
                        if (tag.start !== undefined && tag.length !== undefined) {
                            // Validate tag position against document length
                            if (tag.start < 0 || tag.start >= documentLength || 
                                tag.start + tag.length > documentLength) {
                                console.warn(`Skipping invalid tag position for ${componentId}[${tagIndex}]: start=${tag.start}, length=${tag.length}, docLength=${documentLength}`);
                                return;
                            }
                            
                            const tagColor = tag.color || TAG_COLORS[componentId] || '#e3f2fd';
                            try {
                                // Apply the background color and text color formatting
                                scriptQuill.formatText(tag.start, tag.length, 'background', tagColor);
                                scriptQuill.formatText(tag.start, tag.length, 'color', '#1565c0');
                                restoredCount++;
                                console.log(`Restored highlighting for ${componentId}[${tagIndex}] at position ${tag.start}-${tag.start + tag.length}`);
                            } catch (error) {
                                console.warn(`Failed to restore highlighting for ${componentId}[${tagIndex}] at position ${tag.start}:`, error);
                            }
                        } else {
                            console.warn(`Invalid tag data for ${componentId}[${tagIndex}]:`, tag);
                        }
                    });
                }
            });
            
            console.log(`Visual highlighting restoration completed: ${restoredCount} tags restored`);
        }

        // Extend the openScriptEditor function to initialize component selector
        const originalOpenScriptEditor = openScriptEditor;
        openScriptEditor = function() {
            originalOpenScriptEditor();
            // Populate component selector immediately (no race condition)
            populateComponentSelector();
            // loadComponentTags() will be called after content loads to prevent race condition
        };
    </script>

    <!-- Loading Overlay -->
    <div class="loading" id="loading">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">Loading...</div>
        </div>
    </div>

    <!-- Script Editor Modal -->
    <div class="script-editor-modal" id="scriptEditorModal" style="display: none;">
        <div class="script-editor-container">
            <!-- Loading overlay -->
            <div class="script-editor-loading-overlay" id="scriptEditorLoadingOverlay" style="display: none;">
                <div class="script-editor-loading-spinner"></div>
                <div class="script-editor-loading-text">Loading script content...</div>
            </div>
            
            <div class="script-editor-header">
                <h2>Observation Script Editor</h2>

                <!-- Mode Toggle Buttons -->
                <div class="script-editor-mode-toggle" id="scriptEditorModeToggle" style="display: none;">
                    <button id="viewModeBtn" class="mode-toggle-btn active" onclick="switchToViewMode()">
                        📖 View Staff Responses
                    </button>
                    <button id="editModeBtn" class="mode-toggle-btn" onclick="switchToEditMode()">
                        ✏️ Edit & Tag Content
                    </button>
                </div>

                <div class="script-editor-controls">
                    <button id="saveScriptBtn" class="btn-secondary" onclick="manualSaveScriptContent()" disabled>Saved!</button>
                    <button class="btn-secondary" onclick="closeScriptEditor()">Close</button>
                </div>
            </div>
            
            <!-- Component Tagging Toolbar -->
            <div class="script-tagging-toolbar">
                <div class="tagging-controls">
                    <select id="componentSelector" class="component-selector">
                        <option value="">Select Component to Tag</option>
                    </select>
                    <button class="btn-tag" onclick="tagSelectedText()">🏷️ Tag Selection</button>
                    <button class="btn-push" onclick="pushTaggedToNotes()">➡️ Push Tagged to Notes</button>
                    <button class="btn-clear-tags" onclick="clearComponentTags()">🗑️ Clear Tags</button>
                </div>
                <div class="tag-status" id="tagStatus">
                    Select text and choose a component to create tags
                </div>
            </div>
            
            <div class="script-editor-content">
                <div id="scriptEditor"></div>
            </div>
        </div>
    </div>
</body>
</html>