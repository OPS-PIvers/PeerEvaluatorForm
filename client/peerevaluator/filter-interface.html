<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><?= userContext.role ?> - Select Rubric View</title>
    
    <!-- Content Security Policy - Allow framing from same origin and Google domains -->
    <meta http-equiv="Content-Security-Policy" content="frame-ancestors 'self' https://*.google.com;">
    
    <!-- Quill.js for rich text editing -->
    <link href="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.js"></script>
    <style>
:root {
    --color-white: white;
    --color-text-default: #333;
    --color-bg-body: #f5f5f5;

    /* Greens for toggle button and assignments */
    --color-green-base: #10b981;
    --color-green-dark: #059669;
    --color-green-darker: #047857;
    --color-green-light-bg: #f0fdf4;

    /* Ambers for toggle button (assigned mode) and active filters */
    --color-amber-base: #f59e0b;
    --color-amber-dark: #d97706;
    --color-amber-darker: #b45309;
    --color-amber-light-bg: #fef3c7;
    --color-amber-text-dark: #92400e;

    /* Blues for filter status and select focus */
    --color-blue-base: #3b82f6;
    --color-blue-dark: #2563eb;
    --color-blue-light-bg: #dbeafe;
    --color-blue-text-dark: #1e40af;
    --color-blue-focus-shadow: rgba(59, 130, 246, 0.1);

    /* Grays for various UI elements */
    --color-gray-text: #4a5568;
    --color-gray-text-light: #374151;
    --color-gray-border-light: #d1d5db;
    --color-gray-border-medium: #e2e8f0;
    --color-gray-bg-light: #f8fafc;
    --color-gray-bg-medium: #6b7280;
    --color-gray-bg-dark: #4b5563;
    --color-gray-component-not-assigned-border: #e5e7eb;
    --color-gray-assignment-indicator-not-assigned-bg: #e5e7eb;
    --color-text-deemphasized: #718096;

    /* Reds for destructive actions */
    --color-red-base: #dc2626;
    --color-red-dark: #b91c1c;
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg-body);
            padding: 20px;
            line-height: 1.6;
            color: var(--color-text-default);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--color-white);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header {
            background: linear-gradient(135deg, #4a5568, #2d3748);
            color: var(--color-white);
            padding: 40px 30px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 101;
            border-radius: 12px 12px 0 0;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .content {
            padding: 40px 30px;
        }

        /* Dashboard-specific styles */
        .quick-actions { margin-bottom: 40px; }
        .section-title {
            color: var(--color-gray-text);
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .actions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        .action-card {
            background: var(--color-white);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        .action-card:hover {
            border-color: var(--color-blue-base);
            background: var(--color-gray-bg-light);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        .action-icon { font-size: 2.5rem; margin-bottom: 15px; display: block; }
        .action-title { font-weight: 600; color: var(--color-gray-text-light); font-size: 1.1rem; margin-bottom: 8px; }
        .action-desc { color: var(--color-text-deemphasized); font-size: 0.95rem; }

        /* Filter controls */
        .custom-filters, .observation-selector {
            background: var(--color-gray-bg-light);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 12px;
            padding: 30px;
            display: none;
        }
        .filter-row { display: flex; gap: 15px; margin-bottom: 20px; align-items: center; flex-wrap: wrap; }
        .filter-select {
            padding: 12px 15px;
            border: 1px solid var(--color-gray-border-light);
            border-radius: 8px;
            font-size: 1rem;
            background: var(--color-white);
            transition: all 0.3s ease;
            flex: 1;
            min-width: 200px;
        }
        .filter-select:focus {
            outline: none;
            border-color: var(--color-blue-base);
            box-shadow: 0 0 0 3px var(--color-blue-focus-shadow);
        }
        .filter-btn {
            background: var(--color-blue-base);
            color: var(--color-white);
            border: 2px solid var(--color-blue-base);
            cursor: pointer;
            font-weight: 600;
            min-width: 140px;
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        .filter-btn:hover:not(:disabled) { background: #2c5aa0; border-color: #2c5aa0; }
        .filter-btn:disabled { background: #cbd5e0; border-color: #cbd5e0; cursor: not-allowed; }
        .btn-secondary { 
            background: var(--color-gray-bg-medium); 
            border: 2px solid var(--color-gray-bg-medium);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .btn-secondary:hover { 
            background: var(--color-gray-bg-dark); 
            border-color: var(--color-gray-bg-dark);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(75, 85, 99, 0.2);
        }
        
        .btn-primary {
            background: var(--color-blue-base);
            border: 2px solid var(--color-blue-base);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary:hover {
            background: var(--color-blue-dark);
            border-color: var(--color-blue-dark);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
        }

        /* Loading Overlay */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .loading-content {
            background: var(--color-white);
            color: var(--color-blue-text-dark);
            border: 2px solid var(--color-blue-base);
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            min-width: 300px;
        }
        .loading-spinner { 
            display: inline-block; 
            width: 40px; 
            height: 40px; 
            border: 4px solid rgba(59, 130, 246, 0.3); 
            border-radius: 50%; 
            border-top-color: var(--color-blue-base); 
            animation: spin 1s ease-in-out infinite; 
            margin-bottom: 15px; 
        }
        .loading-text {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--color-gray-text-light);
        }
        
        /* Error states */
        .error { text-align: center; padding: 40px; margin: 20px 0; border-radius: 12px; display: none; background: #fef2f2; color: #dc2626; border: 2px solid #fecaca; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Observation cards */
        .observation-card {
            background: var(--color-white);
            border: 1px solid var(--color-gray-border-medium);
            border-radius: 12px;
            padding: 0;
            text-align: left;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        .observation-card:hover { box-shadow: 0 8px 25px rgba(0,0,0,0.08); transform: translateY(-2px); }
        .obs-card-content { padding: 20px; flex-grow: 1; }
        .obs-card-title { font-weight: 600; color: var(--color-gray-text-light); font-size: 1.1rem; margin-bottom: 4px; }
        .obs-card-desc { color: var(--color-text-deemphasized); font-size: 0.9rem; margin-bottom: 12px; }
        .status-badge { display: inline-block; padding: 4px 10px; font-size: 0.8rem; font-weight: 600; border-radius: 9999px; }
        .status-draft { background-color: var(--color-amber-light-bg); color: var(--color-amber-text-dark); }
        .status-finalized { background-color: var(--color-green-light-bg); color: var(--color-green-darker); }
        .obs-card-actions { background: var(--color-gray-bg-light); border-top: 1px solid var(--color-gray-border-medium); padding: 15px 20px; display: flex; gap: 10px; }
        .obs-card-actions .filter-btn { flex: 1; text-align: center; padding: 8px 16px; font-size: 0.9rem; min-width: auto; }
        .btn-edit { background: #3b82f6; border-color: #3b82f6; }
        .btn-edit:hover { background: #2563eb; border-color: #2563eb; }
        .btn-finalize { background: var(--color-green-base); border-color: var(--color-green-base); }
        .btn-finalize:hover { background: var(--color-green-dark); border-color: var(--color-green-dark); }
        .btn-delete { background: var(--color-red-base); border-color: var(--color-red-base); }
        .btn-delete:hover { background: var(--color-red-dark); border-color: var(--color-red-dark); }
        .btn-view { background: #3b82f6; border-color: #3b82f6; }
        .btn-view:hover { background: #2563eb; border-color: #2563eb; }
        .btn-export { background: var(--color-green-base); border-color: var(--color-green-base); }
        .btn-export:hover { background: var(--color-green-dark); border-color: var(--color-green-dark); }

        .observation-metadata-editor {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        /* Finalized Observation Header */
        .finalized-observation-header {
            padding: 12px 20px;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border-bottom: 1px solid #047857;
        }

        .finalized-status {
            margin-bottom: 4px;
        }

        .status-indicator {
            font-weight: 600;
            font-size: 0.85rem;
        }

        .observation-details {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .obs-name {
            font-weight: 600;
            font-size: 1.0rem;
        }

        .obs-date {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        /* Read-only Evidence Sections */
        .readonly-evidence .evidence-content {
            background: #f8fafc;
        }

        .readonly-notes-content {
            padding: 15px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            line-height: 1.6;
            color: #374151;
        }

        .no-notes-message {
            padding: 15px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            color: #6b7280;
            font-style: italic;
            text-align: center;
        }

        /* Read-only evidence sections use standard toggle styling */
        .readonly-evidence .evidence-content {
            border-left: 3px solid #10b981;
        }

        .global-tools-bar {
            background: var(--color-white);
            border-bottom: 2px solid var(--color-gray-border-medium);
            padding: 16px 24px;
            display: flex;
            justify-content: center;
        }

        .global-tools-container {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .global-tool-btn {
            background: var(--color-blue-base);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .global-tool-btn:hover {
            background: var(--color-blue-dark);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }
        
        .global-tool-btn:active {
            background: var(--color-blue-dark);
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
        }

        .global-tool-btn.recording {
            background: var(--color-red-base);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* PDF Button States */
        .btn-pdf-failed { 
            background: #f97316; 
            border-color: #f97316; 
            position: relative;
        }
        .btn-pdf-failed:hover { 
            background: #ea580c; 
            border-color: #ea580c; 
        }
        .btn-pdf-failed:before {
            content: "‚ö†Ô∏è ";
            margin-right: 4px;
        }
        
        .btn-pdf-missing { 
            background: #6b7280; 
            border-color: #6b7280; 
            position: relative;
        }
        .btn-pdf-missing:hover { 
            background: #4b5563; 
            border-color: #4b5563; 
        }
        .btn-pdf-missing:before {
            content: "üìÑ ";
            margin-right: 4px;
        }

        /* === Sticky Navigation Bar === */
        .sticky-nav {
            position: sticky;
            top: 0;
            z-index: 100;
            background: var(--color-white);
            border-bottom: 2px solid var(--color-gray-border-medium);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: none; /* Hidden by default, shown when viewing rubric */
        }

        .sticky-nav.show {
            display: flex;
        }

        .nav-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            gap: 24px;
        }

        .nav-section {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .nav-back {
            color: var(--color-blue-base);
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .nav-back:hover {
            background: var(--color-blue-light-bg);
            color: var(--color-blue-text-dark);
        }

        /* Professional Sliding Toggle */
        .view-toggle {
            display: flex;
            align-items: center;
            background: var(--color-gray-bg-light);
            border-radius: 8px;
            padding: 4px;
            border: 2px solid var(--color-gray-border-light);
            position: relative;
        }

        .toggle-option {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--color-gray-text);
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
            white-space: nowrap;
        }

        .toggle-option.active {
            color: var(--color-blue-text-dark);
        }

        .toggle-slider {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            background: var(--color-white);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .staff-context {
            color: var(--color-gray-text);
            font-weight: 500;
            font-size: 0.9rem;
            padding: 8px 12px;
            background: var(--color-gray-bg-light);
            border-radius: 6px;
            border: 1px solid var(--color-gray-border-light);
        }

        .nav-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .nav-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            border: 2px solid;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }


        .nav-btn-finalize {
            background: var(--color-green-base);
            color: var(--color-white);
            border-color: var(--color-green-base);
        }

        .nav-btn-finalize:hover {
            background: var(--color-green-dark);
            border-color: var(--color-green-dark);
        }

        .role-badge {
            background: var(--color-blue-base);
            color: var(--color-white);
            border: 2px solid var(--color-blue-base);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            transition: all 0.2s ease;
        }

        /* === Rubric Styles (from rubric.html) === */
        .rubric-container { display: none; margin-top: 30px; }
        .domain-section { border-bottom: 3px solid var(--color-gray-border-medium); }
        .domain-header { background: linear-gradient(135deg, #7c9ac5, #5a82b8); color: white; padding: 15px 20px; font-size: 1.1rem; font-weight: 600; position: sticky; top: 76px; z-index: 50; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .component-section { border-bottom: 1px solid var(--color-gray-border-medium); position: relative; transition: background-color 0.2s; }
        .performance-levels-header { position: sticky; top: 132px; z-index: 40; background: white; border-bottom: 2px solid var(--color-gray-border-medium); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        
        /* Finalized View - Corrected Sticky Positioning */
        .finalized-view .domain-header { 
            top: 56px; /* Adjusted for sticky nav only (no global tools bar) */
        }
        
        .finalized-view .performance-levels-header {
            top: 112px; /* Domain header height + sticky nav */
        }
        .performance-levels { display: grid; grid-template-columns: 200px 1fr 1fr 1fr 1fr; min-height: 50px; }
        .performance-levels-content { display: grid; grid-template-columns: 200px 1fr 1fr 1fr 1fr; min-height: 120px; }
        .level-header { background: #e2e8f0; padding: 12px; font-weight: 600; text-align: center; border-bottom: 1px solid #cbd5e0; color: var(--color-gray-text); font-size: 0.9rem; }
        .level-content { padding: 20px; border-right: 1px solid var(--color-gray-border-medium); border-bottom: 1px solid var(--color-gray-border-medium); background: var(--color-white); color: var(--color-gray-text); font-size: 0.9rem; transition: background-color 0.2s; }
        .level-content:last-child { border-right: none; }
        .row-label { background: #64748b; padding: 20px; font-weight: 600; color: white; border-bottom: 1px solid var(--color-gray-border-medium); display: flex; align-items: center; font-size: 0.9rem; }

        /* Look-fors (Best Practices) */
        .look-fors-section { border-top: 1px solid var(--color-gray-border-medium); }
        .look-fors-header { background: linear-gradient(135deg, #3182ce, #2b77cb); color: white; padding: 10px 20px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-weight: 600; transition: background 0.3s ease; font-size: 0.85rem; }
        .look-fors-header:hover { background: linear-gradient(135deg, #2b77cb, #2c5aa0); }
        .chevron { transition: all 0.3s ease; font-size: 1rem; }
        .look-fors-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; background: var(--color-gray-bg-light); }
        .look-fors-content.expanded { max-height: 1000px; }
        .look-fors-grid { padding: 12px 20px; display: grid; grid-template-columns: 1fr; gap: 8px; }
        .look-for-item { display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: var(--color-white); border-radius: 4px; box-shadow: 0 1px 2px rgba(0,0,0,0.08); border-left: 3px solid var(--color-blue-base); }
        .look-for-item label { cursor: pointer; color: var(--color-gray-text); font-weight: 500; font-size: 0.85rem; line-height: 1.4; }

        /* Component Assignment & Highlighting */
        .component-section.component-assigned { border-left: 4px solid var(--color-green-base); background: var(--color-green-light-bg); }
        .component-section.component-not-assigned { border-left: 4px solid var(--color-gray-component-not-assigned-border); }
        .component-section.component-not-assigned .level-content { color: var(--color-text-deemphasized); }
        .component-section[data-assigned="true"]:hover { border-left-color: var(--color-green-dark); }
        .component-section:not([data-assigned="true"]):hover { border-left-color: var(--color-gray-border-light); background-color: var(--color-gray-bg-light); }
        .component-hidden { display: none; }
        
        /* Utility class for hiding elements completely */
        .hidden { display: none !important; }
        
        /* Interactive Rubric Styles */
        .level-content.editable { cursor: pointer; }
        .level-content.editable:hover { background-color: var(--color-blue-light-bg); }
        .level-content.selected { background-color: var(--color-blue-light-bg) !important; border: 2px solid var(--color-blue-base); font-weight: 600; color: var(--color-blue-text-dark); }

        /* Media Upload Styles */
        .media-upload-section { padding: 15px 20px; background-color: var(--color-gray-bg-light); border-top: 1px solid var(--color-gray-border-medium); }
        .media-upload-title { font-weight: 600; color: var(--color-gray-text); margin-bottom: 10px; font-size: 0.9rem; }
        .media-upload-area { display: flex; gap: 10px; align-items: center; }
        .media-upload-input { display: none; }
        .media-upload-label { background: var(--color-gray-bg-medium); color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; transition: background-color 0.2s; }
        .media-upload-label:hover { background: var(--color-gray-bg-dark); }
        .upload-status { font-size: 0.85rem; color: var(--color-gray-text); font-style: italic; }
        .evidence-list { margin-top: 10px; padding-left: 20px; }
        .evidence-item { margin-bottom: 5px; font-size: 0.9rem; }
        .evidence-item a { color: var(--color-blue-base); text-decoration: none; }
        .evidence-item a:hover { text-decoration: underline; }

        /* View Toggle Button */
        .view-toggle-button {
            background-color: var(--color-gray-bg-light);
            border: 1px solid var(--color-gray-border-light);
            padding: 8px 16px;
            margin: 0 0 20px 0;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            color: var(--color-gray-text);
            transition: all 0.2s ease;
        }
        .view-toggle-button:hover { background-color: #dee2e6; border-color: #adb5bd; }
        .filter-status {
            background: var(--color-blue-light-bg);
            border: 1px solid var(--color-blue-base);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: var(--color-blue-text-dark);
            font-weight: 500;
            display: none;
        }

        /* Toast Notification Styles */
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--color-red-base);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 9999;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            font-weight: 500;
            max-width: 350px;
            word-wrap: break-word;
        }
        .toast-notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast-notification.success {
            background-color: var(--color-green-base);
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .content { padding: 20px; }
            .actions-grid { grid-template-columns: 1fr; }
            .filter-row { flex-direction: column; align-items: stretch; }
            .filter-select, .filter-btn { min-width: auto; width: 100%; }
            .performance-levels, .performance-levels-content { grid-template-columns: 1fr; gap: 1px; }
            .level-header, .row-label, .level-content { border-right: none; padding: 15px; font-size: 0.9rem; }
            .toast-notification { top: 10px; right: 10px; left: 10px; right: 10px; max-width: none; }
            
            /* Responsive Navigation */
            .nav-container {
                flex-wrap: wrap;
                padding: 8px 16px;
                gap: 12px;
            }
            
            .nav-section {
                gap: 8px;
            }
            
            .nav-back {
                font-size: 0.8rem;
                padding: 6px 12px;
            }
            
            .toggle-option {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
            
            .staff-context {
                font-size: 0.8rem;
                padding: 6px 10px;
            }
            
            .nav-btn {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
            
            .role-badge {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
        }

        /* Evidence Section Styles */
        .evidence-section {
            margin-top: 10px;
        }

        .evidence-toggle-btn {
            background: linear-gradient(135deg, #4a4a4a, #3a3a3a);
            color: white;
            border: none;
            padding: 10px 20px;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            transition: background 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .evidence-toggle-btn:hover {
            background: linear-gradient(135deg, #3a3a3a, #2a2a2a);
        }

        .evidence-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: #f8fafc;
        }

        .evidence-content.expanded {
            max-height: 800px;
        }

        .notes-container {
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .notes-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            display: inline-block;
        }

        .notes-header-actions {
            float: right;
            margin-top: -5px;
        }

        .clear-notes-btn {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .clear-notes-btn:hover {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(245, 101, 101, 0.3);
        }

        .clear-notes-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .look-fors-container {
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .look-fors-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .look-fors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 8px;
        }

        .look-for-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
        }

        .look-for-item input[type="checkbox"] {
            margin-top: 2px;
            flex-shrink: 0;
        }

        .look-for-item label {
            font-size: 0.85rem;
            line-height: 1.4;
            cursor: pointer;
        }

        .media-upload-container {
            padding: 15px 20px;
        }

        .media-upload-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .media-upload-input {
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            width: 100%;
        }

        .media-upload-button {
            background: #3182ce;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .media-upload-button:hover {
            background: #2b77cb;
        }

        .media-links-container {
            margin-top: 10px;
        }

        .evidence-item {
            margin-bottom: 5px;
        }

        .evidence-item a {
            color: #3182ce;
            text-decoration: none;
            font-size: 0.85rem;
        }

        .evidence-item a:hover {
            text-decoration: underline;
        }

        /* Script Editor Modal Styles */
        .script-editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .script-editor-container {
            background: white;
            width: 95%;
            height: 90%;
            border-radius: 12px;
            position: relative;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .script-editor-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            border-radius: 12px;
        }

        .script-editor-loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        .script-editor-loading-text {
            color: #666;
            font-size: 16px;
            font-weight: 500;
        }

        .script-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 2px solid var(--color-gray-border-medium);
        }

        .script-editor-header h2 {
            font-size: 1.5rem;
            color: var(--color-gray-text-light);
        }

        .script-editor-controls {
            display: flex;
            gap: 12px;
        }

        .script-editor-controls .btn-primary {
            background-color: var(--color-green-base);
            border-color: var(--color-green-base);
            font-weight: 700;
            padding: 10px 20px;
        }

        .script-editor-controls .btn-primary:hover {
            background-color: var(--color-green-dark);
            border-color: var(--color-green-dark);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
        }
        
        .script-editor-controls .btn-secondary {
            padding: 10px 20px;
            font-weight: 500;
        }

        .script-editor-content {
            flex-grow: 1;
            padding: 0 24px 24px 24px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #scriptEditor {
            height: 100%;
            border: 1px solid var(--color-gray-border-light);
            border-radius: 6px;
            background-color: var(--color-white);
        }

        /* Quill toolbar customization */
        .script-editor-toolbar {
            padding: 12px 0;
        }

        #scriptEditor .ql-editor {
            font-size: 16px;
            line-height: 1.6;
            color: var(--color-text-default);
            height: 100%;
        }

        /* Component Tagging System Styles */
        .script-tagging-toolbar {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-bottom: 2px solid #e2e8f0;
            padding: 12px 16px;
        }

        .tagging-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .component-selector {
            min-width: 200px;
            max-width: 300px;
            padding: 8px 12px;
            border: 2px solid #cbd5e0;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            color: var(--color-text-default);
            transition: all 0.2s ease;
        }

        .component-selector:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .btn-tag, .btn-push, .btn-clear-tags {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-tag {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-tag:hover {
            background: linear-gradient(135deg, #3182ce 0%, #2c5aa0 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(49, 130, 206, 0.3);
        }

        .btn-push {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-push:hover {
            background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(72, 187, 120, 0.3);
        }

        .btn-clear-tags {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-clear-tags:hover {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(245, 101, 101, 0.3);
        }

        .tag-status {
            font-size: 12px;
            color: #4a5568;
            font-style: italic;
            padding: 4px 8px;
            background: #f7fafc;
            border-radius: 4px;
            border-left: 3px solid #4299e1;
        }

        /* Tagged content visual indicators */
        .script-editor-content .ql-editor [style*="background"] {
            position: relative;
            border-radius: 3px;
            padding: 1px 2px;
        }

        /* Component tag color legend (could be added later if needed) */
        .tag-legend {
            display: none; /* Hidden for now, but available for future use */
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        /* Responsive adjustments for tagging toolbar */
        @media (max-width: 768px) {
            .tagging-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .component-selector {
                min-width: unset;
                max-width: unset;
            }
            
            .btn-tag, .btn-push, .btn-clear-tags {
                justify-content: center;
            }
        }

        /* Professional Welcome Modal Styles */
        .welcome-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s ease;
            padding: 20px;
            box-sizing: border-box;
        }

        .welcome-modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .welcome-modal {
            background: var(--color-white);
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: translateY(30px) scale(0.9);
            transition: all 0.4s ease;
        }

        .welcome-modal-overlay.show .welcome-modal {
            transform: translateY(0) scale(1);
        }

        .welcome-modal-header {
            background: linear-gradient(135deg, var(--color-blue-base), var(--color-blue-dark));
            color: var(--color-white);
            padding: 40px 30px 30px;
            text-align: center;
            position: relative;
        }

        .welcome-modal-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            display: block;
            animation: welcomeIconPulse 2s ease-in-out infinite;
        }

        @keyframes welcomeIconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .welcome-modal-header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .welcome-subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            font-weight: 400;
            margin: 0;
        }

        .welcome-modal-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            line-height: 1.6;
        }

        .welcome-section {
            margin-bottom: 30px;
        }

        .welcome-feature {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 25px;
            padding: 20px;
            background: var(--color-gray-bg-light);
            border-radius: 12px;
            border-left: 4px solid var(--color-blue-base);
            transition: all 0.3s ease;
        }

        .welcome-feature:hover {
            background: var(--color-blue-light-bg);
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.1);
        }

        .feature-icon {
            font-size: 2rem;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .feature-content h3 {
            color: var(--color-gray-text-light);
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .feature-content p {
            color: var(--color-gray-text);
            font-size: 0.95rem;
            margin: 0;
        }

        .welcome-commitment {
            background: linear-gradient(135deg, var(--color-green-light-bg), var(--color-blue-light-bg));
            border: 2px solid var(--color-green-base);
            border-radius: 12px;
            padding: 25px;
            text-align: center;
        }

        .welcome-commitment h3 {
            color: var(--color-green-darker);
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .welcome-commitment p {
            color: var(--color-gray-text-light);
            font-size: 1rem;
            margin: 0;
            font-style: italic;
        }

        .welcome-modal-footer {
            padding: 25px 30px;
            background: var(--color-gray-bg-light);
            border-top: 1px solid var(--color-gray-border-light);
            text-align: center;
        }

        .welcome-continue-btn {
            background: linear-gradient(135deg, var(--color-green-base), var(--color-green-dark));
            color: var(--color-white);
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
            min-width: 280px;
        }

        .welcome-continue-btn:hover {
            background: linear-gradient(135deg, var(--color-green-dark), var(--color-green-darker));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .welcome-continue-btn .btn-icon {
            font-size: 1.2rem;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .welcome-modal-overlay {
                padding: 15px;
            }
            
            .welcome-modal {
                max-width: 100%;
                border-radius: 12px;
            }
            
            .welcome-modal-header {
                padding: 30px 20px 25px;
            }
            
            .welcome-modal-header h1 {
                font-size: 1.5rem;
            }
            
            .welcome-subtitle {
                font-size: 1rem;
            }
            
            .welcome-modal-content {
                padding: 20px;
            }
            
            .welcome-feature {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .feature-icon {
                align-self: center;
            }
            
            .welcome-continue-btn {
                min-width: 250px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Professional Welcome Modal -->
    <div class="welcome-modal-overlay" id="welcomeModalOverlay">
        <div class="welcome-modal" id="welcomeModal">
            <div class="welcome-modal-header">
                <div class="welcome-modal-icon">üåü</div>
                <h1>Welcome to the Observation Resources Website</h1>
                <p class="welcome-subtitle">Your Professional Growth Journey Begins Here</p>
            </div>
            
            <div class="welcome-modal-content">
                <div class="welcome-section">
                    <div class="welcome-feature">
                        <span class="feature-icon">üìà</span>
                        <div class="feature-content">
                            <h3>Continuous Professional Development</h3>
                            <p>This platform is designed to support your ongoing professional growth through reflective observation and evidence-based feedback. Every interaction is an opportunity to enhance your teaching practice.</p>
                        </div>
                    </div>
                    
                    <div class="welcome-feature">
                        <span class="feature-icon">ü§ù</span>
                        <div class="feature-content">
                            <h3>Collaborative Learning Environment</h3>
                            <p>Engage in meaningful peer observations and receive constructive feedback that supports your development. Our framework promotes collegiality and shared expertise among educational professionals.</p>
                        </div>
                    </div>
                    
                    <div class="welcome-feature">
                        <span class="feature-icon">üéØ</span>
                        <div class="feature-content">
                            <h3>Evidence-Based Growth</h3>
                            <p>Utilize comprehensive rubrics and structured observation tools to identify strengths and areas for growth. Transform observations into actionable insights for improved student outcomes.</p>
                        </div>
                    </div>
                    
                    <div class="welcome-feature">
                        <span class="feature-icon">‚ú®</span>
                        <div class="feature-content">
                            <h3>Inspiring Excellence</h3>
                            <p>This experience is designed to be supportive, inspiring, and focused on celebrating your professional journey. Every observation is a step toward educational excellence.</p>
                        </div>
                    </div>
                </div>
                
                <div class="welcome-commitment">
                    <h3>Our Commitment to You</h3>
                    <p>We are dedicated to providing a positive, growth-oriented experience that recognizes your professionalism and supports your continued development as an educator. This tool represents our investment in your success and the success of all learners in our community.</p>
                </div>
            </div>
            
            <div class="welcome-modal-footer">
                <button class="welcome-continue-btn" onclick="closeWelcomeModal()">
                    <span class="btn-icon">üöÄ</span>
                    Continue Growing in My Profession
                </button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <!-- Sticky Navigation Bar -->
        <nav class="sticky-nav" id="stickyNav">
            <div class="nav-container">
                <div class="nav-section">
                    <a href="#" class="nav-back" onclick="goBackToObservations(); return false;">
                        ‚Üê Back
                    </a>
                    
                    <div class="view-toggle" id="viewToggle" style="display: none;">
                        <div class="toggle-slider" id="toggleSlider"></div>
                        <button class="toggle-option active" id="assignedToggle" onclick="setViewMode('assigned')">
                            Assigned Subdomains
                        </button>
                        <button class="toggle-option" id="fullToggle" onclick="setViewMode('full')">
                            Full Rubric
                        </button>
                    </div>
                </div>
                
                <div class="staff-context" id="staffContext" style="display: none;">
                    Viewing: <span id="staffName">--</span>
                </div>
                
                <div class="nav-section">
                    <div class="nav-actions" id="navActions" style="display: none;">
                        <button class="nav-btn nav-btn-finalize" id="finalizeBtn" onclick="handleFinalizeFromNav()">
                            ‚úÖ Finalize & Submit
                        </button>
                    </div>
                    
                    <div class="role-badge">
                        <?= userContext.role ?>
                    </div>
                </div>
            </div>
        </nav>

        <div class="header"><h1>üë• Observation Dashboard</h1><p>Select how you'd like to view rubric information</p></div>
        <div class="content">
            <div id="quickActionsView">
                <div class="quick-actions"><h2 class="section-title"><span>üéØ</span> Quick Actions</h2>
                    <div class="actions-grid">
                        <? if (userContext.hasSpecialAccess) { ?>
                        <div class="action-card" onclick="showCustomFilters()"><span class="action-icon">üîç</span><div class="action-title">Find Staff & Start Observation</div><div class="action-desc">Filter by role, year, or specific staff member</div></div>
                        <? } ?>
                        <? if (userContext.specialRoleType === 'peer_evaluator' || userContext.specialRoleType === 'full_access') { ?>
                        <div class="action-card" onclick="loadMyOwnView()"><span class="action-icon">üìã</span><div class="action-title">My Own Rubric</div><div class="action-desc">View your personal assigned areas</div></div>
                        <? } ?>
                    </div>
                </div>
            </div>
            <div class="custom-filters" id="adminStaffListView" style="display: none;">
                <h2 class="section-title"><span>üë•</span> Summative Year Staff</h2>
                <div class="actions-grid" id="adminStaffGrid">
                    <!-- Staff list will be populated here -->
                </div>
            </div>
            <div class="custom-filters" id="customFiltersView">
                <h2 class="section-title"><span>üîç</span> Find Staff Member</h2>
                <div class="filter-row"><select id="roleSelect" class="filter-select" onchange="handleRoleChange()"><option value="">1. Select Role...</option><? for (var i = 0; i < availableRoles.length; i++) { ?><option value="<?= availableRoles[i] ?>"><?= availableRoles[i] ?></option><? } ?></select></div>
                <div class="filter-row"><select id="yearSelect" class="filter-select" style="display: none;" onchange="handleYearChange()"><option value="">2. Select Year...</option><? if (userContext.role === 'Administrator') { ?><option value="3">Year 3</option><option value="0">Probationary</option><? } else { ?><option value="1">Year 1</option><option value="2">Year 2</option><option value="3">Year 3</option><option value="0">Probationary</option><? } ?></select></div>
                <div class="filter-row"><select id="staffSelect" class="filter-select" style="display: none;" onchange="handleStaffChange()"><option value="">3. Select Staff Member...</option></select></div>
                <div class="filter-row"><button class="filter-btn" id="loadBtn" onclick="loadSelectedView()" disabled>üìñ Select Staff</button><button class="filter-btn btn-secondary" onclick="clearFilters()">üóëÔ∏è Clear & Go Back</button></div>
            </div>
            <div class="observation-selector" id="observationSelectorView"></div>
            <div class="error" id="error"><div id="errorMessage"></div><button class="filter-btn btn-secondary" onclick="hideError()" style="margin-top: 15px;">Dismiss</button></div>
            <div class="filter-status" id="filterStatus"><strong>Currently Viewing:</strong> <span id="filterStatusText"></span></div>
            <div class="rubric-container" id="rubricContainer"></div>
        </div>
    </div>
    <div class="toast-notification" id="toastNotification"></div>
    <script>
        /**
         * Professional Welcome Modal Functions
         */
        
        // Show the welcome modal on page load (once per session)
        function showWelcomeModal() {
            // Check if modal has been shown this session
            if (sessionStorage.getItem('welcomeModalShown') === 'true') {
                return; // Don't show again this session
            }
            
            const overlay = document.getElementById('welcomeModalOverlay');
            if (overlay) {
                // Small delay to ensure page is fully loaded
                setTimeout(() => {
                    overlay.classList.add('show');
                    document.body.style.overflow = 'hidden'; // Prevent background scrolling
                }, 300);
            }
        }
        
        // Close the welcome modal
        function closeWelcomeModal() {
            const overlay = document.getElementById('welcomeModalOverlay');
            if (overlay) {
                overlay.classList.remove('show');
                document.body.style.overflow = ''; // Restore scrolling
                
                // Mark as shown for this session
                sessionStorage.setItem('welcomeModalShown', 'true');
                
                // Remove from DOM after animation completes
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 400);
            }
        }
        
        // Handle keyboard events for accessibility
        function handleModalKeydown(event) {
            if (event.key === 'Escape') {
                const overlay = document.getElementById('welcomeModalOverlay');
                if (overlay && overlay.classList.contains('show')) {
                    closeWelcomeModal();
                }
            }
        }
        
        // Initialize modal when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Add keyboard listener for escape key
            document.addEventListener('keydown', handleModalKeydown);
            
            // Show welcome modal after a brief delay
            showWelcomeModal();
            
            // Optional: Close modal if clicking outside (on overlay)
            const overlay = document.getElementById('welcomeModalOverlay');
            if (overlay) {
                overlay.addEventListener('click', function(event) {
                    // Only close if clicking directly on the overlay (not the modal content)
                    if (event.target === overlay) {
                        closeWelcomeModal();
                    }
                });
            }
        });

        /**
         * Escapes HTML entities in a string to prevent XSS and ensure safe HTML rendering.
         * This implementation matches the server-side Utils.js version for consistency.
         * @param {*} unsafe - The input to escape (will be converted to string if not already)
         * @returns {string} The escaped string with HTML entities replaced
         */
        function escapeHtml(unsafe) {
            // Handle null and undefined by returning empty string
            if (unsafe == null) {
                return '';
            }
            
            // Convert to string if not already a string
            const str = String(unsafe);
            
            // Define the character mapping for HTML entities
            const entityMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            };
            
            // Replace characters using the entity map
            return str.replace(/[&<>"']/g, function(match) {
                return entityMap[match];
            });
        }

        /**
         * Escapes characters in a string to ensure it's safe to use within a JavaScript
         * single-quoted string literal, such as in an onclick attribute.
         * @param {*} unsafe - The input to escape (will be converted to string if not already)
         * @returns {string} The escaped string, safe for JS string literals.
         */
        function escapeJsString(unsafe) {
            if (unsafe == null) {
                return '';
            }
            const str = String(unsafe);
            return str.replace(/[\\']/g, '\\$&')
                      .replace(/\n/g, '\\n')
                      .replace(/\r/g, '\\r');
        }

        function showLoading(message = 'Loading...') { 
            document.getElementById('loading-text').textContent = message; 
            document.getElementById('loading').style.display = 'flex'; 
            hideError(); 
        }
        function hideLoading() { document.getElementById('loading').style.display = 'none'; }
        function showError(error) { const msg = error.message || String(error); document.getElementById('errorMessage').textContent = msg; document.getElementById('error').style.display = 'block'; hideLoading(); }
        function hideError() { document.getElementById('error').style.display = 'none'; }
        function handleError(error) { console.error('AJAX Error:', error); showError(error); }

        function showToast(message, isSuccess = false) {
            const toast = document.getElementById('toastNotification');
            toast.textContent = message;
            toast.className = 'toast-notification' + (isSuccess ? ' success' : '');
            toast.classList.add('show');
            setTimeout(function() {
                toast.classList.remove('show');
            }, 4000);
        }

        let currentFilters = { role: null, year: null, staff: null };
        let currentObservationId = null;
        let observationViewMode = 'assigned';
        let currentObservedUser = { email: null, name: null };

        function showView(viewId) {
            stopAllPollers(); // Stop any running pollers when the view changes
            ['quickActionsView', 'customFiltersView', 'observationSelectorView', 'rubricContainer'].forEach(id => { 
                document.getElementById(id).style.display = 'none'; 
            }); 
            document.getElementById(viewId).style.display = 'block'; 
            
            const header = document.querySelector('.header');

            // Show/hide sticky nav and header based on view
            if (viewId === 'rubricContainer') {
                if (header) header.classList.add('hidden');
                // Nav will be shown by handleRubricData
            } else {
                if (header) header.classList.remove('hidden');
                hideStickyNav();
            }
        }
        function showCustomFilters() { showView('customFiltersView'); }
        function loadMyOwnView() { 
            console.log('loadMyOwnView called - making AJAX request');
            showLoading('Loading your assigned rubric...'); 
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .loadRubricData({ myOwnView: true }); 
        }

        function handleRoleChange() {
            const roleSelect = document.getElementById('roleSelect'); const yearSelect = document.getElementById('yearSelect'); currentFilters.role = roleSelect.value;
            yearSelect.value = ''; yearSelect.style.display = roleSelect.value ? 'block' : 'none'; handleYearChange();
        }
        function handleYearChange() {
            const yearSelect = document.getElementById('yearSelect'); const staffSelect = document.getElementById('staffSelect'); currentFilters.year = yearSelect.value;
            staffSelect.value = ''; staffSelect.style.display = yearSelect.value ? 'block' : 'none';
            if (yearSelect.value) { loadStaffOptions(); } else { handleStaffChange(); }
        }
        function handleStaffChange() { const staffSelect = document.getElementById('staffSelect'); currentFilters.staff = staffSelect.value; document.getElementById('loadBtn').disabled = !staffSelect.value; }
        function loadStaffOptions() {
            const staffSelect = document.getElementById('staffSelect'); staffSelect.innerHTML = '<option value="">Loading staff...</option>'; staffSelect.disabled = true;
            google.script.run.withSuccessHandler(populateStaffDropdown).withFailureHandler(handleError).getStaffListForDropdown(currentFilters.role, currentFilters.year);
        }
        function populateStaffDropdown(result) {
            const staffSelect = document.getElementById('staffSelect'); staffSelect.disabled = false;
            if (!result.success) { staffSelect.innerHTML = `<option value="">Error: ${result.error}</option>`; return; }
            staffSelect.innerHTML = '<option value="">3. Select Staff Member...</option>';
            if (result.staff?.length) {
                result.staff.forEach(staff => staffSelect.appendChild(new Option(staff.displayName, staff.email)));
            } else {
                staffSelect.appendChild(new Option('No staff found', '', true, true));
            }
        }
        function loadSelectedView() { if (!currentFilters.staff) return; showLoading('Loading...'); google.script.run.withSuccessHandler(handleRubricData).withFailureHandler(handleError).loadRubricData(currentFilters); }
        function clearFilters() { showView('quickActionsView'); hideError(); hideLoading(); document.getElementById('filterStatus').style.display = 'none'; }

        let activePollers = {};

        function _setPdfButtonState(observationId, state, pdfUrl = null) {
            const pdfButton = document.getElementById(`pdf-button-${observationId}`);
            if (!pdfButton) return;

            switch (state) {
                case 'generating':
                    pdfButton.textContent = 'Generating PDF...';
                    pdfButton.className = 'filter-btn btn-export btn-pdf-missing';
                    pdfButton.disabled = true;
                    pdfButton.onclick = null;
                    break;
                case 'ready':
                    pdfButton.textContent = 'View PDF';
                    pdfButton.className = 'filter-btn btn-export';
                    pdfButton.disabled = false;
                    pdfButton.onclick = () => window.open(pdfUrl, '_blank');
                    break;
                case 'failed':
                    pdfButton.textContent = 'Retry PDF';
                    pdfButton.className = 'filter-btn btn-export btn-pdf-failed';
                    pdfButton.disabled = false;
                    pdfButton.onclick = () => handleRetryPdf(observationId);
                    break;
            }
        }

        function startPdfPolling(observationId) {
            if (activePollers[observationId]) {
                console.log(`Polling already active for ${observationId}`);
                return;
            }

            console.log(`Starting PDF polling for ${observationId}`);
            const pollInterval = 5000; // 5 seconds
            const pollTimeout = 60000; // 60 seconds

            const intervalId = setInterval(() => {
                google.script.run
                    .withSuccessHandler(res => {
                        if (res.success) {
                            if (res.pdfUrl) {
                                console.log(`PDF found for ${observationId}`);
                                showToast('PDF is ready!', true);
                                _setPdfButtonState(observationId, 'ready', res.pdfUrl);
                                stopPdfPolling(observationId);
                            } else if (res.pdfStatus === 'failed') {
                                console.log(`PDF generation failed for ${observationId}`);
                                showToast('PDF generation failed. Please retry.', false);
                                _setPdfButtonState(observationId, 'failed');
                                stopPdfPolling(observationId);
                            }
                        } else {
                             console.warn(`Polling check failed for ${observationId}: ${res.error}`);
                        }
                    })
                    .withFailureHandler(err => {
                        console.error(`Polling error for ${observationId}:`, err);
                    })
                    .getObservationStatusAndPdfUrl(observationId);
            }, pollInterval);

            const timeoutId = setTimeout(() => {
                console.log(`Polling timed out for ${observationId}`);
                const pdfButton = document.getElementById(`pdf-button-${observationId}`);
                if (pdfButton && pdfButton.disabled) {
                     showToast('PDF generation is taking longer than expected. Please check back later or retry.', false);
                    _setPdfButtonState(observationId, 'failed');
                }
                stopPdfPolling(observationId);
            }, pollTimeout);

            activePollers[observationId] = { intervalId, timeoutId };
        }

        function stopPdfPolling(observationId) {
            if (activePollers[observationId]) {
                clearInterval(activePollers[observationId].intervalId);
                clearTimeout(activePollers[observationId].timeoutId);
                delete activePollers[observationId];
                console.log(`Stopped polling for ${observationId}`);
            }
        }

        function stopAllPollers() {
            Object.keys(activePollers).forEach(observationId => {
                stopPdfPolling(observationId);
            });
        }

        function renderObservationCards(result, observedEmail, observedName) {
            hideLoading();
            if (!result.success) return showError(result.error);
            const container = document.getElementById('observationSelectorView');
            const safeObservedNameHtml = escapeHtml(observedName);
            const safeObservedEmailJs = escapeJsString(observedEmail);

            let cardsHtml = `<div class="action-card" onclick="handleNewObservation('${safeObservedEmailJs}')"><span class="action-icon">‚ûï</span><div class="action-title">Start New Observation</div><div class="action-desc">Begin a new evaluation for this staff member.</div></div>`;
            result.observations.forEach(obs => {
                const date = new Date(obs.createdAt).toLocaleDateString();
                let buttons = '';
                const safeObsIdJs = escapeJsString(obs.observationId);
                const safeObsIdHtml = escapeHtml(obs.observationId);
                const safeObsNameHtml = escapeHtml(obs.observedName);
                const safeStatusHtml = escapeHtml(obs.status);
                const safeObservedNameJs = escapeJsString(observedName); // For passing to finalize/delete handlers

                if (obs.status === 'Draft') {
                    buttons = `<button class="filter-btn btn-edit" onclick="handleEditObservation('${safeObsIdJs}')">Edit</button>
                               <button class="filter-btn btn-finalize" onclick="handleFinalizeObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Finalize</button>
                               <button class="filter-btn btn-delete" onclick="handleDeleteObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Delete</button>`;
                } else if (obs.status === 'Finalized') {
                    let pdfButtonHtml = '';
                    if (obs.pdfUrl) {
                        pdfButtonHtml = `<button class="filter-btn btn-export" onclick="window.open('${escapeJsString(obs.pdfUrl)}', '_blank')">View PDF</button>`;
                    } else if (obs.pdfStatus === 'failed') {
                        pdfButtonHtml = `<button class="filter-btn btn-export btn-pdf-failed" id="pdf-button-${safeObsIdHtml}" onclick="handleRetryPdf('${safeObsIdJs}')">Retry PDF</button>`;
                    } else {
                        pdfButtonHtml = `<button class="filter-btn btn-export btn-pdf-missing" id="pdf-button-${safeObsIdHtml}" disabled>Generating PDF...</button>`;
                        setTimeout(() => startPdfPolling(obs.observationId), 100);
                    }

                    buttons = `<button class="filter-btn btn-view" onclick="handleViewObservation('${safeObsIdJs}')">View</button>
                               ${pdfButtonHtml}
                               <button class="filter-btn btn-delete" onclick="handleDeleteFinalizedObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Delete</button>`;
                }
                cardsHtml += `
                    <div class="observation-card">
                        <div class="obs-card-content">
                            <div class="obs-card-title">${safeObsNameHtml} - ${safeStatusHtml}</div>
                            <div class="obs-card-desc">Created on ${date}</div>
                            <div class="status-badge ${obs.status === 'Draft' ? 'status-draft' : 'status-finalized'}">${safeStatusHtml}</div>
                        </div>
                        ${buttons ? `<div class="obs-card-actions">${buttons}</div>` : ''}
                    </div>`;
            });
            container.innerHTML = `<h2 class="section-title"><span>üìù</span> Observations for ${safeObservedNameHtml}</h2><div class="actions-grid">${cardsHtml}</div><div style="margin-top: 20px;"><button class="filter-btn btn-secondary" onclick="showView('customFiltersView')">Back to Filters</button></div>`;
            showView('observationSelectorView');
        }

        function displayObservationOptions(observedEmail, observedName) {
            currentObservedUser.email = observedEmail;
            currentObservedUser.name = observedName;
            showLoading(`Loading options for ${observedName}`);
            google.script.run
                .withSuccessHandler(result => {
                    renderObservationCards(result, observedEmail, observedName);
                })
                .withFailureHandler(handleError)
                .getObservationOptions(observedEmail);
        }

        function handleNewObservation(observedEmail) { 
            console.log('Starting new observation for:', observedEmail);
            
            // Clear all existing observation state before creating new observation
            clearObservationState();
            
            showLoading('Creating new observation draft...'); 
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .createNewObservationForEvaluator(observedEmail);
        }
        function handleEditObservation(obsId) { 
            console.log('Loading observation for editing:', obsId);
            
            // Clear all existing observation state before loading different observation
            clearObservationState();
            
            showLoading('Loading observation...'); 
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .loadObservationForEditing(obsId); 
        }
        function handleDeleteObservation(obsId, email, name) { if (confirm('Are you sure you want to delete this draft? This cannot be undone.')) { showLoading('Deleting draft...'); google.script.run.withSuccessHandler(res => { if(res.success) { displayObservationOptions(email, name); } else { showError(res.error); } }).withFailureHandler(handleError).deleteObservation(obsId); } }

        function handleFinalizeObservation(obsId, email, name) {
            if (confirm('Are you sure you want to finalize this observation? You will not be able to edit it further.')) {
                showLoading('Finalizing observation, please wait...');
                google.script.run
                    .withSuccessHandler(res => {
                        hideLoading();
                        if (res.success) {
                            showToast('Observation finalized. Generating PDF...', true);
                            // Refresh the view to show the "Generating..." button
                            displayObservationOptions(email, name);
                        } else {
                            showError(res.error);
                        }
                    })
                    .withFailureHandler(handleError)
                    .finalizeObservation(obsId);
            }
        }

        function handleFinalizeFromNav() {
            if (!currentObservationId || !currentObservedUser.email || !currentObservedUser.name) {
                showError('Unable to finalize: Missing observation context.');
                return;
            }
            
            if (confirm('Are you sure you want to finalize this observation? You will not be able to edit it further.')) {
                showLoading('Finalizing observation, please wait...');
                google.script.run
                    .withSuccessHandler(res => {
                        hideLoading();
                        if (res.success) {
                            showToast('Observation finalized. Generating PDF...', true);
                            // Navigate back to observation list
                            displayObservationOptions(currentObservedUser.email, currentObservedUser.name);
                        } else {
                            showError(res.error);
                        }
                    })
                    .withFailureHandler(handleError)
                    .finalizeObservation(currentObservationId);
            }
        }

        function handleViewObservation(obsId) {
            console.log('Loading finalized observation for viewing:', obsId);
            
            // Clear all existing observation state before loading different observation
            clearObservationState();
            
            showLoading('Loading observation...');
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .loadFinalizedObservationForViewing(obsId);
        }

        function handleDeleteFinalizedObservation(obsId, email, name) {
            if (confirm('Are you sure you want to PERMANENTLY DELETE this finalized observation? This action cannot be undone.')) {
                showLoading('Deleting observation...');
                google.script.run.withSuccessHandler(res => {
                    if(res.success) {
                        displayObservationOptions(email, name);
                    } else {
                        showError(res.error);
                    }
                }).withFailureHandler(handleError).deleteFinalizedObservation(obsId);
            }
        }

        function handleViewPdf(obsId) {
            showLoading('Retrieving PDF...');
            google.script.run.withSuccessHandler(res => {
                hideLoading();
                if (res.success) {
                    window.open(res.pdfUrl, '_blank');
                } else {
                    showError(res.error);
                }
            }).withFailureHandler(handleError).getObservationPdfUrl(obsId);
        }

        function handleRetryPdf(obsId) {
            if (confirm('This will attempt to regenerate the PDF for this observation. Continue?')) {
                showLoading('Requesting PDF regeneration...');
                _setPdfButtonState(obsId, 'generating');

                google.script.run.withSuccessHandler(res => {
                    hideLoading();
                    if (res.success) {
                        showToast('PDF regeneration started successfully!', true);
                        startPdfPolling(obsId);
                    } else {
                         showError('PDF regeneration failed: ' + res.error);
                         _setPdfButtonState(obsId, 'failed');
                    }
                }).withFailureHandler(error => {
                    handleError(error);
                    _setPdfButtonState(obsId, 'failed');
                }).regenerateObservationPdf(obsId);
            }
        }

        function toggleLookFors(componentId) {
            const content = document.getElementById(`lookForsContent-${componentId}`);
            const chevron = document.getElementById(`chevron-${componentId}`);

            if (content && chevron) {
                const isExpanded = content.classList.toggle('expanded');
                chevron.textContent = isExpanded ? '‚ñº' : '‚ñ∂';
                try {
                    if (!window.pageLoadInfo) return;
                    const storageKey = `lookForsState_${window.pageLoadInfo.cacheVersion}`;
                    const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');
                    allStates[componentId] = isExpanded;
                    sessionStorage.setItem(storageKey, JSON.stringify(allStates));
                } catch (e) {
                    console.warn('SessionStorage not available for look-fors state.');
                }
            }
        }

        function restoreLookForsState() {
            try {
                if (!window.pageLoadInfo) return;
                const storageKey = `lookForsState_${window.pageLoadInfo.cacheVersion}`;
                const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');

                for (const componentId in allStates) {
                    if (allStates[componentId] === true) {
                        const content = document.getElementById(`lookForsContent-${componentId}`);
                        const chevron = document.getElementById(`chevron-${componentId}`);
                        if (content && chevron) {
                            content.classList.add('expanded');
                            chevron.textContent = '‚ñº';
                        }
                    }
                }
            } catch (e) {
                console.warn('Could not restore look-fors state:', e);
            }
        }

        function goBackToObservations() {
            if (currentObservedUser.email && currentObservedUser.name) {
                displayObservationOptions(currentObservedUser.email, currentObservedUser.name);
            } else {
                showView('customFiltersView');
            }
        }

        function handleRubricData(result) {
            hideLoading();
            console.log('handleRubricData received:', result);
            
            if (!result.success) return showError(result.error);
            if (result.action === 'show_observation_selector') {
                currentObservedUser.email = result.observedEmail;
                currentObservedUser.name = result.observedName;
                hideStickyNav(); // Hide nav when going back to selector
                return displayObservationOptions(result.observedEmail, result.observedName);
            }
            
            if (result.action === 'redirect') {
                console.log('Processing redirect with params:', result.redirectParams);
                const url = new URL(window.location);
                Object.keys(result.redirectParams).forEach(key => {
                    url.searchParams.set(key, result.redirectParams[key]);
                });
                console.log('Redirecting to:', url.toString());
                window.location.href = url.toString();
                return;
            }
            
            if (result.action === 'show_html') {
                console.log('Processing show_html action - replacing page content');
                // Replace the entire page content with the generated HTML
                document.open();
                document.write(result.htmlContent);
                document.close();
                return;
            }

            const { observation, rubricData } = result;
            
            // Clear previous Quill instances and notes data before loading new observation
            if (observation) {
                console.log('Loading new observation data, ensuring clean state...');
                clearQuillInstances();
            }
            
            currentObservationId = observation ? observation.observationId : null;
            if (observation) {
                currentObservedUser.email = observation.observedEmail;
                currentObservedUser.name = observation.observedName;
                console.log('Observation context set:', { 
                    observationId: currentObservationId, 
                    observedUser: currentObservedUser 
                });
            }
            observationViewMode = (rubricData.userContext && rubricData.userContext.viewMode) || 'assigned';

            // Store rubricData globally for nav functions
            window.rubricData = rubricData;
            
            // Show sticky navigation when viewing rubric
            showStickyNav(observation);

            window.pageLoadInfo = {
                cacheVersion: rubricData.userContext ? rubricData.userContext.cacheVersion : 'unknown'
            };
            
            updateFilterStatus(rubricData, observation);
            const rubricHtml = generateInteractiveRubricHtml(rubricData, observation);
            document.getElementById('rubricContainer').innerHTML = rubricHtml;
            
            // Initialize notes data from observation if available
            if (observation && observation.observationData) {
                console.log('Loading observation notes data for', Object.keys(observation.observationData).length, 'components');
                Object.keys(observation.observationData).forEach(componentId => {
                    const componentData = observation.observationData[componentId];
                    if (componentData && componentData.notes) {
                        window.globalObservationNotes[componentId] = componentData.notes;
                        console.log(`Loaded notes for component ${componentId}`);
                    }
                });
                
                // Schedule recovery for components with notes data
                setTimeout(() => {
                    ensureEditorsForNotesData(rubricData.userContext.isEvaluator);
                }, 500);
            } else {
                console.log('No observation data to load');
            }
            
            // Show global tools bar for evaluators after DOM injection
            if (rubricData.userContext.isEvaluator) {
                updateComponentVisibility();
                
                // Show global tools bar after HTML is in the DOM
                const globalToolsBar = document.getElementById('globalToolsBar');
                if (globalToolsBar) {
                    globalToolsBar.style.display = 'block';
                }
            } else {
                // For read-only finalized observations, still need to apply component visibility
                // based on the assigned view mode
                updateComponentVisibility();
            }
            restoreLookForsState();
            showView('rubricContainer');
        }

        function generateInteractiveRubricHtml(data, observation) {
            const isEvaluator = data.userContext && data.userContext.isEvaluator;
            const isFinalized = observation && observation.status === 'Finalized';
            const isReadOnlyView = isFinalized && !isEvaluator;
            
            let html = `<div class="${isReadOnlyView ? 'finalized-view' : ''}" style="background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">`;

            // Header section - different for editing vs finalized viewing
            if (isEvaluator) {
                const today = new Date().toISOString().slice(0, 10);
                const defaultObsName = `${observation.observedName.split(' ').pop()}, ${observation.observedName.split(' ')[0]}_${today}`;
                html += `
                <div class="observation-metadata-editor">
                    <div class="filter-row">
                        <input type="text" id="observationName" class="filter-select" value="${escapeHtml(observation.observationName || defaultObsName)}" onchange="saveObservationMetadata()">
                        <input type="date" id="observationDate" class="filter-select" value="${escapeHtml(observation.observationDate || today)}" onchange="saveObservationMetadata()">
                    </div>
                </div>`;
            } else if (isReadOnlyView) {
                // Read-only header for finalized observations
                html += `
                <div class="finalized-observation-header">
                    <div class="finalized-status">
                        <span class="status-indicator">‚úÖ Finalized Observation</span>
                    </div>
                    <div class="observation-details">
                        <span class="obs-name">${escapeHtml(observation.observationName || 'Observation')}</span>
                        <span class="obs-date">${escapeHtml(observation.observationDate || '')}</span>
                    </div>
                </div>`;
            }

            // Global tools bar visibility will be handled after DOM injection

            html += `
            <div class="global-tools-bar" id="globalToolsBar" style="display: none;">
                <div class="global-tools-container">
                    <button class="global-tool-btn" id="recordAudioBtn" onclick="toggleAudioRecording()">
                        üé§ Record Audio
                    </button>
                    <button class="global-tool-btn" id="recordVideoBtn" onclick="toggleVideoRecording()">
                        üìπ Record Video
                    </button>
                    <button class="global-tool-btn" id="scriptEditorBtn" onclick="openScriptEditor()">
                        üìù Script Editor
                    </button>
                </div>
            </div>`;

            // Old navigation buttons removed - now handled by sticky nav

            data.domains.forEach((domain, domainIdx) => {
                html += `<div class="domain-section" id="domain-${domainIdx}"><div class="domain-header">${domain.name}</div>`;
                html += `<div class="performance-levels-header"><div class="performance-levels"><div class="level-header"></div><div class="level-header">Developing</div><div class="level-header">Basic</div><div class="level-header">Proficient</div><div class="level-header">Distinguished</div></div></div>`;
                domain.components.forEach((comp, compIdx) => {
                    const componentId = comp.componentId;
                    const isAssigned = comp.isAssigned || false;
                    const selectedProficiency = observation?.observationData?.[componentId]?.proficiency;
                    const evidence = observation?.evidenceLinks?.[componentId] || [];

                    html += `<div class="component-section ${isAssigned ? 'component-assigned' : 'component-not-assigned'}" data-component-id="${componentId}" data-is-assigned="${isAssigned}"><div class="performance-levels-content">`;
                    html += `<div class="row-label">${comp.title}</div>`;
                    ['developing', 'basic', 'proficient', 'distinguished'].forEach(level => {
                        const isSelected = selectedProficiency === level;
                        html += `<div class="level-content ${isEvaluator ? 'editable' : ''} ${isSelected ? 'selected' : ''}" data-level="${level}" onclick="${isEvaluator ? `selectProficiency(this, '${componentId}', '${level}')` : ''}">${comp[level] || ''}</div>`;
                    });
                    html += `</div>`;

                    // Look-fors section (collapsible blue header, directly below subdomain rows)
                    if (comp.bestPractices && comp.bestPractices.length > 0) {
                        const lookForsId = `domain-${domainIdx}-component-${compIdx}`;
                        html += `<div class="look-fors-section">`;
                        html += `<div class="look-fors-header" onclick="toggleLookFors('${lookForsId}')">`;
                        html += `<span>Best Practices aligned with 5D+ and PELSB Standards</span>`;
                        html += `<span class="chevron" id="chevron-${lookForsId}">‚ñ∂</span>`;
                        html += `</div>`;
                        html += `<div class="look-fors-content" id="lookForsContent-${lookForsId}">`;
                        html += `<div class="look-fors-grid">`;
                        comp.bestPractices.forEach((practice, practiceIdx) => {
                            const practiceId = `practice-${domainIdx}-${compIdx}-${practiceIdx}`;
                            const sanitizedPractice = escapeHtml(practice);
                            const onchangeHandler = isEvaluator ? `onchange="handleLookForChange(this, '${componentId}')"` : '';
                            
                            // Check if this practice is already selected in existing observation data
                            const existingLookfors = observation?.observationData?.[componentId]?.lookfors || [];
                            const isChecked = existingLookfors.includes(practice);
                            const checkedAttribute = isChecked ? 'checked' : '';
                            
                            html += `<div class="look-for-item">`;
                            html += `<input type="checkbox" id="${practiceId}" ${checkedAttribute} ${onchangeHandler}><label for="${practiceId}">${sanitizedPractice}</label>`;
                            html += `</div>`;
                        });
                        html += `</div></div></div>`;
                    }

                    // Notes & Evidence section (for evaluators only - contains notes editor and media upload)
                    // Check if we should show Notes & Evidence (for evaluators AND finalized observation viewing)
                    const hasObservationData = observation?.observationData?.[componentId];
                    const hasNotes = hasObservationData?.notes && hasObservationData.notes.trim() !== '' && hasObservationData.notes !== '<p><br></p>';
                    const hasEvidence = evidence && evidence.length > 0;
                    
                    if (isEvaluator || (isReadOnlyView && (hasNotes || hasEvidence))) {
                        html += `<div class="evidence-section ${isReadOnlyView ? 'readonly-evidence' : ''}">`;
                        html += `<div class="evidence-toggle-btn" onclick="toggleEvidenceSection('evidence-${componentId}')">`;
                        html += `<span>üìù Notes & Evidence</span>`;
                        html += `<span class="chevron" id="evidence-chevron-${componentId}">‚ñ∂</span>`;
                        html += `</div>`;
                        html += `<div class="evidence-content ${isReadOnlyView ? 'expanded' : ''}" id="evidence-${componentId}">`;
                        
                        // Notes container
                        const sanitizedComponentId = componentId.replace(/[^a-zA-Z0-9]/g, '');
                        html += `<div class="notes-container">`;
                        html += `<h4>Observation Notes</h4>`;
                        
                        if (isEvaluator) {
                            // Editable notes for evaluators
                            html += `<div class="notes-header-actions">`;
                            html += `<button class="clear-notes-btn" onclick="clearNotes('${componentId}')" title="Clear all notes for this component">üóëÔ∏è Clear All</button>`;
                            html += `</div>`;
                            html += `<div id="notes-editor-${sanitizedComponentId}"></div>`;
                        } else if (isReadOnlyView && hasNotes) {
                            // Read-only notes display for finalized observations
                            html += `<div class="readonly-notes-content">`;
                            html += hasObservationData.notes;
                            html += `</div>`;
                        } else if (isReadOnlyView) {
                            // No notes message for finalized observations
                            html += `<div class="no-notes-message">No observation notes recorded.</div>`;
                        }
                        
                        html += `</div>`;
                        
                        // Evidence section - different for editing vs viewing
                        if (hasEvidence || isEvaluator) {
                            let evidenceHtml = '';
                            evidence.forEach(item => { evidenceHtml += `<div class="evidence-item"><a href="${item.url}" target="_blank" rel="noopener noreferrer">${item.name}</a></div>`; });
                            
                            html += `<div class="media-upload-container">`;
                            
                            if (isEvaluator) {
                                // Editable evidence upload for evaluators
                                html += `<h4>Upload Evidence</h4>`;
                                html += `<input type="file" class="media-upload-input" id="media-upload-${componentId}" onchange="uploadSelectedFile('${componentId}')" style="display: none;">`;
                                html += `<button class="media-upload-button" onclick="triggerFileUpload('${componentId}')">üìé Select & Upload File</button>`;
                            } else {
                                // Read-only evidence for finalized observations
                                html += `<h4>Evidence Files</h4>`;
                            }
                            
                            html += `<div class="media-links-container" data-component-id="${componentId}">`;
                            html += `<ul>${evidenceHtml}</ul>`;
                            html += `</div></div>`;
                        }
                        
                        // Close evidence-content and evidence-section
                        html += `</div></div>`;
                    }
                    html += `</div>`;
                });
                html += `</div>`;
            });
            html += `</div>`;
            return html;
        }

        function updateFilterStatus(rubricData, observation) {
            const status = document.getElementById('filterStatus');
            
            if (observation) {
                // Hide status div completely when viewing observations - main heading provides context
                status.style.display = 'none';
                return;
            }
            
            // Keep existing logic for other contexts (role viewing, etc.)
            const statusText = document.getElementById('filterStatusText');
            let text = 'Viewing Your Own Rubric';
            if (rubricData?.userContext?.filterInfo) {
                text = `Viewing as: ${rubricData.userContext.filterInfo.viewingAs} (${rubricData.userContext.filterInfo.viewingRole}, Year ${rubricData.userContext.filterInfo.viewingYear})`;
            }
            statusText.innerHTML = text;
            status.style.display = 'block';
        }

        function saveObservationMetadata() {
            const obsId = currentObservationId;
            const newName = document.getElementById('observationName').value;
            const newDate = document.getElementById('observationDate').value;

            if (!obsId || !newName || !newDate) return;

            google.script.run
                .withSuccessHandler(res => {
                    if (res.success) {
                        showToast('Observation details saved.', true);
                    } else {
                        showError(res.error);
                    }
                })
                .withFailureHandler(handleError)
                .updateObservationMetadata(obsId, { observationName: newName, observationDate: newDate });
        }

        function selectProficiency(element, componentId, proficiency) {
            if (!currentObservationId || !componentId || !proficiency) {
                console.error('Missing data for proficiency selection:', { currentObservationId, componentId, proficiency });
                return;
            }

            const parentRow = element.closest('.performance-levels-content');
            const currentlySelected = parentRow.querySelector('.level-content.selected');

            // --- Instant UI Update ---
            if (currentlySelected) {
                currentlySelected.classList.remove('selected');
            }
            element.classList.add('selected');

            // --- Background Save ---
            google.script.run
                .withSuccessHandler(function(response) {
                    if (response.success) {
                        console.log('Proficiency saved:', { componentId, proficiency });
                        // Optionally show a subtle success indicator
                    } else {
                        console.error('Failed to save proficiency:', response.error);
                        // --- Revert UI on Failure ---
                        element.classList.remove('selected');
                        if (currentlySelected) {
                            currentlySelected.classList.add('selected');
                        }
                        showToast('Error saving selection: ' + response.error);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Server error saving proficiency:', error);
                    // --- Revert UI on Failure ---
                    element.classList.remove('selected');
                    if (currentlySelected) {
                        currentlySelected.classList.add('selected');
                    }
                    showToast('Server error: ' + error.message);
                })
                .saveProficiencySelection(currentObservationId, componentId, proficiency);
        }
        function uploadFile(fileInput, componentId) {
            const file = fileInput.files[0]; if (!file) return;
            const statusEl = document.getElementById(`upload-status-${componentId}`); statusEl.textContent = 'Uploading...';
            const reader = new FileReader();
            reader.onload = e => {
                const base64Data = e.target.result.split(',')[1];
                google.script.run.withSuccessHandler(result => {
                    if (result.success) {
                        statusEl.textContent = 'Upload complete.'; fileInput.value = '';
                        const listEl = document.getElementById(`evidence-list-${componentId}`);
                        listEl.innerHTML += `<div class="evidence-item"><a href="${result.fileUrl}" target="_blank">${result.fileName}</a></div>`;
                        setTimeout(() => { statusEl.textContent = 'Select another file?'; }, 3000);
                    } else { handleError(result); statusEl.textContent = 'Upload failed.'; }
                }).withFailureHandler(handleError).uploadMediaEvidence(currentObservationId, componentId, base64Data, file.name, file.type);
            };
            reader.readAsDataURL(file);
        }
        function toggleObservationView() { observationViewMode = observationViewMode === 'assigned' ? 'full' : 'assigned'; updateComponentVisibility(); }
        function updateComponentVisibility() {
            const components = document.querySelectorAll('.component-section');
            if (observationViewMode === 'assigned') {
                components.forEach(comp => { comp.style.display = comp.dataset.isAssigned === 'true' ? '' : 'none'; });
            } else {
                components.forEach(comp => { comp.style.display = ''; });
            }
        }
        
        // Global Quill management system - consolidated for both interfaces
        window.globalQuillInstances = window.globalQuillInstances || {};
        window.globalObservationNotes = window.globalObservationNotes || {};
        
        function toggleEvidenceSection(contentId) {
            console.log('toggleEvidenceSection called with:', contentId);
            
            // Validate observation context
            if (!currentObservationId) {
                console.warn('Cannot toggle evidence section: No active observation');
                showToast('No active observation - cannot edit evidence', false);
                return;
            }
            
            const content = document.getElementById(contentId);
            if (!content) {
                console.error('Evidence content element not found:', contentId);
                return;
            }
            console.log('Found evidence content element:', content);

            const isExpanded = content.classList.toggle('expanded');
            console.log('Evidence section expanded state:', isExpanded);
            const componentId = contentId.replace('evidence-', '');
            console.log('Component ID:', componentId);

            // Toggle chevron
            const chevron = document.getElementById(`evidence-chevron-${componentId}`);
            if (chevron) {
                chevron.textContent = isExpanded ? '‚ñº' : '‚ñ∂';
            }

            // Initialize Quill on first expansion if not already initialized
            if (isExpanded && !window.globalQuillInstances[componentId]) {
                console.log('Initializing Quill editor for component:', componentId);
                const success = initializeQuillEditor(componentId);
                if (!success) {
                    console.error('Failed to initialize Quill editor for component:', componentId);
                    showToast(`Failed to initialize text editor for ${componentId}`, false);
                }
            } else if (isExpanded) {
                console.log('Quill instance already exists for component:', componentId);
                
                // Validate existing instance is functional
                const existingEditor = window.globalQuillInstances[componentId];
                if (!existingEditor || !existingEditor.root) {
                    console.warn('Existing Quill instance appears broken, re-initializing...');
                    delete window.globalQuillInstances[componentId];
                    const success = initializeQuillEditor(componentId);
                    if (!success) {
                        console.error('Failed to re-initialize Quill editor for component:', componentId);
                        showToast(`Failed to initialize text editor for ${componentId}`, false);
                    }
                }
            }

            // Store state in sessionStorage for persistence
            try {
                const storageKey = 'evidenceState_' + (window.pageLoadInfo?.cacheVersion || 'default');
                const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');
                allStates[componentId] = isExpanded;
                sessionStorage.setItem(storageKey, JSON.stringify(allStates));
            } catch (e) {
                console.warn('Could not save evidence section state:', e);
            }
        }

        // Consolidated Quill initialization function - make globally available
        window.initializeQuillEditor = function(componentId) {
            console.log('Attempting to initialize Quill editor for:', componentId);
            
            // Validate observation context
            if (!currentObservationId) {
                console.warn(`Cannot initialize Quill editor for ${componentId}: No active observation`);
                return false;
            }
            
            const sanitizedComponentId = componentId.replace(/[^a-zA-Z0-9]/g, '');
            const editorId = 'notes-editor-' + sanitizedComponentId;
            const editorElement = document.getElementById(editorId);
            
            if (!editorElement) {
                console.error('Notes editor element not found:', editorId);
                return false;
            }

            // Check if this component already has a Quill instance in our global registry
            if (window.globalQuillInstances[componentId]) {
                const existingEditor = window.globalQuillInstances[componentId];
                console.log('Quill instance already exists in global registry for:', componentId);
                
                // Verify the existing editor is still valid and attached to the correct element
                if (existingEditor && existingEditor.root && existingEditor.root.parentNode === editorElement) {
                    // Load existing notes content if available and not already loaded
                    if (window.globalObservationNotes[componentId] && 
                        (!existingEditor.root.innerHTML || existingEditor.root.innerHTML === '<p><br></p>')) {
                        existingEditor.root.innerHTML = window.globalObservationNotes[componentId];
                        console.log('Loaded existing notes for component:', componentId);
                    }
                    return true;
                } else {
                    // Existing editor is invalid, clean it up
                    console.warn(`Cleaning up invalid Quill instance for ${componentId}`);
                    delete window.globalQuillInstances[componentId];
                }
            }

            // Check if DOM element already has a Quill instance (prevent duplicates)
            if (editorElement.__quill) {
                console.log('Quill already initialized on DOM element:', editorId);
                const existingEditor = editorElement.__quill;
                
                // Verify this editor is functional
                if (existingEditor && existingEditor.root) {
                    window.globalQuillInstances[componentId] = existingEditor;
                    
                    // Load existing notes content if available and not already loaded
                    if (window.globalObservationNotes[componentId] && 
                        (!existingEditor.root.innerHTML || existingEditor.root.innerHTML === '<p><br></p>')) {
                        existingEditor.root.innerHTML = window.globalObservationNotes[componentId];
                        console.log('Loaded existing notes for component:', componentId);
                    }
                    
                    // Ensure auto-save is set up (check if already has listeners to avoid duplicates)
                    if (!existingEditor._hasAutoSaveListener) {
                        let timeout;
                        existingEditor.on('text-change', () => {
                            clearTimeout(timeout);
                            timeout = setTimeout(() => {
                                saveNotes(componentId, existingEditor.root.innerHTML);
                            }, 1500);
                        });
                        existingEditor._hasAutoSaveListener = true;
                        console.log('Auto-save listener attached to existing editor for:', componentId);
                    }
                    
                    return true;
                } else {
                    // DOM element has broken Quill instance, clean it up
                    console.warn(`Cleaning up broken Quill instance on DOM element for ${componentId}`);
                    delete editorElement.__quill;
                }
            }
            
            console.log('Found editor element:', editorId);
            try {
                // Check if Quill is available
                if (typeof Quill === 'undefined') {
                    console.error('Quill library failed to load from CDN');
                    showToast('Rich text editor unavailable. Please refresh the page.');
                    return false;
                }
                
                const editor = new Quill(editorElement, {
                    theme: 'snow',
                    modules: {
                        toolbar: [
                            [{ 'header': [1, 2, false] }],
                            ['bold', 'italic', 'underline'],
                            [{'list': 'ordered'}, {'list': 'bullet'}],
                            ['clean']
                        ]
                    }
                });
                console.log('Quill editor created successfully');

                // Load existing notes 
                if (window.globalObservationNotes[componentId]) {
                    editor.root.innerHTML = window.globalObservationNotes[componentId];
                    console.log('Loaded existing notes for component:', componentId);
                }

                // Add debounced auto-save
                let timeout;
                editor.on('text-change', () => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        saveNotes(componentId, editor.root.innerHTML);
                    }, 1500); // Save 1.5 seconds after typing stops
                });
                editor._hasAutoSaveListener = true;

                window.globalQuillInstances[componentId] = editor;
                console.log('Quill editor initialized for component:', componentId);
                return true;
            } catch (error) {
                console.error('Error initializing Quill editor:', error);
                return false;
            }
        }
        
        function saveNotes(componentId, content) {
            if (!currentObservationId) {
                console.error('Cannot save notes: No observation context available.');
                showToast('Error: No active observation found. Cannot save notes.');
                return;
            }

            // Update local data using global storage
            window.globalObservationNotes[componentId] = content;

            google.script.run
                .withSuccessHandler(() => console.log(`Notes saved for ${componentId}`))
                .withFailureHandler(error => {
                    console.error('Failed to save notes:', error);
                    showToast('Error saving notes. Please check your connection.');
                })
                .saveObservationNotes(currentObservationId, componentId, content);
        }

        // Clear all notes for a specific component
        window.clearNotes = function(componentId) {
            if (!confirm(`Are you sure you want to clear all notes for this component?\n\nThis action cannot be undone.`)) {
                return;
            }

            const editor = window.globalQuillInstances[componentId];
            if (editor) {
                editor.setContents([], 'user'); // Clear content and trigger change event
                console.log(`Notes cleared for component: ${componentId}`);
                showToast(`Notes cleared for ${componentId}`, true);
                
                // Immediately save the cleared state
                window.globalObservationNotes[componentId] = '';
                saveNotes(componentId, '');
            } else {
                console.warn(`No editor found for component: ${componentId}`);
                showToast(`No notes to clear for ${componentId}`, false);
            }
        }

        // Recovery mechanism to ensure all components with notes data have editors
        function ensureEditorsForNotesData(isEvaluator) {
            if (!isEvaluator || !window.globalObservationNotes) {
                return;
            }
            
            console.log('Running recovery mechanism for orphaned notes data...');
            
            Object.keys(window.globalObservationNotes).forEach(componentId => {
                const notesContent = window.globalObservationNotes[componentId];
                if (notesContent && notesContent.trim() !== '' && notesContent !== '<p><br></p>') {
                    // Check if editor exists
                    if (!window.globalQuillInstances[componentId]) {
                        console.log(`Found orphaned notes data for ${componentId}, attempting to initialize editor...`);
                        
                        // Check if the evidence section exists but is collapsed
                        const evidenceSectionId = `evidence-${componentId}`;
                        const evidenceSection = document.getElementById(evidenceSectionId);
                        
                        if (evidenceSection) {
                            // Expand the section if collapsed
                            const content = document.getElementById(evidenceSectionId);
                            if (content && !content.classList.contains('expanded')) {
                                console.log(`Expanding collapsed section for ${componentId} to recover notes...`);
                                toggleEvidenceSection(evidenceSectionId);
                            }
                            
                            // Try to initialize the editor with a slight delay
                            setTimeout(() => {
                                if (!window.globalQuillInstances[componentId]) {
                                    console.log(`Force initializing editor for ${componentId}...`);
                                    const success = window.initializeQuillEditor(componentId);
                                    if (success) {
                                        console.log(`Successfully recovered notes editor for ${componentId}`);
                                    } else {
                                        console.warn(`Failed to recover notes editor for ${componentId}`);
                                    }
                                }
                            }, 200);
                        } else {
                            console.warn(`Evidence section not found for ${componentId}, cannot recover notes`);
                        }
                    } else {
                        // Editor exists, ensure content is loaded
                        const editor = window.globalQuillInstances[componentId];
                        if (editor && (!editor.root.innerHTML || editor.root.innerHTML === '<p><br></p>')) {
                            editor.root.innerHTML = notesContent;
                            console.log(`Restored content to existing editor for ${componentId}`);
                        }
                    }
                }
            });
        }

        function triggerFileUpload(componentId) {
            const fileInput = document.getElementById(`media-upload-${componentId}`);
            if (!fileInput) {
                console.error('File input not found for component:', componentId);
                return;
            }
            
            // Trigger the file picker
            fileInput.click();
        }

        function uploadSelectedFile(componentId) {
            const fileInput = document.getElementById(`media-upload-${componentId}`);
            if (!fileInput) {
                console.error('File input not found for component:', componentId);
                return;
            }

            const file = fileInput.files[0];
            if (!file) {
                return; // No file selected, user probably cancelled
            }

            if (!currentObservationId) {
                showToast('No observation selected. Please save the observation first.');
                return;
            }

            showToast('Uploading file...', false);

            // Convert file to base64 for Google Apps Script
            const reader = new FileReader();
            reader.onload = function(e) {
                const fileData = {
                    name: file.name,
                    mimeType: file.type,
                    content: e.target.result.split(',')[1], // Remove data:mime;base64, prefix
                    size: file.size
                };

                google.script.run
                    .withSuccessHandler(function(result) {
                        if (result.success) {
                            showToast('File uploaded successfully!', true);
                            updateMediaLinks(componentId, result.fileUrl, result.fileName);
                            fileInput.value = ''; // Clear the input
                        } else {
                            showToast('Upload failed: ' + result.error);
                        }
                    })
                    .withFailureHandler(function(error) {
                        console.error('Upload error:', error);
                        showToast('Upload failed. Please try again.');
                    })
                    .uploadMediaEvidence(currentObservationId, componentId, fileData.content, fileData.name, fileData.mimeType);
            };
            reader.onerror = function() {
                showToast('Error reading file. Please try again.');
            };
            reader.readAsDataURL(file);
        }

        function updateMediaLinks(componentId, fileUrl, fileName) {
            const linksContainer = document.querySelector(`[data-component-id="${componentId}"] ul`);
            if (linksContainer) {
                const listItem = document.createElement('li');
                listItem.className = 'evidence-item';
                listItem.innerHTML = `<a href="${fileUrl}" target="_blank">${fileName}</a>`;
                linksContainer.appendChild(listItem);
            }
        }
        
        function handleLookForChange(checkbox, componentId) {
            const lookForText = checkbox.nextElementSibling.textContent;
            const isChecked = checkbox.checked;

            if (!currentObservationId) {
                console.error('Cannot save look-for selection: Observation context not available.');
                checkbox.checked = !isChecked; // Revert the checkbox state
                showToast('Error: No active observation found. Cannot save selection.');
                return;
            }

            google.script.run
                .withSuccessHandler(() => {
                    console.log(`Saved look-for: ${componentId} -> ${lookForText}`);
                })
                .withFailureHandler(error => {
                    console.error('Save failed:', error);
                    checkbox.checked = !isChecked; // Revert the checkbox state on failure
                    showToast('Failed to save look-for selection. Please check your connection.');
                })
                .saveLookForSelection(currentObservationId, componentId, lookForText, isChecked);
        }
        
        // === New Sticky Navigation Functions ===
        
        function setViewMode(mode) {
            observationViewMode = mode;
            updateViewToggle();
            updateComponentVisibility();
        }
        
        function updateViewToggle() {
            const assignedToggle = document.getElementById('assignedToggle');
            const fullToggle = document.getElementById('fullToggle');
            const slider = document.getElementById('toggleSlider');
            
            if (!assignedToggle || !fullToggle || !slider) return;
            
            // Update active states
            assignedToggle.classList.toggle('active', observationViewMode === 'assigned');
            fullToggle.classList.toggle('active', observationViewMode === 'full');
            
            // Animate slider position
            const toggleWidth = assignedToggle.offsetWidth;
            if (observationViewMode === 'assigned') {
                slider.style.width = toggleWidth + 'px';
                slider.style.transform = 'translateX(0)';
            } else {
                slider.style.width = fullToggle.offsetWidth + 'px';
                slider.style.transform = `translateX(${toggleWidth}px)`;
            }
        }
        
        function showStickyNav(observation) {
            const stickyNav = document.getElementById('stickyNav');
            const viewToggle = document.getElementById('viewToggle');
            const staffContext = document.getElementById('staffContext');
            const staffName = document.getElementById('staffName');
            const navActions = document.getElementById('navActions');
            const finalizeBtn = document.getElementById('finalizeBtn');
            
            if (!stickyNav) return;
            
            stickyNav.classList.add('show');
            
            if (observation) {
                // Show staff context
                if (staffContext && staffName) {
                    staffName.textContent = observation.observedName || 'N/A';
                    staffContext.style.display = 'block';
                }
                
                // Show view toggle for evaluators
                if (viewToggle && window.rubricData?.userContext?.isEvaluator) {
                    viewToggle.style.display = 'flex';
                    updateViewToggle();
                }
                
                // Show action buttons for draft observations
                if (navActions && observation.status === 'Draft') {
                    navActions.style.display = 'flex';
                }
                
                // Update finalize button text based on status
                if (finalizeBtn) {
                    if (observation.status === 'Draft') {
                        finalizeBtn.textContent = '‚úÖ Finalize & Submit';
                        finalizeBtn.onclick = handleFinalizeFromNav;
                    } else {
                        finalizeBtn.style.display = 'none';
                    }
                }
            }
        }
        
        function hideStickyNav() {
            const stickyNav = document.getElementById('stickyNav');
            if (stickyNav) {
                stickyNav.classList.remove('show');
            }
        }
        
        
        // Update existing functions to work with new nav
        const originalToggleObservationView = toggleObservationView;
        toggleObservationView = function() {
            originalToggleObservationView();
            updateViewToggle();
        };

        const userContext = <?!= JSON.stringify(userContext) ?>;

        document.addEventListener('DOMContentLoaded', () => {
            if (userContext.role === 'Administrator') {
                showView('adminStaffListView');
                loadAdminStaffList();
            } else {
                showView('quickActionsView');
            }
        });

        function loadAdminStaffList() {
            showLoading('Loading staff list...');
            google.script.run
                .withSuccessHandler(populateAdminStaffList)
                .withFailureHandler(handleError)
                .getStaffListForDropdown(null, null);
        }

        function populateAdminStaffList(result) {
            hideLoading();
            if (!result.success) {
                showError(result.error);
                return;
            }

            const grid = document.getElementById('adminStaffGrid');
            grid.innerHTML = ''; // Clear existing content

            if (result.staff && result.staff.length > 0) {
                result.staff.forEach(staff => {
                    const card = document.createElement('div');
                    card.className = 'action-card';
                    card.onclick = () => displayObservationOptions(staff.email, staff.name);

                    const icon = document.createElement('span');
                    icon.className = 'action-icon';
                    icon.textContent = 'üë§';

                    const title = document.createElement('div');
                    title.className = 'action-title';
                    title.textContent = staff.name;

                    const desc = document.createElement('div');
                    desc.className = 'action-desc';
                    desc.textContent = `${staff.role}, Year ${staff.year}`;

                    card.appendChild(icon);
                    card.appendChild(title);
                    card.appendChild(desc);
                    grid.appendChild(card);
                });
            } else {
                const noStaffMessage = document.createElement('p');
                noStaffMessage.textContent = 'No staff members are currently in their summative year.';
                grid.appendChild(noStaffMessage);
            }
        }

        // Consolidated recording state management
        const recordingState = {
            audio: { recorder: null, stream: null, isRecording: false },
            video: { recorder: null, stream: null, isRecording: false }
        };

        // Recording configuration
        const recordingConfig = {
            audio: {
                constraints: { audio: true },
                buttonId: 'recordAudioBtn',
                startText: 'üõë Stop Audio',
                stopText: 'üé§ Record Audio',
                errorMessage: 'Error accessing microphone: '
            },
            video: {
                constraints: { video: true, audio: true },
                buttonId: 'recordVideoBtn', 
                startText: 'üõë Stop Video',
                stopText: 'üìπ Record Video',
                errorMessage: 'Error accessing camera: '
            }
        };

        async function toggleRecording(type) {
            const state = recordingState[type];
            const config = recordingConfig[type];
            const btn = document.getElementById(config.buttonId);

            if (!state.isRecording) {
                try {
                    state.stream = await navigator.mediaDevices.getUserMedia(config.constraints);
                    state.recorder = new MediaRecorder(state.stream);

                    const chunks = [];
                    state.recorder.ondataavailable = event => chunks.push(event.data);

                    state.recorder.onstop = () => {
                        const mimeType = type === 'audio' ? 'audio/webm' : 'video/webm';
                        const blob = new Blob(chunks, { type: mimeType });
                        uploadRecording(blob, type);
                    };

                    state.recorder.start();
                    state.isRecording = true;
                    btn.textContent = config.startText;
                    btn.classList.add('recording');

                } catch (error) {
                    showToast(config.errorMessage + error.message, false);
                }
            } else {
                state.recorder.stop();
                state.stream.getTracks().forEach(track => track.stop());
                state.isRecording = false;
                btn.textContent = config.stopText;
                btn.classList.remove('recording');
            }
        }

        // Wrapper functions for backwards compatibility
        async function toggleAudioRecording() {
            await toggleRecording('audio');
        }

        async function toggleVideoRecording() {
            await toggleRecording('video');
        }

        function uploadRecording(blob, type) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `${type}-recording-${timestamp}.webm`;

            // Convert blob to base64
            const reader = new FileReader();
            reader.onload = function() {
                const base64Data = reader.result.split(',')[1];

                google.script.run
                    .withSuccessHandler(function(result) {
                        if (result.success) {
                            showToast(`${type} recording saved successfully!`, true);
                            // Add to global recordings list
                            addGlobalRecording(result.fileUrl, filename, type);
                        } else {
                            showToast(`Error saving ${type} recording: ` + result.error, false);
                        }
                    })
                    .withFailureHandler(function(error) {
                        showToast(`Failed to save ${type} recording: ` + error.message, false);
                    })
                    .uploadGlobalRecording(currentObservationId, base64Data, filename, type);
            };
            reader.readAsDataURL(blob);
        }

        function addGlobalRecording(fileUrl, filename, type) {
            // Placeholder for now
            console.log(`Recording saved: ${type} at ${fileUrl} with name ${filename}`);
        }

        // === Observation State Management Functions ===
        
        /**
         * Clears all observation-related state to prevent cross-contamination between observations
         */
        function clearObservationState() {
            console.log('Clearing all observation state...');
            
            // Clear observation context
            currentObservationId = null;
            currentObservedUser = { email: null, name: null };
            
            // Clear script editor state
            clearScriptEditor();
            
            // Clear Quill editor instances and notes
            clearQuillInstances();
            
            // Clear any UI state
            resetObservationUI();
            
            console.log('Observation state cleared successfully');
        }
        
        /**
         * Clears script editor state and destroys the Quill instance
         */
        function clearScriptEditor() {
            console.log('Clearing script editor state...');
            
            // Clear auto-save timer
            if (scriptSaveDebounceTimer) {
                clearTimeout(scriptSaveDebounceTimer);
                scriptSaveDebounceTimer = null;
            }
            
            // Destroy Quill instance if it exists
            if (scriptQuill) {
                try {
                    console.log('Destroying existing script Quill instance...');
                    
                    // Remove all event listeners
                    scriptQuill.off('text-change');
                    
                    // Get container element before destroying Quill
                    const container = document.getElementById('scriptEditor');
                    
                    // Clear the editor content
                    scriptQuill.setContents([], 'silent');
                    
                    // More thorough destruction of Quill instance
                    if (typeof scriptQuill.destroy === 'function') {
                        scriptQuill.destroy();
                    }
                    
                    // Nullify the JavaScript reference
                    scriptQuill = null;
                    
                    // CRITICAL: Clean up DOM elements completely
                    if (container) {
                        console.log('Cleaning up script editor DOM...');
                        resetScriptEditorContainer();
                    }
                    
                } catch (error) {
                    console.warn('Error destroying script Quill instance:', error);
                    
                    // Emergency cleanup - force reset container even if Quill destruction failed
                    scriptQuill = null;
                    resetScriptEditorContainer();
                }
            }
            
            // Reset script state variables
            scriptContent = {};
            isScriptDirty = false;
            isSavingScript = false;
            
            // Reset UI state
            updateSaveButtonState();
            
            console.log('Script editor state cleared');
        }
        
        /**
         * Destroys all Quill editor instances and clears notes data
         */
        function clearQuillInstances() {
            console.log('Clearing all Quill instances and notes data...');
            
            // Destroy all existing Quill instances
            if (window.globalQuillInstances) {
                Object.keys(window.globalQuillInstances).forEach(componentId => {
                    const editor = window.globalQuillInstances[componentId];
                    if (editor && typeof editor.off === 'function') {
                        try {
                            // Remove all event listeners
                            editor.off('text-change');
                            // Clear the editor content
                            editor.setContents([], 'silent');
                            
                            // Clear the __quill reference from the DOM element
                            const editorElement = document.getElementById(`notesEditor-${componentId}`);
                            if (editorElement && editorElement.__quill) {
                                delete editorElement.__quill;
                            }
                        } catch (error) {
                            console.warn(`Error destroying Quill instance for ${componentId}:`, error);
                        }
                    }
                });
            }
            
            // Reset global storage objects
            window.globalQuillInstances = {};
            window.globalObservationNotes = {};
            
            console.log('All Quill instances and notes data cleared');
        }
        
        /**
         * Resets observation-related UI elements to default state
         */
        function resetObservationUI() {
            console.log('Resetting observation UI...');
            
            // Close script editor modal if open
            const scriptModal = document.getElementById('scriptEditorModal');
            if (scriptModal) {
                scriptModal.style.display = 'none';
            }
            
            // Reset any expanded evidence sections
            const evidenceSections = document.querySelectorAll('[id^="evidence-content-"]');
            evidenceSections.forEach(section => {
                section.style.display = 'none';
            });
            
            // Reset chevron indicators
            const chevrons = document.querySelectorAll('[id^="evidence-chevron-"]');
            chevrons.forEach(chevron => {
                chevron.textContent = '‚ñ∂';
            });
            
            // Clear any temporary UI states from sessionStorage related to evidence
            try {
                const storagePrefix = 'evidenceState_';
                Object.keys(sessionStorage).forEach(key => {
                    if (key.startsWith(storagePrefix)) {
                        sessionStorage.removeItem(key);
                    }
                });
            } catch (error) {
                console.warn('Error clearing evidence state from sessionStorage:', error);
            }
            
            console.log('Observation UI reset completed');
        }
        
        /**
         * Completely resets the script editor container to pristine state
         * This utility function ensures no leftover Quill DOM elements remain
         */
        function resetScriptEditorContainer() {
            console.log('Resetting script editor container to clean state...');
            
            const container = document.getElementById('scriptEditor');
            if (!container) {
                console.warn('Script editor container not found');
                return false;
            }
            
            try {
                // Remove all Quill-generated content
                container.innerHTML = '';
                
                // Reset all CSS classes (Quill adds classes like 'ql-container')
                container.className = '';
                
                // Remove any Quill-specific data attributes
                container.removeAttribute('data-quill');
                container.removeAttribute('contenteditable');
                
                // Remove any Quill-added inline styles
                container.removeAttribute('style');
                
                // Clear any remaining Quill references
                if (container.__quill) {
                    delete container.__quill;
                }
                
                console.log('Script editor container reset successfully');
                return true;
                
            } catch (error) {
                console.error('Error resetting script editor container:', error);
                
                // Emergency fallback - try to at least clear innerHTML
                try {
                    container.innerHTML = '';
                } catch (e) {
                    console.error('Emergency container reset also failed:', e);
                }
                return false;
            }
        }
        
        /**
         * Diagnostic function to detect and fix broken observation state
         */
        function diagnoseAndRecoverObservationState() {
            console.log('Running observation state diagnostics...');
            
            const issues = [];
            const fixes = [];
            
            // Check for orphaned currentObservationId without proper context
            if (currentObservationId && !currentObservedUser.email) {
                issues.push('currentObservationId set but no observed user context');
                currentObservationId = null;
                fixes.push('Cleared orphaned observation ID');
            }
            
            // Check for broken script editor state
            if (scriptQuill && !currentObservationId) {
                issues.push('Script editor exists but no observation context');
                clearScriptEditor();
                fixes.push('Cleared orphaned script editor');
            }
            
            // Check for leftover Quill DOM elements without corresponding JS instance
            const scriptContainer = document.getElementById('scriptEditor');
            if (scriptContainer && !scriptQuill) {
                const hasQuillElements = scriptContainer.querySelector('.ql-toolbar, .ql-container, .ql-editor');
                if (hasQuillElements) {
                    issues.push('Found orphaned Quill DOM elements in script editor');
                    resetScriptEditorContainer();
                    fixes.push('Cleaned up orphaned script editor DOM elements');
                }
            }
            
            // Check for broken Quill instances
            if (window.globalQuillInstances) {
                Object.keys(window.globalQuillInstances).forEach(componentId => {
                    const editor = window.globalQuillInstances[componentId];
                    if (!editor || !editor.root || !editor.root.parentNode) {
                        issues.push(`Broken Quill instance for component ${componentId}`);
                        delete window.globalQuillInstances[componentId];
                        fixes.push(`Removed broken Quill instance for ${componentId}`);
                    }
                });
            }
            
            // Check for notes data without observation context
            if (window.globalObservationNotes && !currentObservationId) {
                const notesCount = Object.keys(window.globalObservationNotes).length;
                if (notesCount > 0) {
                    issues.push(`${notesCount} orphaned notes entries without observation context`);
                    window.globalObservationNotes = {};
                    fixes.push('Cleared orphaned notes data');
                }
            }
            
            // Check for mismatched DOM and JS state
            const scriptModal = document.getElementById('scriptEditorModal');
            if (scriptModal && scriptModal.style.display !== 'none' && !scriptQuill) {
                issues.push('Script modal open but no Quill instance');
                scriptModal.style.display = 'none';
                fixes.push('Closed orphaned script modal');
            }
            
            if (issues.length > 0) {
                console.warn('Observation state issues detected:', issues);
                console.log('Applied fixes:', fixes);
                showToast(`Recovered from ${issues.length} state issue(s)`, true);
            } else {
                console.log('Observation state is healthy');
            }
            
            return { issues, fixes };
        }
        
        /**
         * Emergency state reset function for when things go really wrong
         */
        function emergencyStateReset() {
            console.warn('EMERGENCY: Performing complete state reset...');
            
            try {
                // Force clear all state
                currentObservationId = null;
                currentObservedUser = { email: null, name: null };
                
                // Destroy script editor
                if (scriptQuill) {
                    try {
                        scriptQuill.off('text-change');
                        scriptQuill = null;
                    } catch (e) {
                        console.warn('Error destroying script Quill:', e);
                        scriptQuill = null;
                    }
                }
                
                // Force clean script editor container
                resetScriptEditorContainer();
                
                scriptContent = {};
                isScriptDirty = false;
                isSavingScript = false;
                
                if (scriptSaveDebounceTimer) {
                    clearTimeout(scriptSaveDebounceTimer);
                    scriptSaveDebounceTimer = null;
                }
                
                // Destroy all Quill instances
                if (window.globalQuillInstances) {
                    Object.keys(window.globalQuillInstances).forEach(componentId => {
                        try {
                            const editor = window.globalQuillInstances[componentId];
                            if (editor && editor.off) {
                                editor.off('text-change');
                            }
                            const element = document.getElementById(`notesEditor-${componentId}`);
                            if (element && element.__quill) {
                                delete element.__quill;
                            }
                        } catch (e) {
                            console.warn(`Error cleaning up Quill for ${componentId}:`, e);
                        }
                    });
                }
                window.globalQuillInstances = {};
                window.globalObservationNotes = {};
                
                // Reset UI
                const scriptModal = document.getElementById('scriptEditorModal');
                if (scriptModal) {
                    scriptModal.style.display = 'none';
                }
                
                console.log('Emergency state reset completed');
                showToast('Emergency state reset completed', true);
                
            } catch (error) {
                console.error('Error during emergency reset:', error);
                showToast('Emergency reset encountered errors - please refresh page', false);
            }
        }
        
        // === Periodic State Monitoring ===
        
        let stateMonitorInterval = null;
        
        /**
         * Starts periodic monitoring of observation state
         */
        function startStateMonitoring() {
            if (stateMonitorInterval) {
                clearInterval(stateMonitorInterval);
            }
            
            stateMonitorInterval = setInterval(() => {
                try {
                    diagnoseAndRecoverObservationState();
                } catch (error) {
                    console.error('Error during state monitoring:', error);
                }
            }, 30000); // Check every 30 seconds
            
            console.log('State monitoring started');
        }
        
        /**
         * Stops periodic state monitoring
         */
        function stopStateMonitoring() {
            if (stateMonitorInterval) {
                clearInterval(stateMonitorInterval);
                stateMonitorInterval = null;
                console.log('State monitoring stopped');
            }
        }
        
        // Start monitoring when page loads
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                startStateMonitoring();
            }, 5000); // Start monitoring after 5 seconds
        });
        
        // === Debug and Testing Functions ===
        
        /**
         * Debug function to check script editor state and DOM
         * Can be called from browser console: window.debugScriptEditor()
         */
        window.debugScriptEditor = function() {
            const container = document.getElementById('scriptEditor');
            const result = {
                hasContainer: !!container,
                hasScriptQuill: !!scriptQuill,
                containerHTML: container ? container.innerHTML : null,
                containerClasses: container ? Array.from(container.classList) : null,
                quillToolbars: document.querySelectorAll('#scriptEditor .ql-toolbar').length,
                quillContainers: document.querySelectorAll('#scriptEditor .ql-container').length,
                quillEditors: document.querySelectorAll('#scriptEditor .ql-editor').length,
                containerAttributes: container ? Array.from(container.attributes).map(attr => `${attr.name}="${attr.value}"`) : null
            };
            
            console.log('Script Editor Debug Info:', result);
            
            if (result.quillToolbars > 1) {
                console.warn(`üö® TOOLBAR DUPLICATION DETECTED: ${result.quillToolbars} toolbars found!`);
            } else if (result.quillToolbars === 1) {
                console.log('‚úÖ Script editor state is clean (1 toolbar)');
            } else {
                console.log('‚ÑπÔ∏è No toolbars found (editor not initialized)');
            }
            
            return result;
        };
        
        /**
         * Test function to simulate opening/closing script editor multiple times
         * Can be called from browser console: window.testScriptEditorCleanup()
         */
        window.testScriptEditorCleanup = function(iterations = 3) {
            console.log(`üß™ Testing script editor cleanup ${iterations} times...`);
            
            if (!currentObservationId) {
                console.error('Cannot test: No active observation. Please load an observation first.');
                return;
            }
            
            for (let i = 0; i < iterations; i++) {
                console.log(`\n--- Test iteration ${i + 1} ---`);
                
                // Open script editor
                openScriptEditor();
                window.debugScriptEditor();
                
                // Close script editor
                closeScriptEditor();
                
                // Force clear to simulate observation switching
                clearScriptEditor();
                window.debugScriptEditor();
            }
            
            console.log('\nüèÅ Test completed. Check results above.');
        };
        
        // Stop monitoring when page unloads
        window.addEventListener('beforeunload', function() {
            stopStateMonitoring();
        });

        // === Script Editor Functions ===
        const SCRIPT_EDITOR_CONSTANTS = <?!= JSON.stringify(scriptEditorSettings) ?>;
        let scriptQuill = null;
        let scriptContent = {};
        const SILENT_SAVE_DEBOUNCE_MS = 5000;
        let isScriptDirty = false;
        let scriptSaveDebounceTimer;
        let isSavingScript = false;

        function updateSaveButtonState() {
            const saveBtn = document.getElementById('saveScriptBtn');
            if (!saveBtn) return;

            if (isScriptDirty) {
                saveBtn.textContent = 'Save all changes';
                saveBtn.disabled = false;
                saveBtn.classList.remove('btn-secondary');
                saveBtn.classList.add('btn-primary');
            } else {
                saveBtn.textContent = 'Saved!';
                saveBtn.disabled = true;
                saveBtn.classList.remove('btn-primary');
                saveBtn.classList.add('btn-secondary');
            }
        }

        function handleSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                showToast('Speech recognition is not supported in this browser.', false);
                return;
            }

            const recognition = new SpeechRecognition();
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            const sttButton = document.querySelector('.ql-stt-button');
            if (sttButton.classList.contains('recording')) {
                recognition.stop();
                return;
            }

            recognition.addEventListener('result', e => {
                const transcript = Array.from(e.results)
                    .map(result => result[0])
                    .map(result => result.transcript)
                    .join('');

                const range = scriptQuill.getSelection(true);
                scriptQuill.insertText(range.index, transcript + ' ', 'user');
            });

            recognition.addEventListener('end', () => {
                sttButton.classList.remove('recording');
                sttButton.innerHTML = 'üé§';
            });

            recognition.start();
            sttButton.classList.add('recording');
            sttButton.innerHTML = 'üõë';
        }

        function openScriptEditor() {
            // Validate observation context before opening
            if (!currentObservationId) {
                showToast('Cannot open script editor: No active observation', false);
                console.error('Cannot open script editor: No active observation context');
                return;
            }
            
            if (!currentObservedUser.email) {
                showToast('Cannot open script editor: Invalid observation context', false);
                console.error('Cannot open script editor: Invalid observed user context');
                return;
            }
            
            console.log('Opening script editor for observation:', currentObservationId);
            
            // Run diagnostics to check for any state issues
            diagnoseAndRecoverObservationState();
            
            const modal = document.getElementById('scriptEditorModal');
            const loadingOverlay = document.getElementById('scriptEditorLoadingOverlay');
            
            modal.style.display = 'flex';
            loadingOverlay.style.display = 'flex'; // Show loading overlay immediately

            // Disable existing Quill editor if it exists to prevent interaction during loading
            if (scriptQuill) {
                scriptQuill.disable();
            }

            // Clear any pending auto-save timer when opening editor
            clearTimeout(scriptSaveDebounceTimer);

            if (!scriptQuill) {
                // DEFENSIVE CHECK: Ensure container is clean before creating new Quill instance
                const container = document.getElementById('scriptEditor');
                if (!container) {
                    console.error('Script editor container not found');
                    showToast('Script editor container not found', false);
                    modal.style.display = 'none';
                    return;
                }
                
                // Check for leftover Quill elements that might cause toolbar duplication
                const hasQuillElements = container.querySelector('.ql-toolbar, .ql-container, .ql-editor');
                if (hasQuillElements) {
                    console.warn('Found leftover Quill elements in container, cleaning up...');
                    resetScriptEditorContainer();
                }
                
                // Additional check for any Quill-related classes or attributes
                if (container.classList.length > 0 || container.hasAttribute('data-quill')) {
                    console.warn('Container has Quill-related attributes, resetting...');
                    resetScriptEditorContainer();
                }
                
                try {
                    console.log('Creating new Quill instance on clean container...');
                    
                    const toolbarOptions = SCRIPT_EDITOR_CONSTANTS.TOOLBAR_OPTIONS;
                    toolbarOptions.push(['stt-button']);

                    // Initialize Quill editor using constants
                    scriptQuill = new Quill('#scriptEditor', {
                        theme: 'snow',
                        modules: {
                            toolbar: {
                                container: toolbarOptions,
                                handlers: {
                                    'stt-button': handleSpeechRecognition
                                }
                            }
                        }
                    });

                    // Add our custom button
                    document.querySelector('.ql-stt-button').innerHTML = 'üé§';


                    console.log('Script Quill editor initialized successfully');

                    // Load existing content for current observation
                    loadScriptContent();

                    // Auto-save on content change
                    scriptQuill.on('text-change', function(delta, oldDelta, source) {
                        if (source === 'user') {
                            isScriptDirty = true;
                            updateSaveButtonState();
                            clearTimeout(scriptSaveDebounceTimer);
                            scriptSaveDebounceTimer = setTimeout(() => {
                                silentSaveScriptContent();
                            }, SILENT_SAVE_DEBOUNCE_MS);
                        }
                    });
                    
                } catch (error) {
                    console.error('Error initializing script editor:', error);
                    
                    // If initialization fails, try emergency reset and retry ONCE
                    console.log('Attempting emergency reset and retry...');
                    resetScriptEditorContainer();
                    
                    try {
                        const toolbarOptions = SCRIPT_EDITOR_CONSTANTS.TOOLBAR_OPTIONS;
                        toolbarOptions.push(['stt-button']);
                        scriptQuill = new Quill('#scriptEditor', {
                            theme: 'snow',
                            modules: {
                                toolbar: {
                                    container: toolbarOptions,
                                    handlers: {
                                        'stt-button': handleSpeechRecognition
                                    }
                                }
                            }
                        });
                        document.querySelector('.ql-stt-button').innerHTML = 'üé§';

                        console.log('Script Quill editor initialized on retry');
                        loadScriptContent();
                        
                        // Auto-save on content change
                        scriptQuill.on('text-change', function(delta, oldDelta, source) {
                            if (source === 'user') {
                                isScriptDirty = true;
                                updateSaveButtonState();
                                clearTimeout(scriptSaveDebounceTimer);
                                scriptSaveDebounceTimer = setTimeout(() => {
                                    silentSaveScriptContent();
                                }, SILENT_SAVE_DEBOUNCE_MS);
                            }
                        });
                        
                    } catch (retryError) {
                        console.error('Script editor initialization failed even after reset:', retryError);
                        showToast('Failed to initialize script editor: ' + retryError.message, false);
                        modal.style.display = 'none';
                        return;
                    }
                }
            } else {
                // Ensure existing editor has the right content for current observation
                console.log('Reusing existing script editor, loading content for current observation');
                loadScriptContent();
            }
            
            isScriptDirty = false;
            updateSaveButtonState();
        }

        function closeScriptEditor() {
            if (isScriptDirty) {
                if (!confirm('You have unsaved changes that will be lost. Are you sure you want to close?')) {
                    return;
                }
            }
            // Clear any pending auto-save timer
            clearTimeout(scriptSaveDebounceTimer);
            const modal = document.getElementById('scriptEditorModal');
            modal.style.display = 'none';
            
            // Hide loading overlay if still visible
            hideScriptEditorLoading();
            
            isScriptDirty = false;
        }

        function manualSaveScriptContent() {
            if (!scriptQuill || !currentObservationId || isSavingScript) return;

            showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SAVING, false);
            saveScriptContent().then(success => {
                if (success) {
                    showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SAVED, true);
                }
            }).catch(error => {
                // Log errors, but don't show a toast as saveScriptContent already does.
                console.warn("Could not manually save script:", error.message);
            });
        }

        function silentSaveScriptContent() {
            if (!scriptQuill || !currentObservationId || !isScriptDirty || isSavingScript) return;
            console.log('Silently saving script content...');
            saveScriptContent().catch(error => {
                // Silent saves should not bother the user, so just log.
                console.warn("Could not silently save script:", error.message);
            });
        }

        function saveScriptContent() {
            return new Promise((resolve, reject) => {
                if (isSavingScript) {
                    reject(new Error('A save operation is already in progress.'));
                    return;
                }
                if (!scriptQuill || !currentObservationId) {
                    reject(new Error('Quill editor or observation ID is not available.'));
                    return;
                }

                isSavingScript = true;
                const content = scriptQuill.getContents();
                scriptContent = content; // Keep local copy

                google.script.run
                    .withSuccessHandler(function(result) {
                        isSavingScript = false;
                        if (result.success) {
                            isScriptDirty = false;
                            updateSaveButtonState();
                            resolve(true);
                        } else {
                            console.error('Failed to save script content:', result.error);
                            showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.ERROR_SAVING + result.error, false);
                            reject(new Error(result.error || 'Unknown save error'));
                        }
                    })
                    .withFailureHandler(function(error) {
                        isSavingScript = false;
                        console.error('Error saving script content:', error);
                        showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SERVER_ERROR + error.message, false);
                        reject(error);
                    })
                    .updateObservationScript(currentObservationId, content);
            });
        }

        function hideScriptEditorLoading() {
            const loadingOverlay = document.getElementById('scriptEditorLoadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
            
            // Re-enable the Quill editor
            if (scriptQuill) {
                scriptQuill.enable();
            }
        }

        function loadScriptContent() {
            if (!currentObservationId) {
                console.warn('Cannot load script content: currentObservationId is not set');
                hideScriptEditorLoading(); // Hide loading on error
                return;
            }
            
            // Validate that we have a valid observation context
            if (!currentObservedUser.email) {
                console.warn('Cannot load script content: No observed user context');
                hideScriptEditorLoading(); // Hide loading on error
                return;
            }
            
            console.log(`Loading script content for observation: ${currentObservationId}`);
            
            google.script.run
                .withSuccessHandler(function(content) {
                    // Double-check that we still have the same observation ID (prevent race conditions)
                    if (!scriptQuill || !currentObservationId) {
                        console.warn('Script editor or observation context lost during load');
                        return;
                    }
                    
                    console.log('Script content loaded successfully', { 
                        observationId: currentObservationId,
                        hasContent: !!(content && typeof content === 'object' && Object.keys(content).length > 0)
                    });
                    
                    if (content && typeof content === 'object' && Object.keys(content).length > 0) {
                        scriptQuill.setContents(content, 'silent');
                        scriptContent = content;
                    } else {
                        // Load empty content for new observations
                        scriptQuill.setContents([], 'silent');
                        scriptContent = {};
                    }
                    isScriptDirty = false;
                    updateSaveButtonState();
                    
                    // Hide loading overlay and re-enable editor
                    hideScriptEditorLoading();
                    
                    // Load component tags and restore highlighting AFTER content is loaded
                    // Small delay to ensure Quill content is fully processed
                    setTimeout(() => {
                        loadComponentTags();
                    }, 50);
                })
                .withFailureHandler(function(error) {
                    console.error('Error loading script content:', error);
                    showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.LOAD_ERROR + error.message, false);
                    
                    // Clear script editor on error to prevent showing wrong content
                    if (scriptQuill) {
                        scriptQuill.setContents([], 'silent');
                        scriptContent = {};
                        isScriptDirty = false;
                        updateSaveButtonState();
                    }
                    
                    // Hide loading overlay and re-enable editor even on error
                    hideScriptEditorLoading();
                })
                .getObservationScript(currentObservationId);
        }


        // === Component Tagging System ===
        let componentTags = {};
        const TAG_COLORS = {
            '1a:': '#e3f2fd', '1b:': '#f3e5f5', '1c:': '#e8f5e8', '1d:': '#fff3e0',
            '1e:': '#fce4ec', '1f:': '#e0f2f1', '2a:': '#e1f5fe', '2b:': '#f1f8e9',
            '2c:': '#fef7e0', '2d:': '#ede7f6', '2e:': '#fcf2ff', '3a:': '#e8eaf6',
            '3b:': '#f9fbe7', '3c:': '#fff8e1', '3d:': '#ffebee', '4a:': '#e0f7fa',
            '4b:': '#f0f4c3', '4c:': '#ffe0b2', '4d:': '#d1c4e9', '4e:': '#ffcdd2',
            '4f:': '#b2dfdb'
        };

        function populateComponentSelector() {
            const selector = document.getElementById('componentSelector');
            if (!selector) {
                console.warn('Component selector element not found');
                return;
            }
            
            // Check if rubric data is available (using the same source as the main rubric)
            if (window.rubricData && window.rubricData.domains && window.rubricData.domains.length > 0) {
                // Data is available, populate the selector
                selector.innerHTML = '<option value="">Select Component to Tag</option>';
                
                let hasComponents = false;
                window.rubricData.domains.forEach(domain => {
                    if (domain.components && domain.components.length > 0) {
                        domain.components.forEach(component => {
                            // Only show assigned components to match main rubric behavior
                            if (component.isAssigned) {
                                const option = document.createElement('option');
                                option.value = component.componentId;
                                option.textContent = `${domain.name}: ${component.title}`;
                                selector.appendChild(option);
                                hasComponents = true;
                            }
                        });
                    }
                });
                
                if (!hasComponents) {
                    selector.innerHTML = '<option value="">No components available</option>';
                    console.warn('Rubric data exists but contains no components');
                }
            } else {
                // Rubric data not available - this should not happen if called after rubric is loaded
                selector.innerHTML = '<option value="">Rubric data not loaded</option>';
                console.warn('Component selector called but rubric data not available:', {
                    hasWindow: typeof window !== 'undefined',
                    hasRubricData: !!window.rubricData,
                    hasDomains: window.rubricData && !!window.rubricData.domains,
                    domainsLength: window.rubricData && window.rubricData.domains ? window.rubricData.domains.length : 'N/A'
                });
            }
        }

        function tagSelectedText() {
            if (!scriptQuill) {
                showToast('Script editor not initialized', false);
                return;
            }
            
            const range = scriptQuill.getSelection();
            if (!range || range.length === 0) {
                showToast('Please select text to tag', false);
                return;
            }
            
            const componentId = document.getElementById('componentSelector').value;
            if (!componentId) {
                showToast('Please select a component', false);
                return;
            }
            
            // Get the selected text
            const selectedText = scriptQuill.getText(range.index, range.length);
            if (!selectedText.trim()) {
                showToast('Selected text is empty', false);
                return;
            }
            
            // Apply visual formatting to tagged text
            const tagColor = TAG_COLORS[componentId] || '#e3f2fd';
            scriptQuill.formatText(range.index, range.length, 'background', tagColor);
            scriptQuill.formatText(range.index, range.length, 'color', '#1565c0');
            
            // Store tag information
            const tagData = {
                componentId: componentId,
                start: range.index,
                length: range.length,
                text: selectedText.trim(),
                timestamp: new Date().toISOString(),
                color: tagColor
            };
            
            if (!componentTags[componentId]) {
                componentTags[componentId] = [];
            }
            componentTags[componentId].push(tagData);
            
            // Update status
            document.getElementById('tagStatus').textContent = 
                `Tagged "${selectedText.substring(0, 30)}${selectedText.length > 30 ? '...' : ''}" to ${componentId}`;
            
            // Save tags
            saveComponentTags();
            
            showToast('Text tagged successfully', true);
        }

        function pushTaggedToNotes() {
            const allTags = Object.keys(componentTags);
            if (allTags.length === 0) {
                showToast('No tagged evidence to push.', false);
                return;
            }

            let pushedCount = 0;
            allTags.forEach(componentId => {
                const tags = componentTags[componentId];
                if (tags && tags.length > 0) {
                    let notesEditor = window.globalQuillInstances && window.globalQuillInstances[componentId];
                    if (!notesEditor) {
                        const evidenceSectionId = `evidence-${componentId}`;
                        const evidenceSection = document.getElementById(evidenceSectionId);
                        if (evidenceSection) {
                            toggleEvidenceSection(evidenceSectionId);
                            const attemptPush = (retries = 8) => { // Increased retries
                                if (retries <= 0) {
                                    console.warn(`Could not initialize notes editor for ${componentId} after multiple attempts.`);
                                    showToast(`Could not push to ${componentId} notes - editor initialization failed`, false);
                                    return;
                                }
                                
                                // Try to force initialization if editor doesn't exist
                                if (!window.globalQuillInstances[componentId]) {
                                    console.log(`Attempting to force initialize editor for ${componentId}, retries left: ${retries}`);
                                    window.initializeQuillEditor(componentId);
                                }
                                
                                notesEditor = window.globalQuillInstances && window.globalQuillInstances[componentId];
                                if (notesEditor) {
                                    completePushToNotes(componentId, tags, notesEditor);
                                } else {
                                    setTimeout(() => attemptPush(retries - 1), 300); // Increased delay
                                }
                            };
                            attemptPush();
                        } else {
                            console.warn(`Evidence section not found for ${componentId}.`);
                            showToast(`Could not find notes section for ${componentId}`, false);
                        }
                    } else {
                        completePushToNotes(componentId, tags, notesEditor);
                    }
                    pushedCount++;
                }
            });

            if (pushedCount > 0) {
                showToast(`Pushed all tagged evidence to their respective notes sections.`, true);
                document.getElementById('tagStatus').textContent = `Pushed all tagged evidence to notes.`;
            } else {
                showToast('No tagged evidence to push.', false);
            }
        }
        
        function completePushToNotes(componentId, tags, notesEditor) {
            // Combine all tagged text for this component
            const taggedContent = tags.map(tag => tag.text).join('\n\n');
            
            // Get current notes content
            const currentContent = notesEditor.root.innerHTML;
            const separator = currentContent && currentContent !== '<p><br></p>' ? '\n\n' : '';
            const scriptHeader = '<p><strong>From Script:</strong></p>';
            const newContent = currentContent + separator + scriptHeader + '<p>' + taggedContent.replace(/\n/g, '</p><p>') + '</p>';
            
            // Update notes editor
            notesEditor.root.innerHTML = newContent;
            
            // Trigger save
            setTimeout(() => {
                const event = new Event('input', { bubbles: true });
                notesEditor.root.dispatchEvent(event);
            }, 100);
            
            document.getElementById('tagStatus').textContent = 
                `Pushed ${tags.length} tagged item(s) to ${componentId} notes`;
            
            showToast(`Tagged content added to ${componentId} notes`, true);
        }

        function clearComponentTags() {
            const componentId = document.getElementById('componentSelector').value;
            if (!componentId) {
                // Clear all tags
                if (confirm('Clear all component tags from the script?')) {
                    componentTags = {};
                    // Remove all formatting - this is a simplified approach
                    if (scriptQuill) {
                        const length = scriptQuill.getLength();
                        scriptQuill.removeFormat(0, length);
                    }
                    saveComponentTags();
                    document.getElementById('tagStatus').textContent = 'All tags cleared';
                    showToast('All tags cleared', true);
                }
            } else {
                // Clear tags for specific component
                if (componentTags[componentId] && componentTags[componentId].length > 0) {
                    if (confirm(`Clear all tags for component ${componentId}?`)) {
                        delete componentTags[componentId];
                        saveComponentTags();
                        document.getElementById('tagStatus').textContent = `Tags cleared for ${componentId}`;
                        showToast(`Tags cleared for ${componentId}`, true);
                    }
                }
            }
        }

        function saveComponentTags() {
            if (!currentObservationId) return;
            
            google.script.run
                .withSuccessHandler(function(result) {
                    if (result.success) {
                        console.log('Component tags saved successfully');
                    } else {
                        console.error('Failed to save component tags:', result.error);
                        showToast('Failed to save tags: ' + result.error, false);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Error saving component tags:', error);
                    showToast('Error saving tags: ' + error.message, false);
                })
                .saveComponentTags(currentObservationId, componentTags);
        }

        function loadComponentTags() {
            if (!currentObservationId) return;
            
            google.script.run
                .withSuccessHandler(function(tags) {
                    if (tags) {
                        componentTags = tags;
                        // Restore visual formatting for tagged text
                        restoreVisualHighlighting();
                        console.log('Component tags loaded:', componentTags);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Error loading component tags:', error);
                })
                .getComponentTags(currentObservationId);
        }

        function restoreVisualHighlighting() {
            if (!scriptQuill || !componentTags) {
                console.log('Cannot restore highlighting: missing scriptQuill or componentTags');
                return;
            }

            // Ensure Quill is ready and has content
            if (!scriptQuill.getLength || scriptQuill.getLength() <= 1) {
                console.log('Script editor has no content, skipping highlight restoration');
                return;
            }

            console.log('Restoring visual highlighting for tagged components...');
            const documentLength = scriptQuill.getLength() - 1; // Exclude final newline
            let restoredCount = 0;
            
            // Iterate through all component tags and restore their visual formatting
            Object.keys(componentTags).forEach(componentId => {
                const tags = componentTags[componentId];
                if (tags && Array.isArray(tags)) {
                    tags.forEach((tag, tagIndex) => {
                        if (tag.start !== undefined && tag.length !== undefined) {
                            // Validate tag position against document length
                            if (tag.start < 0 || tag.start >= documentLength || 
                                tag.start + tag.length > documentLength) {
                                console.warn(`Skipping invalid tag position for ${componentId}[${tagIndex}]: start=${tag.start}, length=${tag.length}, docLength=${documentLength}`);
                                return;
                            }
                            
                            const tagColor = tag.color || TAG_COLORS[componentId] || '#e3f2fd';
                            try {
                                // Apply the background color and text color formatting
                                scriptQuill.formatText(tag.start, tag.length, 'background', tagColor);
                                scriptQuill.formatText(tag.start, tag.length, 'color', '#1565c0');
                                restoredCount++;
                                console.log(`Restored highlighting for ${componentId}[${tagIndex}] at position ${tag.start}-${tag.start + tag.length}`);
                            } catch (error) {
                                console.warn(`Failed to restore highlighting for ${componentId}[${tagIndex}] at position ${tag.start}:`, error);
                            }
                        } else {
                            console.warn(`Invalid tag data for ${componentId}[${tagIndex}]:`, tag);
                        }
                    });
                }
            });
            
            console.log(`Visual highlighting restoration completed: ${restoredCount} tags restored`);
        }

        // Extend the openScriptEditor function to initialize component selector
        const originalOpenScriptEditor = openScriptEditor;
        openScriptEditor = function() {
            originalOpenScriptEditor();
            // Populate component selector immediately (no race condition)
            populateComponentSelector();
            // loadComponentTags() will be called after content loads to prevent race condition
        };
    </script>

    <!-- Loading Overlay -->
    <div class="loading" id="loading">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">Loading...</div>
        </div>
    </div>

    <!-- Script Editor Modal -->
    <div class="script-editor-modal" id="scriptEditorModal" style="display: none;">
        <div class="script-editor-container">
            <!-- Loading overlay -->
            <div class="script-editor-loading-overlay" id="scriptEditorLoadingOverlay" style="display: none;">
                <div class="script-editor-loading-spinner"></div>
                <div class="script-editor-loading-text">Loading script content...</div>
            </div>
            
            <div class="script-editor-header">
                <h2>Observation Script Editor</h2>
                <div class="script-editor-controls">
                    <button id="saveScriptBtn" class="btn-secondary" onclick="manualSaveScriptContent()" disabled>Saved!</button>
                    <button class="btn-secondary" onclick="closeScriptEditor()">Close</button>
                </div>
            </div>
            
            <!-- Component Tagging Toolbar -->
            <div class="script-tagging-toolbar">
                <div class="tagging-controls">
                    <select id="componentSelector" class="component-selector">
                        <option value="">Select Component to Tag</option>
                    </select>
                    <button class="btn-tag" onclick="tagSelectedText()">üè∑Ô∏è Tag Selection</button>
                    <button class="btn-push" onclick="pushTaggedToNotes()">‚û°Ô∏è Push Tagged to Notes</button>
                    <button class="btn-clear-tags" onclick="clearComponentTags()">üóëÔ∏è Clear Tags</button>
                </div>
                <div class="tag-status" id="tagStatus">
                    Select text and choose a component to create tags
                </div>
            </div>
            
            <div class="script-editor-content">
                <div id="scriptEditor"></div>
            </div>
        </div>
    </div>
</body>
</html>