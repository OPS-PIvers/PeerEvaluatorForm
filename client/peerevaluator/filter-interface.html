<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><?= userContext.role ?> - Select Rubric View</title>
    
    <!-- Content Security Policy - Allow framing from same origin and Google domains -->
    <meta http-equiv="Content-Security-Policy" content="frame-ancestors 'self' https://*.google.com;">
    
    <!-- Quill.js for rich text editing -->
    <link href="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.2/dist/quill.js"></script>
    <!-- Lame.js for MP3 encoding -->
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <style>
:root {
    --color-white: white;
    --color-text-default: #333;
    --color-bg-body: #f5f5f5;

    /* Greens for toggle button and assignments */
    --color-green-base: #10b981;
    --color-green-dark: #059669;
    --color-green-darker: #047857;
    --color-green-light-bg: #f0fdf4;

    /* Ambers for toggle button (assigned mode) and active filters */
    --color-amber-base: #f59e0b;
    --color-amber-dark: #d97706;
    --color-amber-darker: #b45309;
    --color-amber-light-bg: #fef3c7;
    --color-amber-text-dark: #92400e;

    /* Blues for filter status and select focus */
    --color-blue-base: #3b82f6;
    --color-blue-dark: #2563eb;
    --color-blue-light-bg: #dbeafe;
    --color-blue-text-dark: #1e40af;
    --color-blue-focus-shadow: rgba(59, 130, 246, 0.1);

    /* Grays for various UI elements */
    --color-gray-text: #4a5568;
    --color-gray-text-light: #374151;
    --color-gray-border-light: #d1d5db;
    --color-gray-border-medium: #e2e8f0;
    --color-gray-bg-light: #f8fafc;
    --color-gray-bg-medium: #6b7280;
    --color-gray-bg-dark: #4b5563;
    --color-gray-component-not-assigned-border: #e5e7eb;
    --color-gray-assignment-indicator-not-assigned-bg: #e5e7eb;
    --color-text-deemphasized: #718096;

    /* Reds for destructive actions */
    --color-red-base: #dc2626;
    --color-red-dark: #b91c1c;

    /* Oranges for processing states */
    --color-orange-base: #ea580c;
    --color-orange-dark: #c2410c;
    --color-orange-light: #fed7aa;
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg-body);
            padding: 20px;
            line-height: 1.6;
            color: var(--color-text-default);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--color-white);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header {
            background: linear-gradient(135deg, #4a5568, #2d3748);
            color: var(--color-white);
            padding: 40px 30px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 101;
            border-radius: 12px 12px 0 0;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .content {
            padding: 40px 30px;
        }

        /* Dashboard-specific styles */
        .quick-actions { margin-bottom: 40px; }
        .section-title {
            color: var(--color-gray-text);
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .action-card {
            background: var(--color-white);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        .action-card:hover {
            border-color: var(--color-blue-base);
            background: var(--color-gray-bg-light);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        .action-icon { font-size: 2.5rem; margin-bottom: 15px; display: block; }
        .action-title { font-weight: 600; color: var(--color-gray-text-light); font-size: 1.1rem; margin-bottom: 8px; }
        .action-desc { color: var(--color-text-deemphasized); font-size: 0.95rem; }

        /* Staff List Styles */
        .staff-filter-container {
            margin-bottom: 25px;
            display: flex;
            justify-content: center;
        }

        .filter-toggle-group {
            display: flex;
            background: var(--color-white);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 8px;
            overflow: hidden;
        }

        .filter-toggle-btn {
            padding: 12px 24px;
            background: var(--color-white);
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--color-gray-text-light);
            transition: all 0.2s ease;
            border-right: 1px solid var(--color-gray-border-medium);
        }

        .filter-toggle-btn:last-child {
            border-right: none;
        }

        .filter-toggle-btn:hover {
            background: var(--color-gray-bg-light);
            color: var(--color-blue-base);
        }

        .filter-toggle-btn.active {
            background: var(--color-blue-base);
            color: var(--color-white);
        }

        .staff-list-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .staff-list-item {
            background: var(--color-white);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .staff-list-item:hover {
            border-color: var(--color-blue-base);
            background: var(--color-gray-bg-light);
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .staff-item-main {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .staff-item-icon {
            font-size: 1.8rem;
            color: var(--color-blue-base);
        }

        .staff-item-info {
            display: flex;
            flex-direction: column;
        }

        .staff-item-name {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--color-gray-text-light);
            margin-bottom: 4px;
        }

        .staff-item-details {
            font-size: 0.9rem;
            color: var(--color-text-deemphasized);
        }

        .staff-item-year-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .staff-item-year-badge.tenured {
            background: var(--color-green-light);
            color: var(--color-green-dark);
            border: 1px solid var(--color-green-base);
        }

        .staff-item-year-badge.probationary {
            background: var(--color-orange-light);
            color: var(--color-orange-dark);
            border: 1px solid var(--color-orange-base);
        }

        /* Responsive adjustments for staff list */
        @media (max-width: 768px) {
            .staff-list-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
            }

            .staff-item-main {
                width: 100%;
            }

            .filter-toggle-btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
        }

        /* Filter controls */
        .custom-filters, .observation-selector {
            background: var(--color-gray-bg-light);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 12px;
            padding: 30px;
            display: none;
        }
        .filter-row { display: flex; gap: 15px; margin-bottom: 20px; align-items: center; flex-wrap: wrap; }
        .filter-select {
            padding: 12px 15px;
            border: 1px solid var(--color-gray-border-light);
            border-radius: 8px;
            font-size: 1rem;
            background: var(--color-white);
            transition: all 0.3s ease;
            flex: 1;
            min-width: 200px;
        }
        .filter-select:focus {
            outline: none;
            border-color: var(--color-blue-base);
            box-shadow: 0 0 0 3px var(--color-blue-focus-shadow);
        }
        .filter-btn {
            background: var(--color-blue-base);
            color: var(--color-white);
            border: 2px solid var(--color-blue-base);
            cursor: pointer;
            font-weight: 600;
            min-width: 140px;
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        .filter-btn:hover:not(:disabled) { background: #2c5aa0; border-color: #2c5aa0; }
        .filter-btn:disabled { background: #cbd5e0; border-color: #cbd5e0; cursor: not-allowed; }
        .btn-secondary { 
            background: var(--color-gray-bg-medium); 
            border: 2px solid var(--color-gray-bg-medium);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .btn-secondary:hover { 
            background: var(--color-gray-bg-dark); 
            border-color: var(--color-gray-bg-dark);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(75, 85, 99, 0.2);
        }
        
        .btn-primary {
            background: var(--color-blue-base);
            border: 2px solid var(--color-blue-base);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary:hover {
            background: var(--color-blue-dark);
            border-color: var(--color-blue-dark);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
        }

        /* Loading Overlay */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .loading-content {
            background: var(--color-white);
            color: var(--color-blue-text-dark);
            border: 2px solid var(--color-blue-base);
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            min-width: 300px;
        }
        .loading-spinner { 
            display: inline-block; 
            width: 40px; 
            height: 40px; 
            border: 4px solid rgba(59, 130, 246, 0.3); 
            border-radius: 50%; 
            border-top-color: var(--color-blue-base); 
            animation: spin 1s ease-in-out infinite; 
            margin-bottom: 15px; 
        }
        .loading-text {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--color-gray-text-light);
        }
        
        /* Error states */
        .error { text-align: center; padding: 40px; margin: 20px 0; border-radius: 12px; display: none; background: #fef2f2; color: #dc2626; border: 2px solid #fecaca; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Status badges and action buttons */
        .status-badge { display: inline-block; padding: 4px 10px; font-size: 0.8rem; font-weight: 600; border-radius: 9999px; }
        .status-draft { background-color: var(--color-amber-light-bg); color: var(--color-amber-text-dark); }
        .status-finalized { background-color: var(--color-green-light-bg); color: var(--color-green-darker); }
        .btn-edit { background: #3b82f6; border-color: #3b82f6; }
        .btn-edit:hover { background: #2563eb; border-color: #2563eb; }
        .btn-finalize { background: var(--color-green-base); border-color: var(--color-green-base); }
        .btn-finalize:hover { background: var(--color-green-dark); border-color: var(--color-green-dark); }
        .btn-delete { background: var(--color-red-base); border-color: var(--color-red-base); }
        .btn-delete:hover { background: var(--color-red-dark); border-color: var(--color-red-dark); }
        .btn-view { background: #3b82f6; border-color: #3b82f6; }
        .btn-view:hover { background: #2563eb; border-color: #2563eb; }
        .btn-export { background: var(--color-green-base); border-color: var(--color-green-base); }
        .btn-export:hover { background: var(--color-green-dark); border-color: var(--color-green-dark); }

        /* NEW LIST VIEW STYLES */
        .action-buttons-section {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .observation-filter-section {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        .observation-filter-toggle {
            display: flex;
            background: var(--color-white);
            border: 2px solid var(--color-gray-border-medium);
            border-radius: 8px;
            overflow: hidden;
        }

        .observation-filter-btn {
            padding: 10px 20px;
            background: var(--color-white);
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--color-gray-text-light);
            transition: all 0.2s ease;
            border-right: 1px solid var(--color-gray-border-medium);
        }

        .observation-filter-btn:last-child {
            border-right: none;
        }

        .observation-filter-btn.active {
            background: var(--color-blue-base);
            color: white;
        }

        .observation-filter-btn:hover:not(.active) {
            background: var(--color-gray-bg-light);
        }

        .observations-list-container {
            background: var(--color-white);
            border: 1px solid var(--color-gray-border-medium);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .observations-list-header {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr 2fr;
            gap: 20px;
            align-items: center;
            padding: 16px 20px;
            background: var(--color-gray-bg-light);
            border-bottom: 1px solid var(--color-gray-border-medium);
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--color-gray-text-light);
        }

        .observations-list-item {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr 2fr;
            gap: 20px;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--color-gray-border-light);
            transition: all 0.2s ease;
        }

        .observations-list-item:last-child {
            border-bottom: none;
        }

        .observations-list-item:hover {
            background: var(--color-gray-bg-light);
        }

        .obs-list-title {
            font-weight: 600;
            color: var(--color-gray-text-light);
            font-size: 1rem;
        }

        .obs-list-date {
            color: var(--color-text-deemphasized);
            font-size: 0.9rem;
        }

        .obs-list-type {
            color: var(--color-gray-text-light);
            font-size: 0.9rem;
        }

        .obs-list-status {
            display: flex;
            align-items: center;
        }

        .obs-list-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .obs-list-actions .filter-btn {
            padding: 6px 12px;
            font-size: 0.85rem;
            min-width: auto;
        }

        .empty-observations-message {
            padding: 40px 20px;
            text-align: center;
            color: var(--color-text-deemphasized);
            font-style: italic;
        }

        .observation-metadata-editor {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        /* Finalized Observation Header */
        .finalized-observation-header {
            padding: 12px 20px;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border-bottom: 1px solid #047857;
        }

        .finalized-status {
            margin-bottom: 4px;
        }

        .status-indicator {
            font-weight: 600;
            font-size: 0.85rem;
        }

        .observation-details {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .obs-name {
            font-weight: 600;
            font-size: 1.0rem;
        }

        .obs-date {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        /* Read-only Evidence Sections */
        .readonly-evidence .evidence-content {
            background: #f8fafc;
        }

        .readonly-notes-content {
            padding: 15px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            line-height: 1.6;
            color: #374151;
        }

        .no-notes-message {
            padding: 15px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            color: #6b7280;
            font-style: italic;
            text-align: center;
        }

        /* Read-only evidence sections use standard toggle styling */
        .readonly-evidence .evidence-content {
            border-left: 3px solid #10b981;
        }

        .global-tools-bar {
            background: var(--color-white);
            border-bottom: 2px solid var(--color-gray-border-medium);
            padding: 16px 24px;
            display: flex;
            justify-content: center;
        }

        .global-tools-container {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .global-tool-btn {
            background: var(--color-blue-base);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .global-tool-btn:hover {
            background: var(--color-blue-dark);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }
        
        .global-tool-btn:active {
            background: var(--color-blue-dark);
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
        }

        .global-tool-btn.recording {
            background: var(--color-red-base);
            animation: pulse 1.5s infinite;
        }

        .global-tool-btn.processing, .ql-stt-button.processing {
            background: var(--color-orange-base);
            animation: pulse 1.5s infinite;
        }

        .global-tool-btn.transcribe-btn {
            background: var(--color-amber-base);
            color: white;
        }

        .global-tool-btn.transcribe-btn:hover {
            background: var(--color-amber-dark);
        }

        .global-tool-btn.transcribe-btn.processing {
            background: var(--color-orange-base);
            animation: pulse 1.5s infinite;
        }

        .global-tool-btn.transcribe-btn:disabled {
            background: var(--color-gray-bg-medium);
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* Recording Timer Display Styling */
        .timer-display {
            margin: 8px 0;
            font-size: 0.9rem;
        }

        .recording-timer {
            background: var(--color-gray-bg-light);
            border: 1px solid var(--color-gray-border-light);
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            min-width: 200px;
        }

        .timer-info {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--color-text-main);
        }

        .timer-progress {
            background: var(--color-gray-bg-medium);
            border-radius: 3px;
            height: 6px;
            overflow: hidden;
        }

        .progress-bar {
            background: var(--color-green-base);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .timer-warning .recording-timer {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .timer-warning .timer-info {
            color: #856404;
        }

        .timer-warning .progress-bar {
            background: var(--color-red-base);
        }

        /* Speech-to-Text Button Styling */
        .ql-stt-button {
            background: var(--color-blue-base);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
            min-width: 32px;
            height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .ql-stt-button:hover {
            background: var(--color-blue-light);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .ql-stt-button:active {
            background: var(--color-blue-dark);
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
        }

        .ql-stt-button.recording {
            background: var(--color-red-base);
            animation: pulse 1.5s infinite;
        }

        .ql-stt-button.recording:hover {
            background: var(--color-red-light);
        }

        .ql-stt-button:disabled {
            background: var(--color-gray-light);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* PDF Button States */
        .btn-pdf-failed { 
            background: #f97316; 
            border-color: #f97316; 
            position: relative;
        }
        .btn-pdf-failed:hover { 
            background: #ea580c; 
            border-color: #ea580c; 
        }
        .btn-pdf-failed:before {
            content: "⚠️ ";
            margin-right: 4px;
        }
        
        .btn-pdf-missing { 
            background: #6b7280; 
            border-color: #6b7280; 
            position: relative;
        }
        .btn-pdf-missing:hover { 
            background: #4b5563; 
            border-color: #4b5563; 
        }
        .btn-pdf-missing:before {
            content: "📄 ";
            margin-right: 4px;
        }

        /* === Sticky Navigation Bar === */
        .sticky-nav {
            position: sticky;
            top: 0;
            z-index: 100;
            background: var(--color-white);
            border-bottom: 2px solid var(--color-gray-border-medium);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: none; /* Hidden by default, shown when viewing rubric */
        }

        .sticky-nav.show {
            display: flex;
        }

        .nav-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            gap: 24px;
        }

        .nav-section {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .nav-back {
            color: var(--color-blue-base);
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .nav-back:hover {
            background: var(--color-blue-light-bg);
            color: var(--color-blue-text-dark);
        }

        /* Professional Sliding Toggle */
        .view-toggle {
            display: flex;
            align-items: center;
            background: var(--color-gray-bg-light);
            border-radius: 8px;
            padding: 4px;
            border: 2px solid var(--color-gray-border-light);
            position: relative;
        }

        .toggle-option {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--color-gray-text);
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
            white-space: nowrap;
        }

        .toggle-option.active {
            color: var(--color-blue-text-dark);
        }

        .toggle-slider {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            background: var(--color-white);
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .staff-context {
            color: var(--color-gray-text);
            font-weight: 500;
            font-size: 0.9rem;
            padding: 8px 12px;
            background: var(--color-gray-bg-light);
            border-radius: 6px;
            border: 1px solid var(--color-gray-border-light);
        }

        .nav-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .nav-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            border: 2px solid;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }


        .nav-btn-finalize {
            background: var(--color-green-base);
            color: var(--color-white);
            border-color: var(--color-green-base);
        }

        .nav-btn-finalize:hover {
            background: var(--color-green-dark);
            border-color: var(--color-green-dark);
        }

        .role-badge {
            background: var(--color-blue-base);
            color: var(--color-white);
            border: 2px solid var(--color-blue-base);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            transition: all 0.2s ease;
        }

        /* === Rubric Styles (from rubric.html) === */
        .rubric-container { display: none; margin-top: 30px; }
        .domain-section { border-bottom: 3px solid var(--color-gray-border-medium); }
        .domain-header { background: linear-gradient(135deg, #7c9ac5, #5a82b8); color: white; padding: 15px 20px; font-size: 1.1rem; font-weight: 600; position: sticky; top: 76px; z-index: 50; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .component-section { border-bottom: 1px solid var(--color-gray-border-medium); position: relative; transition: background-color 0.2s; }
        .performance-levels-header { position: sticky; top: 132px; z-index: 40; background: white; border-bottom: 2px solid var(--color-gray-border-medium); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        
        /* Finalized View - Corrected Sticky Positioning */
        .finalized-view .domain-header { 
            top: 56px; /* Adjusted for sticky nav only (no global tools bar) */
        }
        
        .finalized-view .performance-levels-header {
            top: 112px; /* Domain header height + sticky nav */
        }
        .performance-levels { display: grid; grid-template-columns: 200px 1fr 1fr 1fr 1fr; min-height: 50px; }
        .performance-levels-content { display: grid; grid-template-columns: 200px 1fr 1fr 1fr 1fr; min-height: 120px; }
        .level-header { background: #e2e8f0; padding: 12px; font-weight: 600; text-align: center; border-bottom: 1px solid #cbd5e0; color: var(--color-gray-text); font-size: 0.9rem; }
        .level-content { padding: 20px; border-right: 1px solid var(--color-gray-border-medium); border-bottom: 1px solid var(--color-gray-border-medium); background: var(--color-white); color: var(--color-gray-text); font-size: 0.9rem; transition: background-color 0.2s; }
        .level-content:last-child { border-right: none; }
        .row-label { background: #64748b; padding: 20px; font-weight: 600; color: white; border-bottom: 1px solid var(--color-gray-border-medium); display: flex; align-items: center; font-size: 0.9rem; }

        /* Look-fors (Best Practices) */
        .look-fors-section { border-top: 1px solid var(--color-gray-border-medium); }
        .look-fors-header { background: linear-gradient(135deg, #3182ce, #2b77cb); color: white; padding: 10px 20px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-weight: 600; transition: background 0.3s ease; font-size: 0.85rem; }
        .look-fors-header:hover { background: linear-gradient(135deg, #2b77cb, #2c5aa0); }
        .chevron { transition: all 0.3s ease; font-size: 1rem; }
        .look-fors-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; background: var(--color-gray-bg-light); }
        .look-fors-content.expanded { max-height: 1000px; }
        .look-fors-grid { padding: 12px 20px; display: grid; grid-template-columns: 1fr; gap: 8px; }
        .look-for-item { display: flex; align-items: flex-start; gap: 8px; padding: 8px 12px; background: var(--color-white); border-radius: 4px; box-shadow: 0 1px 2px rgba(0,0,0,0.08); border-left: 3px solid var(--color-blue-base); }
        .look-for-item label { cursor: pointer; color: var(--color-gray-text); font-weight: 500; font-size: 0.85rem; line-height: 1.4; }

        /* Component Assignment & Highlighting */
        .component-section.component-assigned { border-left: 4px solid var(--color-green-base); background: var(--color-green-light-bg); }
        .component-section.component-not-assigned { border-left: 4px solid var(--color-gray-component-not-assigned-border); }
        .component-section.component-not-assigned .level-content { color: var(--color-text-deemphasized); }
        .component-section[data-assigned="true"]:hover { border-left-color: var(--color-green-dark); }
        .component-section:not([data-assigned="true"]):hover { border-left-color: var(--color-gray-border-light); background-color: var(--color-gray-bg-light); }
        .component-hidden { display: none; }
        
        /* Utility class for hiding elements completely */
        .hidden { display: none !important; }
        
        /* Interactive Rubric Styles */
        .level-content.editable { cursor: pointer; }
        .level-content.editable:hover { background-color: var(--color-blue-light-bg); }
        .level-content.selected { background-color: var(--color-blue-light-bg) !important; border: 2px solid var(--color-blue-base); font-weight: 600; color: var(--color-blue-text-dark); }

        /* Media Upload Styles */
        .media-upload-section { padding: 15px 20px; background-color: var(--color-gray-bg-light); border-top: 1px solid var(--color-gray-border-medium); }
        .media-upload-title { font-weight: 600; color: var(--color-gray-text); margin-bottom: 10px; font-size: 0.9rem; }
        .media-upload-area { display: flex; gap: 10px; align-items: center; }
        .media-upload-input { display: none; }
        .media-upload-label { background: var(--color-gray-bg-medium); color: white; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; transition: background-color 0.2s; }
        .media-upload-label:hover { background: var(--color-gray-bg-dark); }
        .upload-status { font-size: 0.85rem; color: var(--color-gray-text); font-style: italic; }
        .evidence-list { margin-top: 10px; padding-left: 20px; }
        .evidence-item { margin-bottom: 5px; font-size: 0.9rem; }
        .evidence-item a { color: var(--color-blue-base); text-decoration: none; }
        .evidence-item a:hover { text-decoration: underline; }

        /* View Toggle Button */
        .view-toggle-button {
            background-color: var(--color-gray-bg-light);
            border: 1px solid var(--color-gray-border-light);
            padding: 8px 16px;
            margin: 0 0 20px 0;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            color: var(--color-gray-text);
            transition: all 0.2s ease;
        }
        .view-toggle-button:hover { background-color: #dee2e6; border-color: #adb5bd; }
        .filter-status {
            background: var(--color-blue-light-bg);
            border: 1px solid var(--color-blue-base);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            color: var(--color-blue-text-dark);
            font-weight: 500;
            display: none;
        }

        /* Toast Notification Styles */
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--color-red-base);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 9999;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            font-weight: 500;
            max-width: 350px;
            word-wrap: break-word;
        }
        .toast-notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast-notification.success {
            background-color: var(--color-green-base);
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            .content { padding: 20px; }
            .actions-grid { grid-template-columns: 1fr; }
            .filter-row { flex-direction: column; align-items: stretch; }
            .filter-select, .filter-btn { min-width: auto; width: 100%; }
            .performance-levels, .performance-levels-content { grid-template-columns: 1fr; gap: 1px; }
            .level-header, .row-label, .level-content { border-right: none; padding: 15px; font-size: 0.9rem; }
            .toast-notification { top: 10px; right: 10px; left: 10px; right: 10px; max-width: none; }
            
            /* Responsive Navigation */
            .nav-container {
                flex-wrap: wrap;
                padding: 8px 16px;
                gap: 12px;
            }
            
            .nav-section {
                gap: 8px;
            }
            
            .nav-back {
                font-size: 0.8rem;
                padding: 6px 12px;
            }
            
            .toggle-option {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
            
            .staff-context {
                font-size: 0.8rem;
                padding: 6px 10px;
            }
            
            .nav-btn {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
            
            .role-badge {
                font-size: 0.75rem;
                padding: 6px 12px;
            }
        }

        /* Evidence Section Styles */
        .evidence-section {
            margin-top: 10px;
        }

        .evidence-toggle-btn {
            background: linear-gradient(135deg, #4a4a4a, #3a3a3a);
            color: white;
            border: none;
            padding: 10px 20px;
            width: 100%;
            text-align: left;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            transition: background 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .evidence-toggle-btn:hover {
            background: linear-gradient(135deg, #3a3a3a, #2a2a2a);
        }

        .evidence-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: #f8fafc;
        }

        .evidence-content.expanded {
            max-height: 800px;
        }

        .notes-container {
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .notes-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            display: inline-block;
        }

        .notes-header-actions {
            float: right;
            margin-top: -5px;
        }

        .clear-notes-btn {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .clear-notes-btn:hover {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(245, 101, 101, 0.3);
        }

        .clear-notes-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .look-fors-container {
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
        }

        .look-fors-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .look-fors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 8px;
        }

        .look-for-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
        }

        .look-for-item input[type="checkbox"] {
            margin-top: 2px;
            flex-shrink: 0;
        }

        .look-for-item label {
            font-size: 0.85rem;
            line-height: 1.4;
            cursor: pointer;
        }

        .media-upload-container {
            padding: 15px 20px;
        }

        .media-upload-container h4 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .media-upload-input {
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            width: 100%;
        }

        .media-upload-button {
            background: #3182ce;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .media-upload-button:hover {
            background: #2b77cb;
        }

        .media-links-container {
            margin-top: 10px;
        }

        .evidence-item {
            margin-bottom: 5px;
        }

        .evidence-item a {
            color: #3182ce;
            text-decoration: none;
            font-size: 0.85rem;
        }

        .evidence-item a:hover {
            text-decoration: underline;
        }

        /* Script Editor Modal Styles */
        .script-editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .script-editor-container {
            background: white;
            width: 95%;
            height: 90%;
            border-radius: 12px;
            position: relative;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .script-editor-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            border-radius: 12px;
        }

        .script-editor-loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        .script-editor-loading-text {
            color: #666;
            font-size: 16px;
            font-weight: 500;
        }

        .script-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 2px solid var(--color-gray-border-medium);
        }

        .script-editor-header h2 {
            font-size: 1.5rem;
            color: var(--color-gray-text-light);
        }

        .script-editor-controls {
            display: flex;
            gap: 12px;
        }

        .script-editor-controls .btn-primary {
            background-color: var(--color-green-base);
            border-color: var(--color-green-base);
            font-weight: 700;
            padding: 10px 20px;
        }

        .script-editor-controls .btn-primary:hover {
            background-color: var(--color-green-dark);
            border-color: var(--color-green-dark);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
        }
        
        .script-editor-controls .btn-secondary {
            padding: 10px 20px;
            font-weight: 500;
        }

        .script-editor-content {
            flex-grow: 1;
            padding: 0 24px 24px 24px;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Enable vertical scrolling within modal */
            overflow-x: hidden;
        }

        #scriptEditor {
            height: 100%;
            border: 1px solid var(--color-gray-border-light);
            border-radius: 6px;
            background-color: var(--color-white);
        }


        /* Script Editor Mode Toggle Styling */
        .script-editor-mode-toggle {
            display: flex;
            gap: 8px;
            margin: 12px 0;
            padding: 4px;
            background: #f3f4f6;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .mode-toggle-btn {
            flex: 1;
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            transition: all 0.2s ease;
        }

        .mode-toggle-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .mode-toggle-btn.active {
            background: white;
            color: #1f2937;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            border: 1px solid #d1d5db;
        }

        /* View-Only Mode Styling */
        .staff-responses-view-only {
            height: 100%;
            overflow-y: auto;
            padding: 16px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
        }

        .response-item {
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid #f3f4f6;
        }

        .response-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .response-question {
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
            font-size: 15px;
        }

        .response-answer {
            color: #4b5563;
            line-height: 1.6;
            font-size: 14px;
            white-space: pre-wrap;
        }

        /* Quill toolbar customization */
        .script-editor-toolbar {
            padding: 12px 0;
        }

        #scriptEditor .ql-editor {
            font-size: 16px;
            line-height: 1.6;
            color: var(--color-text-default);
            height: 100%;
        }

        /* Component Tagging System Styles */
        .script-tagging-toolbar {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-bottom: 2px solid #e2e8f0;
            padding: 12px 16px;
        }

        .tagging-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .component-selector {
            min-width: 200px;
            max-width: 300px;
            padding: 8px 12px;
            border: 2px solid #cbd5e0;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            color: var(--color-text-default);
            transition: all 0.2s ease;
        }

        .component-selector:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .btn-tag, .btn-push, .btn-clear-tags {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-tag {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-tag:hover {
            background: linear-gradient(135deg, #3182ce 0%, #2c5aa0 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(49, 130, 206, 0.3);
        }

        .btn-push {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-push:hover {
            background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(72, 187, 120, 0.3);
        }

        .btn-clear-tags {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
            border: 2px solid transparent;
        }

        .btn-clear-tags:hover {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(245, 101, 101, 0.3);
        }

        .tag-status {
            font-size: 12px;
            color: #4a5568;
            font-style: italic;
            padding: 4px 8px;
            background: #f7fafc;
            border-radius: 4px;
            border-left: 3px solid #4299e1;
        }

        /* Tagged content visual indicators */
        .script-editor-content .ql-editor [style*="background"] {
            position: relative;
            border-radius: 3px;
            padding: 1px 2px;
        }

        /* Component tag color legend (could be added later if needed) */
        .tag-legend {
            display: none; /* Hidden for now, but available for future use */
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        /* Responsive adjustments for tagging toolbar */
        @media (max-width: 768px) {
            .tagging-controls {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .component-selector {
                min-width: unset;
                max-width: unset;
            }
            
            .btn-tag, .btn-push, .btn-clear-tags {
                justify-content: center;
            }
        }

        /* Professional Welcome Modal Styles */
        .welcome-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s ease;
            padding: 20px;
            box-sizing: border-box;
        }

        .welcome-modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .welcome-modal {
            background: var(--color-white);
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: translateY(30px) scale(0.9);
            transition: all 0.4s ease;
        }

        .welcome-modal-overlay.show .welcome-modal {
            transform: translateY(0) scale(1);
        }

        .welcome-modal-header {
            background: linear-gradient(135deg, var(--color-blue-base), var(--color-blue-dark));
            color: var(--color-white);
            padding: 40px 30px 30px;
            text-align: center;
            position: relative;
        }

        .welcome-modal-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            display: block;
            animation: welcomeIconPulse 2s ease-in-out infinite;
        }

        @keyframes welcomeIconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .welcome-modal-header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .welcome-subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            font-weight: 400;
            margin: 0;
        }

        .welcome-modal-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            line-height: 1.6;
        }

        .welcome-section {
            margin-bottom: 30px;
        }

        .welcome-feature {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 25px;
            padding: 20px;
            background: var(--color-gray-bg-light);
            border-radius: 12px;
            border-left: 4px solid var(--color-blue-base);
            transition: all 0.3s ease;
        }

        .welcome-feature:hover {
            background: var(--color-blue-light-bg);
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.1);
        }

        .feature-icon {
            font-size: 2rem;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .feature-content h3 {
            color: var(--color-gray-text-light);
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .feature-content p {
            color: var(--color-gray-text);
            font-size: 0.95rem;
            margin: 0;
        }

        .welcome-commitment {
            background: linear-gradient(135deg, var(--color-green-light-bg), var(--color-blue-light-bg));
            border: 2px solid var(--color-green-base);
            border-radius: 12px;
            padding: 25px;
            text-align: center;
        }

        .welcome-commitment h3 {
            color: var(--color-green-darker);
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .welcome-commitment p {
            color: var(--color-gray-text-light);
            font-size: 1rem;
            margin: 0;
            font-style: italic;
        }

        .welcome-modal-footer {
            padding: 25px 30px;
            background: var(--color-gray-bg-light);
            border-top: 1px solid var(--color-gray-border-light);
            text-align: center;
        }

        .welcome-continue-btn {
            background: linear-gradient(135deg, var(--color-green-base), var(--color-green-dark));
            color: var(--color-white);
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
            min-width: 280px;
        }

        .welcome-continue-btn:hover {
            background: linear-gradient(135deg, var(--color-green-dark), var(--color-green-darker));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .welcome-continue-btn .btn-icon {
            font-size: 1.2rem;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .welcome-modal-overlay {
                padding: 15px;
            }
            
            .welcome-modal {
                max-width: 100%;
                border-radius: 12px;
            }
            
            .welcome-modal-header {
                padding: 30px 20px 25px;
            }
            
            .welcome-modal-header h1 {
                font-size: 1.5rem;
            }
            
            .welcome-subtitle {
                font-size: 1rem;
            }
            
            .welcome-modal-content {
                padding: 20px;
            }
            
            .welcome-feature {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .feature-icon {
                align-self: center;
            }
            
            .welcome-continue-btn {
                min-width: 250px;
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Professional Welcome Modal -->
    <div class="welcome-modal-overlay" id="welcomeModalOverlay">
        <div class="welcome-modal" id="welcomeModal">
            <div class="welcome-modal-header">
                <div class="welcome-modal-icon">🌟</div>
                <h1>Welcome to the Observation Resources Website</h1>
                <p class="welcome-subtitle">Your Professional Growth Journey Begins Here</p>
            </div>
            
            <div class="welcome-modal-content">
                <div class="welcome-section">
                    <div class="welcome-feature">
                        <span class="feature-icon">📈</span>
                        <div class="feature-content">
                            <h3>Continuous Professional Development</h3>
                            <p>This platform is designed to support your ongoing professional growth through reflective observation and evidence-based feedback. Every interaction is an opportunity to enhance your teaching practice.</p>
                        </div>
                    </div>
                    
                    <div class="welcome-feature">
                        <span class="feature-icon">🤝</span>
                        <div class="feature-content">
                            <h3>Collaborative Learning Environment</h3>
                            <p>Engage in meaningful peer observations and receive constructive feedback that supports your development. Our framework promotes collegiality and shared expertise among educational professionals.</p>
                        </div>
                    </div>
                    
                    <div class="welcome-feature">
                        <span class="feature-icon">🎯</span>
                        <div class="feature-content">
                            <h3>Evidence-Based Growth</h3>
                            <p>Utilize comprehensive rubrics and structured observation tools to identify strengths and areas for growth. Transform observations into actionable insights for improved student outcomes.</p>
                        </div>
                    </div>
                    
                    <div class="welcome-feature">
                        <span class="feature-icon">✨</span>
                        <div class="feature-content">
                            <h3>Inspiring Excellence</h3>
                            <p>This experience is designed to be supportive, inspiring, and focused on celebrating your professional journey. Every observation is a step toward educational excellence.</p>
                        </div>
                    </div>
                </div>
                
                <div class="welcome-commitment">
                    <h3>Our Commitment to You</h3>
                    <p>We are dedicated to providing a positive, growth-oriented experience that recognizes your professionalism and supports your continued development as an educator. This tool represents our investment in your success and the success of all learners in our community.</p>
                </div>
            </div>
            
            <div class="welcome-modal-footer">
                <button class="welcome-continue-btn" onclick="closeWelcomeModal()">
                    <span class="btn-icon">🚀</span>
                    Continue Growing in My Profession
                </button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <!-- Sticky Navigation Bar -->
        <nav class="sticky-nav" id="stickyNav">
            <div class="nav-container">
                <div class="nav-section">
                    <a href="#" class="nav-back" onclick="goBackToObservations(); return false;">
                        ← Back
                    </a>
                    
                    <div class="view-toggle" id="viewToggle" style="display: none;">
                        <div class="toggle-slider" id="toggleSlider"></div>
                        <button class="toggle-option active" id="assignedToggle" onclick="setViewMode('assigned')">
                            Assigned Subdomains
                        </button>
                        <button class="toggle-option" id="fullToggle" onclick="setViewMode('full')">
                            Full Rubric
                        </button>
                    </div>
                </div>
                
                <div class="staff-context" id="staffContext" style="display: none;">
                    Viewing: <span id="staffName">--</span>
                </div>
                
                <div class="nav-section">
                    <div class="nav-actions" id="navActions" style="display: none;">
                        <button class="nav-btn nav-btn-finalize" id="finalizeBtn" onclick="handleFinalizeFromNav()">
                            ✅ Finalize & Submit
                        </button>
                    </div>
                    
                    <div class="role-badge">
                        <?= userContext.role ?>
                    </div>
                </div>
            </div>
        </nav>

        <div class="header"><h1>👥 Observation Dashboard</h1><p>Select how you'd like to view rubric information</p></div>
        <div class="content">
            <div id="quickActionsView">
                <div class="quick-actions"><h2 class="section-title"><span>🎯</span> Quick Actions</h2>
                    <div class="actions-grid">
                        <? if (userContext.hasSpecialAccess) { ?>
                        <div class="action-card" onclick="showCustomFilters()"><span class="action-icon">🔍</span><div class="action-title">Find Staff & Start Observation</div><div class="action-desc">Filter by role, year, or specific staff member</div></div>
                        <? } ?>
                        <? if (userContext.specialRoleType === 'peer_evaluator' || userContext.specialRoleType === 'full_access') { ?>
                        <div class="action-card" onclick="loadMyOwnView()"><span class="action-icon">📋</span><div class="action-title">My Own Rubric</div><div class="action-desc">View your personal assigned areas</div></div>
                        <? } ?>
                    </div>
                </div>
            </div>
            <div class="custom-filters" id="adminStaffListView" style="display: none;">
                <h2 class="section-title"><span>👥</span> Summative Year Staff</h2>
                
                <!-- Filter Toggle Buttons -->
                <div class="staff-filter-container">
                    <div class="filter-toggle-group">
                        <button class="filter-toggle-btn active" data-filter="all" onclick="filterStaffList('all')">All</button>
                        <button class="filter-toggle-btn" data-filter="tenured" onclick="filterStaffList('tenured')">Tenured</button>
                        <button class="filter-toggle-btn" data-filter="probationary" onclick="filterStaffList('probationary')">Probationary</button>
                    </div>
                </div>
                
                <!-- Staff List Container -->
                <div class="staff-list-container" id="adminStaffList">
                    <!-- Staff list will be populated here -->
                </div>
            </div>
            <div class="custom-filters" id="customFiltersView">
                <h2 class="section-title"><span>🔍</span> Find Staff Member</h2>
                <div class="filter-row"><select id="roleSelect" class="filter-select" onchange="handleRoleChange()"><option value="">1. Select Role...</option><? for (var i = 0; i < availableRoles.length; i++) { ?><option value="<?= availableRoles[i] ?>"><?= availableRoles[i] ?></option><? } ?></select></div>
                <div class="filter-row"><select id="yearSelect" class="filter-select" style="display: none;" onchange="handleYearChange()"><option value="">2. Select Year...</option><? if (userContext.role === 'Administrator') { ?><option value="3">Year 3</option><option value="0">Probationary</option><? } else { ?><option value="1">Year 1</option><option value="2">Year 2</option><option value="3">Year 3</option><option value="0">Probationary</option><? } ?></select></div>
                <div class="filter-row"><select id="staffSelect" class="filter-select" style="display: none;" onchange="handleStaffChange()"><option value="">3. Select Staff Member...</option></select></div>
                <div class="filter-row"><button class="filter-btn" id="loadBtn" onclick="loadSelectedView()" disabled>📖 Select Staff</button><button class="filter-btn btn-secondary" onclick="clearFilters()">🗑️ Clear & Go Back</button></div>
            </div>
            <div class="observation-selector" id="observationSelectorView"></div>
            <div class="error" id="error"><div id="errorMessage"></div><button class="filter-btn btn-secondary" onclick="hideError()" style="margin-top: 15px;">Dismiss</button></div>
            <div class="filter-status" id="filterStatus"><strong>Currently Viewing:</strong> <span id="filterStatusText"></span></div>
            <div class="rubric-container" id="rubricContainer"></div>
        </div>
    </div>
    <div class="toast-notification" id="toastNotification"></div>
    <script>
        /**
         * Professional Welcome Modal Functions
         */
        
        // Show the welcome modal on page load (once per session)
        function showWelcomeModal() {
            // Check if modal has been shown this session
            if (sessionStorage.getItem('welcomeModalShown') === 'true') {
                return; // Don't show again this session
            }
            
            const overlay = document.getElementById('welcomeModalOverlay');
            if (overlay) {
                // Small delay to ensure page is fully loaded
                setTimeout(() => {
                    overlay.classList.add('show');
                    document.body.style.overflow = 'hidden'; // Prevent background scrolling
                }, 300);
            }
        }
        
        // Close the welcome modal
        function closeWelcomeModal() {
            const overlay = document.getElementById('welcomeModalOverlay');
            if (overlay) {
                overlay.classList.remove('show');
                document.body.style.overflow = ''; // Restore scrolling
                
                // Mark as shown for this session
                sessionStorage.setItem('welcomeModalShown', 'true');
                
                // Remove from DOM after animation completes
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 400);
            }
        }
        
        // Handle keyboard events for accessibility
        function handleModalKeydown(event) {
            if (event.key === 'Escape') {
                const overlay = document.getElementById('welcomeModalOverlay');
                if (overlay && overlay.classList.contains('show')) {
                    closeWelcomeModal();
                }
            }
        }
        
        // Initialize modal when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Add keyboard listener for escape key
            document.addEventListener('keydown', handleModalKeydown);
            
            // Show welcome modal after a brief delay
            showWelcomeModal();
            
            // Optional: Close modal if clicking outside (on overlay)
            const overlay = document.getElementById('welcomeModalOverlay');
            if (overlay) {
                overlay.addEventListener('click', function(event) {
                    // Only close if clicking directly on the overlay (not the modal content)
                    if (event.target === overlay) {
                        closeWelcomeModal();
                    }
                });
            }
        });

        /**
         * Escapes HTML entities in a string to prevent XSS and ensure safe HTML rendering.
         * This implementation matches the server-side Utils.js version for consistency.
         * @param {*} unsafe - The input to escape (will be converted to string if not already)
         * @returns {string} The escaped string with HTML entities replaced
         */
        function escapeHtml(unsafe) {
            // Handle null and undefined by returning empty string
            if (unsafe == null) {
                return '';
            }
            
            // Convert to string if not already a string
            const str = String(unsafe);
            
            // Define the character mapping for HTML entities
            const entityMap = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            };
            
            // Replace characters using the entity map
            return str.replace(/[&<>"']/g, function(match) {
                return entityMap[match];
            });
        }

        /**
         * Escapes characters in a string to ensure it's safe to use within a JavaScript
         * single-quoted string literal, such as in an onclick attribute.
         * @param {*} unsafe - The input to escape (will be converted to string if not already)
         * @returns {string} The escaped string, safe for JS string literals.
         */
        function escapeJsString(unsafe) {
            if (unsafe == null) {
                return '';
            }
            const str = String(unsafe);
            return str.replace(/[\\']/g, '\\$&')
                      .replace(/\n/g, '\\n')
                      .replace(/\r/g, '\\r');
        }

        function formatYearDisplay(year) {
            // Handle Probationary year (0 or 'Probationary')
            if (year === 0 || year === 'Probationary') {
                return 'Probationary';
            }
            
            // Handle null, undefined, or empty values
            if (year === null || year === undefined || year === '') {
                return 'N/A';
            }
            
            // Return the year as-is for valid numeric years (1, 2, 3)
            return year.toString();
        }

        function showLoading(message = 'Loading...') { 
            document.getElementById('loading-text').textContent = message; 
            document.getElementById('loading').style.display = 'flex'; 
            hideError(); 
        }
        function hideLoading() { document.getElementById('loading').style.display = 'none'; }
        function showError(error) { const msg = error.message || String(error); document.getElementById('errorMessage').textContent = msg; document.getElementById('error').style.display = 'block'; hideLoading(); }
        function hideError() { document.getElementById('error').style.display = 'none'; }
        function handleError(error) { console.error('AJAX Error:', error); showError(error); }

        function showToast(message, isSuccess = false, duration = 4000) {
            const toast = document.getElementById('toastNotification');
            toast.textContent = message;
            toast.className = 'toast-notification' + (isSuccess ? ' success' : '');
            toast.classList.add('show');
            setTimeout(function() {
                toast.classList.remove('show');
            }, duration);
        }

        let currentFilters = { role: null, year: null, staff: null };
        let currentObservationId = null;
        let observationViewMode = 'assigned';
        let currentObservedUser = { email: null, name: null };

        // Client-side cache for work product answers
        let workProductAnswersCache = new Map();

        // Helper function to clear work product answers cache
        function clearWorkProductAnswersCache() {
            workProductAnswersCache.clear();
            console.log('Work product answers cache cleared');
        }

        function showView(viewId) {
            stopAllPollers(); // Stop any running pollers when the view changes
            ['quickActionsView', 'customFiltersView', 'observationSelectorView', 'rubricContainer', 'adminStaffListView'].forEach(id => { 
                document.getElementById(id).style.display = 'none'; 
            }); 
            document.getElementById(viewId).style.display = 'block'; 
            
            const header = document.querySelector('.header');

            // Show/hide sticky nav and header based on view
            if (viewId === 'rubricContainer') {
                if (header) header.classList.add('hidden');
                // Nav will be shown by handleRubricData
            } else {
                if (header) header.classList.remove('hidden');
                hideStickyNav();
            }
        }
        function showCustomFilters() { showView('customFiltersView'); }
        function loadMyOwnView() { 
            console.log('loadMyOwnView called - making AJAX request');
            showLoading('Loading your assigned rubric...'); 
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .loadRubricData({ myOwnView: true }); 
        }

        function handleRoleChange() {
            const roleSelect = document.getElementById('roleSelect'); const yearSelect = document.getElementById('yearSelect'); currentFilters.role = roleSelect.value;
            yearSelect.value = ''; yearSelect.style.display = roleSelect.value ? 'block' : 'none'; handleYearChange();
        }
        function handleYearChange() {
            const yearSelect = document.getElementById('yearSelect'); const staffSelect = document.getElementById('staffSelect'); currentFilters.year = yearSelect.value;
            staffSelect.value = ''; staffSelect.style.display = yearSelect.value ? 'block' : 'none';
            if (yearSelect.value) { loadStaffOptions(); } else { handleStaffChange(); }
        }
        function handleStaffChange() { const staffSelect = document.getElementById('staffSelect'); currentFilters.staff = staffSelect.value; document.getElementById('loadBtn').disabled = !staffSelect.value; }
        function loadStaffOptions() {
            const staffSelect = document.getElementById('staffSelect'); staffSelect.innerHTML = '<option value="">Loading staff...</option>'; staffSelect.disabled = true;
            google.script.run.withSuccessHandler(populateStaffDropdown).withFailureHandler(handleError).getStaffListForDropdown(currentFilters.role, currentFilters.year);
        }
        function populateStaffDropdown(result) {
            const staffSelect = document.getElementById('staffSelect'); staffSelect.disabled = false;
            if (!result.success) { staffSelect.innerHTML = `<option value="">Error: ${result.error}</option>`; return; }
            staffSelect.innerHTML = '<option value="">3. Select Staff Member...</option>';
            if (result.staff?.length) {
                result.staff.forEach(staff => staffSelect.appendChild(new Option(staff.displayName, staff.email)));
            } else {
                staffSelect.appendChild(new Option('No staff found', '', true, true));
            }
        }
        function loadSelectedView() { if (!currentFilters.staff) return; showLoading('Loading...'); google.script.run.withSuccessHandler(handleRubricData).withFailureHandler(handleError).loadRubricData(currentFilters); }
        function clearFilters() { showView('quickActionsView'); hideError(); hideLoading(); document.getElementById('filterStatus').style.display = 'none'; }

        let activePollers = {};

        function _setPdfButtonState(observationId, state, pdfUrl = null) {
            const pdfButton = document.getElementById(`pdf-button-${observationId}`);
            if (!pdfButton) return;

            switch (state) {
                case 'generating':
                    pdfButton.textContent = 'Generating PDF...';
                    pdfButton.className = 'filter-btn btn-export btn-pdf-missing';
                    pdfButton.disabled = true;
                    pdfButton.onclick = null;
                    break;
                case 'ready':
                    pdfButton.textContent = 'View PDF';
                    pdfButton.className = 'filter-btn btn-export';
                    pdfButton.disabled = false;
                    pdfButton.onclick = () => window.open(pdfUrl, '_blank');
                    break;
                case 'failed':
                    pdfButton.textContent = 'Retry PDF';
                    pdfButton.className = 'filter-btn btn-export btn-pdf-failed';
                    pdfButton.disabled = false;
                    pdfButton.onclick = () => handleRetryPdf(observationId);
                    break;
            }
        }

        function startPdfPolling(observationId) {
            if (activePollers[observationId]) {
                console.log(`Polling already active for ${observationId}`);
                return;
            }

            console.log(`Starting PDF polling for ${observationId}`);
            const pollInterval = 5000; // 5 seconds
            const pollTimeout = 60000; // 60 seconds

            const intervalId = setInterval(() => {
                google.script.run
                    .withSuccessHandler(res => {
                        if (res.success) {
                            if (res.pdfUrl) {
                                console.log(`PDF found for ${observationId}`);
                                showToast('PDF is ready!', true);
                                _setPdfButtonState(observationId, 'ready', res.pdfUrl);
                                stopPdfPolling(observationId);
                            } else if (res.pdfStatus === 'failed') {
                                console.log(`PDF generation failed for ${observationId}`);
                                showToast('PDF generation failed. Please retry.', false);
                                _setPdfButtonState(observationId, 'failed');
                                stopPdfPolling(observationId);
                            }
                        } else {
                             console.warn(`Polling check failed for ${observationId}: ${res.error}`);
                        }
                    })
                    .withFailureHandler(err => {
                        console.error(`Polling error for ${observationId}:`, err);
                    })
                    .getObservationStatusAndPdfUrl(observationId);
            }, pollInterval);

            const timeoutId = setTimeout(() => {
                console.log(`Polling timed out for ${observationId}`);
                const pdfButton = document.getElementById(`pdf-button-${observationId}`);
                if (pdfButton && pdfButton.disabled) {
                     showToast('PDF generation is taking longer than expected. Please check back later or retry.', false);
                    _setPdfButtonState(observationId, 'failed');
                }
                stopPdfPolling(observationId);
            }, pollTimeout);

            activePollers[observationId] = { intervalId, timeoutId };
        }

        function stopPdfPolling(observationId) {
            if (activePollers[observationId]) {
                clearInterval(activePollers[observationId].intervalId);
                clearTimeout(activePollers[observationId].timeoutId);
                delete activePollers[observationId];
                console.log(`Stopped polling for ${observationId}`);
            }
        }

        function stopAllPollers() {
            Object.keys(activePollers).forEach(observationId => {
                stopPdfPolling(observationId);
            });
        }

        // Global variable to store current observations data for filtering
        let currentObservationsData = [];
        let currentObservationFilter = 'all';

        function renderObservationCards(result, observedEmail, observedName) {
            hideLoading();
            if (!result.success) return showError(result.error);

            // Store the observations data globally for filtering
            currentObservationsData = result.observations;

            const container = document.getElementById('observationSelectorView');
            const safeObservedNameHtml = escapeHtml(observedName);
            const safeObservedEmailJs = escapeJsString(observedEmail);

            // Action buttons section
            let actionButtonsHtml = `
                <div class="action-buttons-section">
                    <div class="action-card" onclick="handleNewObservation('${safeObservedEmailJs}')">
                        <span class="action-icon">➕</span>
                        <div class="action-title">Start New Observation</div>
                        <div class="action-desc">Begin a new evaluation for this staff member.</div>
                    </div>`;

            <? if (showWorkProductButton) { ?>
            actionButtonsHtml += `
                    <div class="action-card" onclick="handleNewWorkProductObservation('${safeObservedEmailJs}')">
                        <span class="action-icon">📋</span>
                        <div class="action-title">Create Work Product</div>
                        <div class="action-desc">Request reflective responses from this staff member.</div>
                    </div>`;
            <? } ?>

            actionButtonsHtml += `</div>`;

            // Filter toggle section
            const filterHtml = `
                <div class="observation-filter-section">
                    <div class="observation-filter-toggle">
                        <button class="observation-filter-btn active" data-filter="all" onclick="filterObservations('all')">All</button>
                        <button class="observation-filter-btn" data-filter="draft" onclick="filterObservations('draft')">Draft</button>
                        <button class="observation-filter-btn" data-filter="finalized" onclick="filterObservations('finalized')">Finalized</button>
                    </div>
                </div>`;

            // Generate the observations list
            const observationsListHtml = generateObservationsList(result.observations, observedEmail, observedName);

            // Back button
            const backButtonText = userContext.role === 'Administrator' ? 'Back to Staff List' : 'Back to Filters';
            const backButtonAction = userContext.role === 'Administrator' ? "showView('adminStaffListView')" : "showView('customFiltersView')";
            const backButtonHtml = `
                <div style="margin-top: 20px;">
                    <button class="filter-btn btn-secondary" onclick="${backButtonAction}">${backButtonText}</button>
                </div>`;

            container.innerHTML = `
                <h2 class="section-title"><span>📝</span> Observations for ${safeObservedNameHtml}</h2>
                ${actionButtonsHtml}
                ${filterHtml}
                <div id="observations-list-display">
                    ${observationsListHtml}
                </div>
                ${backButtonHtml}`;

            showView('observationSelectorView');
        }

        function generateObservationsList(observations, observedEmail, observedName) {
            const safeObservedEmailJs = escapeJsString(observedEmail);
            const safeObservedNameJs = escapeJsString(observedName);

            if (!observations || observations.length === 0) {
                return `<div class="observations-list-container">
                    <div class="empty-observations-message">No observations found for this staff member.</div>
                </div>`;
            }

            let listHtml = `
                <div class="observations-list-container">
                    <div class="observations-list-header">
                        <div>Title</div>
                        <div>Date</div>
                        <div>Type</div>
                        <div>Status</div>
                        <div>Actions</div>
                    </div>`;

            observations.forEach(obs => {
                const date = new Date(obs.createdAt).toLocaleDateString();
                const safeObsIdJs = escapeJsString(obs.observationId);
                const safeObsIdHtml = escapeHtml(obs.observationId);
                const safeStatusHtml = escapeHtml(obs.status);
                const safeTypeHtml = escapeHtml(obs.type || 'Standard');

                // Generate observation title
                let title = obs.observationName || `${obs.observedName} Observation`;
                const safeTitleHtml = escapeHtml(title);

                // Generate action buttons based on status
                let buttonsHtml = '';
                if (obs.status === 'Draft') {
                    buttonsHtml = `
                        <button class="filter-btn btn-edit" onclick="handleEditObservation('${safeObsIdJs}')">Edit</button>
                        <button class="filter-btn btn-finalize" onclick="handleFinalizeObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Finalize</button>
                        <button class="filter-btn btn-delete" onclick="handleDeleteObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Delete</button>`;
                } else if (obs.status === 'Finalized') {
                    let pdfButtonHtml = '';
                    if (obs.pdfUrl) {
                        pdfButtonHtml = `<button class="filter-btn btn-export" onclick="window.open('${escapeJsString(obs.pdfUrl)}', '_blank')">View PDF</button>`;
                    } else if (obs.pdfStatus === 'failed') {
                        pdfButtonHtml = `<button class="filter-btn btn-export btn-pdf-failed" id="pdf-button-${safeObsIdHtml}" onclick="handleRetryPdf('${safeObsIdJs}')">Retry PDF</button>`;
                    } else {
                        pdfButtonHtml = `<button class="filter-btn btn-export btn-pdf-missing" id="pdf-button-${safeObsIdHtml}" disabled>Generating PDF...</button>`;
                        setTimeout(() => startPdfPolling(obs.observationId), 100);
                    }

                    buttonsHtml = `
                        <button class="filter-btn btn-view" onclick="handleViewObservation('${safeObsIdJs}')">View</button>
                        ${pdfButtonHtml}
                        <button class="filter-btn btn-delete" onclick="handleDeleteFinalizedObservation('${safeObsIdJs}', '${safeObservedEmailJs}', '${safeObservedNameJs}')">Delete</button>`;
                }

                listHtml += `
                    <div class="observations-list-item" data-status="${obs.status.toLowerCase()}">
                        <div class="obs-list-title">${safeTitleHtml}</div>
                        <div class="obs-list-date">${date}</div>
                        <div class="obs-list-type">${safeTypeHtml}</div>
                        <div class="obs-list-status">
                            <div class="status-badge ${obs.status === 'Draft' ? 'status-draft' : 'status-finalized'}">${safeStatusHtml}</div>
                        </div>
                        <div class="obs-list-actions">
                            ${buttonsHtml}
                        </div>
                    </div>`;
            });

            listHtml += `</div>`;
            return listHtml;
        }

        function filterObservations(filter) {
            currentObservationFilter = filter;

            // Update active button state
            document.querySelectorAll('.observation-filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-filter') === filter);
            });

            // Filter observations
            let filteredObservations = currentObservationsData;
            if (filter === 'draft') {
                filteredObservations = currentObservationsData.filter(obs => obs.status === 'Draft');
            } else if (filter === 'finalized') {
                filteredObservations = currentObservationsData.filter(obs => obs.status === 'Finalized');
            }

            // Re-render the observations list
            const listDisplay = document.getElementById('observations-list-display');
            if (listDisplay) {
                listDisplay.innerHTML = generateObservationsList(filteredObservations, currentObservedUser.email, currentObservedUser.name);
            }
        }

        function displayObservationOptions(observedEmail, observedName) {
            currentObservedUser.email = observedEmail;
            currentObservedUser.name = observedName;
            
            
            showLoading(`Loading options for ${observedName}`);
            google.script.run
                .withSuccessHandler(result => {
                    renderObservationCards(result, observedEmail, observedName);
                })
                .withFailureHandler(handleError)
                .getObservationOptions(observedEmail);
        }

        function handleNewObservation(observedEmail) {
            console.log('Starting new observation for:', observedEmail);

            // Clear all existing observation state before creating new observation
            clearObservationState();

            showLoading('Creating new observation draft...');
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .createNewObservationForEvaluator(observedEmail);
        }

        function handleNewWorkProductObservation(observedEmail) {
            console.log('Starting new work product observation for:', observedEmail);
            clearObservationState();
            showLoading('Creating work product observation...');
            google.script.run
              .withSuccessHandler(handleRubricData)
              .withFailureHandler(handleError)
              .createWorkProductObservationForEvaluator(observedEmail);
        }
        function handleEditObservation(obsId) { 
            console.log('Loading observation for editing:', obsId);
            
            // Clear all existing observation state before loading different observation
            clearObservationState();
            
            showLoading('Loading observation...'); 
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .loadObservationForEditing(obsId); 
        }
        function handleDeleteObservation(obsId, email, name) { if (confirm('Are you sure you want to delete this draft? This cannot be undone.')) { showLoading('Deleting draft...'); google.script.run.withSuccessHandler(res => { if(res.success) { displayObservationOptions(email, name); } else { showError(res.error); } }).withFailureHandler(handleError).deleteObservation(obsId); } }

        function handleFinalizeObservation(obsId, email, name) {
            if (confirm('Are you sure you want to finalize this observation? You will not be able to edit it further.')) {
                showLoading('Finalizing observation, please wait...');
                google.script.run
                    .withSuccessHandler(res => {
                        hideLoading();
                        if (res.success) {
                            showToast('Observation finalized. Generating PDF...', true);
                            // Refresh the view to show the "Generating..." button
                            displayObservationOptions(email, name);
                        } else {
                            showError(res.error);
                        }
                    })
                    .withFailureHandler(handleError)
                    .finalizeObservation(obsId);
            }
        }

        function handleFinalizeFromNav() {
            if (!currentObservationId || !currentObservedUser.email || !currentObservedUser.name) {
                showError('Unable to finalize: Missing observation context.');
                return;
            }
            
            if (confirm('Are you sure you want to finalize this observation? You will not be able to edit it further.')) {
                showLoading('Finalizing observation, please wait...');
                google.script.run
                    .withSuccessHandler(res => {
                        hideLoading();
                        if (res.success) {
                            showToast('Observation finalized. Generating PDF...', true);
                            // Navigate back to observation list
                            displayObservationOptions(currentObservedUser.email, currentObservedUser.name);
                        } else {
                            showError(res.error);
                        }
                    })
                    .withFailureHandler(handleError)
                    .finalizeObservation(currentObservationId);
            }
        }

        function handleViewObservation(obsId) {
            console.log('Loading finalized observation for viewing:', obsId);
            
            // Clear all existing observation state before loading different observation
            clearObservationState();
            
            showLoading('Loading observation...');
            google.script.run
                .withSuccessHandler(handleRubricData)
                .withFailureHandler(handleError)
                .loadFinalizedObservationForViewing(obsId);
        }

        function handleDeleteFinalizedObservation(obsId, email, name) {
            if (confirm('Are you sure you want to PERMANENTLY DELETE this finalized observation? This action cannot be undone.')) {
                showLoading('Deleting observation...');
                google.script.run.withSuccessHandler(res => {
                    if(res.success) {
                        displayObservationOptions(email, name);
                    } else {
                        showError(res.error);
                    }
                }).withFailureHandler(handleError).deleteFinalizedObservation(obsId);
            }
        }

        function handleViewPdf(obsId) {
            showLoading('Retrieving PDF...');
            google.script.run.withSuccessHandler(res => {
                hideLoading();
                if (res.success) {
                    window.open(res.pdfUrl, '_blank');
                } else {
                    showError(res.error);
                }
            }).withFailureHandler(handleError).getObservationPdfUrl(obsId);
        }

        function handleRetryPdf(obsId) {
            if (confirm('This will attempt to regenerate the PDF for this observation. Continue?')) {
                showLoading('Requesting PDF regeneration...');
                _setPdfButtonState(obsId, 'generating');

                google.script.run.withSuccessHandler(res => {
                    hideLoading();
                    if (res.success) {
                        showToast('PDF regeneration started successfully!', true);
                        startPdfPolling(obsId);
                    } else {
                         showError('PDF regeneration failed: ' + res.error);
                         _setPdfButtonState(obsId, 'failed');
                    }
                }).withFailureHandler(error => {
                    handleError(error);
                    _setPdfButtonState(obsId, 'failed');
                }).regenerateObservationPdf(obsId);
            }
        }

        function toggleLookFors(componentId) {
            const content = document.getElementById(`lookForsContent-${componentId}`);
            const chevron = document.getElementById(`chevron-${componentId}`);

            if (content && chevron) {
                const isExpanded = content.classList.toggle('expanded');
                chevron.textContent = isExpanded ? '▼' : '▶';
                try {
                    if (!window.pageLoadInfo) return;
                    const storageKey = `lookForsState_${window.pageLoadInfo.cacheVersion}`;
                    const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');
                    allStates[componentId] = isExpanded;
                    sessionStorage.setItem(storageKey, JSON.stringify(allStates));
                } catch (e) {
                    console.warn('SessionStorage not available for look-fors state.');
                }
            }
        }

        function restoreLookForsState() {
            try {
                if (!window.pageLoadInfo) return;
                const storageKey = `lookForsState_${window.pageLoadInfo.cacheVersion}`;
                const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');

                for (const componentId in allStates) {
                    if (allStates[componentId] === true) {
                        const content = document.getElementById(`lookForsContent-${componentId}`);
                        const chevron = document.getElementById(`chevron-${componentId}`);
                        if (content && chevron) {
                            content.classList.add('expanded');
                            chevron.textContent = '▼';
                        }
                    }
                }
            } catch (e) {
                console.warn('Could not restore look-fors state:', e);
            }
        }

        function goBackToObservations() {
            if (currentObservedUser.email && currentObservedUser.name) {
                displayObservationOptions(currentObservedUser.email, currentObservedUser.name);
            } else {
                // Return to appropriate view based on user role
                if (userContext.role === 'Administrator') {
                    showView('adminStaffListView');
                } else {
                    showView('customFiltersView');
                }
            }
        }

        function handleRubricData(result) {
            hideLoading();
            console.log('handleRubricData received:', result);
            
            if (!result.success) return showError(result.error);
            if (result.action === 'show_observation_selector') {
                currentObservedUser.email = result.observedEmail;
                currentObservedUser.name = result.observedName;
                hideStickyNav(); // Hide nav when going back to selector
                return displayObservationOptions(result.observedEmail, result.observedName);
            }
            
            if (result.action === 'redirect') {
                console.log('Processing redirect with params:', result.redirectParams);
                const url = new URL(window.location);
                Object.keys(result.redirectParams).forEach(key => {
                    url.searchParams.set(key, result.redirectParams[key]);
                });
                console.log('Redirecting to:', url.toString());
                window.location.href = url.toString();
                return;
            }
            
            if (result.action === 'show_html') {
                console.log('Processing show_html action - replacing page content');
                // Replace the entire page content with the generated HTML
                document.open();
                document.write(result.htmlContent);
                document.close();
                return;
            }

            const { observation, rubricData } = result;
            
            // Clear previous Quill instances and notes data before loading new observation
            if (observation) {
                console.log('Loading new observation data, ensuring clean state...');
                clearQuillInstances();
            }
            
            currentObservationId = observation ? observation.observationId : null;
            clearWorkProductAnswersCache(); // Clear cache when switching observations
            if (observation) {
                // Store observation globally for transcription button logic
                window.currentObservation = observation;
                currentObservedUser.email = observation.observedEmail;
                currentObservedUser.name = observation.observedName;
                console.log('Observation context set:', {
                    observationId: currentObservationId,
                    observedUser: currentObservedUser
                });
            }
            observationViewMode = (rubricData.userContext && rubricData.userContext.viewMode) || 'assigned';

            // Store observation type and show work product section if needed
            window.currentObservationType = result.observation?.Type || 'Standard';
            toggleWorkProductAnswersSection(window.currentObservationType === 'Work Product');

            // Auto-load answers for work product observations
            if (window.currentObservationType === 'Work Product') {
                refreshWorkProductAnswers();
            }

            // Store rubricData globally for nav functions
            window.rubricData = rubricData;
            
            // Show sticky navigation when viewing rubric
            showStickyNav(observation);

            window.pageLoadInfo = {
                cacheVersion: rubricData.userContext ? rubricData.userContext.cacheVersion : 'unknown'
            };
            
            updateFilterStatus(rubricData, observation);
            const rubricHtml = generateInteractiveRubricHtml(rubricData, observation);
            
            const rubricContainer = document.getElementById('rubricContainer');
            if (rubricContainer) {
                rubricContainer.innerHTML = rubricHtml;
            } else {
                console.error('ERROR: rubricContainer element not found!');
            }
            
            // Initialize notes data from observation if available
            if (observation && observation.observationData) {
                console.log('Loading observation notes data for', Object.keys(observation.observationData).length, 'components');
                Object.keys(observation.observationData).forEach(componentId => {
                    const componentData = observation.observationData[componentId];
                    if (componentData && componentData.notes) {
                        window.globalObservationNotes[componentId] = componentData.notes;
                        console.log(`Loaded notes for component ${componentId}`);
                    }
                });
                
                // Schedule recovery for components with notes data
                setTimeout(() => {
                    ensureEditorsForNotesData(rubricData.userContext.isEvaluator);
                }, 500);
            } else {
                console.log('No observation data to load');
            }
            
            // Show global tools bar for evaluators after DOM injection
            if (rubricData.userContext && rubricData.userContext.isEvaluator) {
                updateComponentVisibility();
                
                // Show global tools bar after HTML is in the DOM
                const globalToolsBar = document.getElementById('globalToolsBar');
                if (globalToolsBar) {
                    globalToolsBar.style.display = 'block';
                    // Update transcribe button visibility based on observation data
                    updateTranscribeButtonVisibility();
                } else {
                    console.error('ERROR: globalToolsBar element not found after HTML injection!');
                }
            } else {
                // For read-only finalized observations, still need to apply component visibility
                // based on the assigned view mode
                updateComponentVisibility();
            }
            restoreLookForsState();
            showView('rubricContainer');
        }

        function generateInteractiveRubricHtml(data, observation) {
            if (!data) {
                console.error('ERROR: No data provided to generateInteractiveRubricHtml');
                return '<div class="error">No rubric data available</div>';
            }
            
            if (!data.domains || !Array.isArray(data.domains) || data.domains.length === 0) {
                console.error('ERROR: No domains found in rubric data:', data);
                return '<div class="error">No rubric domains available</div>';
            }
            
            const isEvaluator = data.userContext && data.userContext.isEvaluator;
            const isFinalized = observation && observation.status === 'Finalized';
            const isReadOnlyView = isFinalized && !isEvaluator;
            
            let html = `<div class="${isReadOnlyView ? 'finalized-view' : ''}" style="background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">`;

            // Header section - different for editing vs finalized viewing
            if (isEvaluator) {
                const today = new Date().toISOString().slice(0, 10);
                const defaultObsName = `${observation.observedName.split(' ').pop()}, ${observation.observedName.split(' ')[0]}_${today}`;
                html += `
                <div class="observation-metadata-editor">
                    <div class="filter-row">
                        <input type="text" id="observationName" class="filter-select" value="${escapeHtml(observation.observationName || defaultObsName)}" onchange="saveObservationMetadata()">
                        <input type="date" id="observationDate" class="filter-select" value="${escapeHtml(observation.observationDate || today)}" onchange="saveObservationMetadata()">
                    </div>
                </div>`;
            } else if (isReadOnlyView) {
                // Read-only header for finalized observations
                html += `
                <div class="finalized-observation-header">
                    <div class="finalized-status">
                        <span class="status-indicator">✅ Finalized Observation</span>
                    </div>
                    <div class="observation-details">
                        <span class="obs-name">${escapeHtml(observation.observationName || 'Observation')}</span>
                        <span class="obs-date">${escapeHtml(observation.observationDate || '')}</span>
                    </div>
                </div>`;
            }

            // Global tools bar visibility will be handled after DOM injection

            html += `
            <div class="global-tools-bar" id="globalToolsBar" style="display: none;">
                <div class="global-tools-container">
                    <button class="global-tool-btn" id="recordAudioBtn" onclick="toggleAudioRecording()">
                        🎤 Record Audio
                    </button>
                    <div id="audioTimerDisplay" class="timer-display"></div>
                    <button class="global-tool-btn" id="recordVideoBtn" onclick="toggleVideoRecording()">
                        📹 Record Video
                    </button>
                    <div id="videoTimerDisplay" class="timer-display"></div>
                    <button class="global-tool-btn transcribe-btn" id="transcribeAudioBtn" onclick="requestTranscription()" style="display: none;" title="Get AI Transcription">
                        ⭐ Get Transcription
                    </button>
                    <button class="global-tool-btn" id="scriptEditorBtn" onclick="openScriptEditor()">
                        📝 Script Editor
                    </button>
                </div>
            </div>`;

            // Old navigation buttons removed - now handled by sticky nav

            data.domains.forEach((domain, domainIdx) => {
                html += `<div class="domain-section" id="domain-${domainIdx}"><div class="domain-header">${domain.name}</div>`;
                html += `<div class="performance-levels-header"><div class="performance-levels"><div class="level-header"></div><div class="level-header">Developing</div><div class="level-header">Basic</div><div class="level-header">Proficient</div><div class="level-header">Distinguished</div></div></div>`;
                
                if (!domain.components || !Array.isArray(domain.components)) {
                    console.error(`Domain ${domainIdx} has no components or invalid components:`, domain.components);
                    html += `<div class="error">Domain components not available</div>`;
                    return;
                }
                
                domain.components.forEach((comp, compIdx) => {
                    const componentId = comp.componentId;
                    const isAssigned = comp.isAssigned || false;
                    const selectedProficiency = observation?.observationData?.[componentId]?.proficiency;
                    const evidence = observation?.evidenceLinks?.[componentId] || [];

                    html += `<div class="component-section ${isAssigned ? 'component-assigned' : 'component-not-assigned'}" data-component-id="${componentId}" data-is-assigned="${isAssigned}"><div class="performance-levels-content">`;
                    html += `<div class="row-label">${comp.title}</div>`;
                    ['developing', 'basic', 'proficient', 'distinguished'].forEach(level => {
                        const isSelected = selectedProficiency === level;
                        html += `<div class="level-content ${isEvaluator ? 'editable' : ''} ${isSelected ? 'selected' : ''}" data-level="${level}" onclick="${isEvaluator ? `selectProficiency(this, '${componentId}', '${level}')` : ''}">${comp[level] || ''}</div>`;
                    });
                    html += `</div>`;

                    // Look-fors section (collapsible blue header, directly below subdomain rows)
                    if (comp.bestPractices && comp.bestPractices.length > 0) {
                        const lookForsId = `domain-${domainIdx}-component-${compIdx}`;
                        html += `<div class="look-fors-section">`;
                        html += `<div class="look-fors-header" onclick="toggleLookFors('${lookForsId}')">`;
                        html += `<span>Best Practices aligned with 5D+ and PELSB Standards</span>`;
                        html += `<span class="chevron" id="chevron-${lookForsId}">▶</span>`;
                        html += `</div>`;
                        html += `<div class="look-fors-content" id="lookForsContent-${lookForsId}">`;
                        html += `<div class="look-fors-grid">`;
                        comp.bestPractices.forEach((practice, practiceIdx) => {
                            const practiceId = `practice-${domainIdx}-${compIdx}-${practiceIdx}`;
                            const sanitizedPractice = escapeHtml(practice);
                            const onchangeHandler = isEvaluator ? `onchange="handleLookForChange(this, '${componentId}')"` : '';
                            
                            // Check if this practice is already selected in existing observation data
                            const existingLookfors = observation?.observationData?.[componentId]?.lookfors || [];
                            const isChecked = existingLookfors.includes(practice);
                            const checkedAttribute = isChecked ? 'checked' : '';
                            
                            html += `<div class="look-for-item">`;
                            html += `<input type="checkbox" id="${practiceId}" ${checkedAttribute} ${onchangeHandler}><label for="${practiceId}">${sanitizedPractice}</label>`;
                            html += `</div>`;
                        });
                        html += `</div></div></div>`;
                    }

                    // Notes & Evidence section (for evaluators only - contains notes editor and media upload)
                    // Check if we should show Notes & Evidence (for evaluators AND finalized observation viewing)
                    const hasObservationData = observation?.observationData?.[componentId];
                    const hasNotes = hasObservationData?.notes && hasObservationData.notes.trim() !== '' && hasObservationData.notes !== '<p><br></p>';
                    const hasEvidence = evidence && evidence.length > 0;
                    
                    if (isEvaluator || (isReadOnlyView && (hasNotes || hasEvidence))) {
                        html += `<div class="evidence-section ${isReadOnlyView ? 'readonly-evidence' : ''}">`;
                        html += `<div class="evidence-toggle-btn" onclick="toggleEvidenceSection('evidence-${componentId}')">`;
                        html += `<span>📝 Notes & Evidence</span>`;
                        html += `<span class="chevron" id="evidence-chevron-${componentId}">▶</span>`;
                        html += `</div>`;
                        html += `<div class="evidence-content ${isReadOnlyView ? 'expanded' : ''}" id="evidence-${componentId}">`;
                        
                        // Notes container
                        const sanitizedComponentId = componentId.replace(/[^a-zA-Z0-9]/g, '');
                        html += `<div class="notes-container">`;
                        html += `<h4>Observation Notes</h4>`;
                        
                        if (isEvaluator) {
                            // Editable notes for evaluators
                            html += `<div class="notes-header-actions">`;
                            html += `<button class="clear-notes-btn" onclick="clearNotes('${componentId}')" title="Clear all notes for this component">🗑️ Clear All</button>`;
                            html += `</div>`;
                            html += `<div id="notes-editor-${sanitizedComponentId}"></div>`;
                        } else if (isReadOnlyView && hasNotes) {
                            // Read-only notes display for finalized observations
                            html += `<div class="readonly-notes-content">`;
                            html += hasObservationData.notes;
                            html += `</div>`;
                        } else if (isReadOnlyView) {
                            // No notes message for finalized observations
                            html += `<div class="no-notes-message">No observation notes recorded.</div>`;
                        }
                        
                        html += `</div>`;
                        
                        // Evidence section - different for editing vs viewing
                        if (hasEvidence || isEvaluator) {
                            let evidenceHtml = '';
                            evidence.forEach(item => { evidenceHtml += `<div class="evidence-item"><a href="${item.url}" target="_blank" rel="noopener noreferrer">${item.name}</a></div>`; });
                            
                            html += `<div class="media-upload-container">`;
                            
                            if (isEvaluator) {
                                // Editable evidence upload for evaluators
                                html += `<h4>Upload Evidence</h4>`;
                                html += `<input type="file" class="media-upload-input" id="media-upload-${componentId}" onchange="uploadSelectedFile('${componentId}')" style="display: none;">`;
                                html += `<button class="media-upload-button" onclick="triggerFileUpload('${componentId}')">📎 Select & Upload File</button>`;
                            } else {
                                // Read-only evidence for finalized observations
                                html += `<h4>Evidence Files</h4>`;
                            }
                            
                            html += `<div class="media-links-container" data-component-id="${componentId}">`;
                            html += `<ul>${evidenceHtml}</ul>`;
                            html += `</div></div>`;
                        }
                        
                        // Close evidence-content and evidence-section
                        html += `</div></div>`;
                    }
                    html += `</div>`;
                });
                html += `</div>`;
            });
            html += `</div>`;
            
            return html;
        }

        function updateFilterStatus(rubricData, observation) {
            const status = document.getElementById('filterStatus');
            
            if (observation) {
                // Hide status div completely when viewing observations - main heading provides context
                status.style.display = 'none';
                return;
            }
            
            // Keep existing logic for other contexts (role viewing, etc.)
            const statusText = document.getElementById('filterStatusText');
            let text = 'Viewing Your Own Rubric';
            if (rubricData?.userContext?.filterInfo) {
                text = `Viewing as: ${rubricData.userContext.filterInfo.viewingAs} (${rubricData.userContext.filterInfo.viewingRole}, Year ${rubricData.userContext.filterInfo.viewingYear})`;
            }
            statusText.innerHTML = text;
            status.style.display = 'block';
        }

        function saveObservationMetadata() {
            const obsId = currentObservationId;
            const newName = document.getElementById('observationName').value;
            const newDate = document.getElementById('observationDate').value;

            if (!obsId || !newName || !newDate) return;

            google.script.run
                .withSuccessHandler(res => {
                    if (res.success) {
                        showToast('Observation details saved.', true);
                    } else {
                        showError(res.error);
                    }
                })
                .withFailureHandler(handleError)
                .updateObservationMetadata(obsId, { observationName: newName, observationDate: newDate });
        }

        function selectProficiency(element, componentId, proficiency) {
            if (!currentObservationId || !componentId || !proficiency) {
                console.error('Missing data for proficiency selection:', { currentObservationId, componentId, proficiency });
                return;
            }

            const parentRow = element.closest('.performance-levels-content');
            const currentlySelected = parentRow.querySelector('.level-content.selected');

            // --- Instant UI Update ---
            if (currentlySelected) {
                currentlySelected.classList.remove('selected');
            }
            element.classList.add('selected');

            // --- Background Save ---
            google.script.run
                .withSuccessHandler(function(response) {
                    if (response.success) {
                        console.log('Proficiency saved:', { componentId, proficiency });
                        // Optionally show a subtle success indicator
                    } else {
                        console.error('Failed to save proficiency:', response.error);
                        // --- Revert UI on Failure ---
                        element.classList.remove('selected');
                        if (currentlySelected) {
                            currentlySelected.classList.add('selected');
                        }
                        showToast('Error saving selection: ' + response.error);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Server error saving proficiency:', error);
                    // --- Revert UI on Failure ---
                    element.classList.remove('selected');
                    if (currentlySelected) {
                        currentlySelected.classList.add('selected');
                    }
                    showToast('Server error: ' + error.message);
                })
                .saveProficiencySelection(currentObservationId, componentId, proficiency);
        }
        function uploadFile(fileInput, componentId) {
            const file = fileInput.files[0]; if (!file) return;
            const statusEl = document.getElementById(`upload-status-${componentId}`); statusEl.textContent = 'Uploading...';
            const reader = new FileReader();
            reader.onload = e => {
                const base64Data = e.target.result.split(',')[1];
                google.script.run.withSuccessHandler(result => {
                    if (result.success) {
                        statusEl.textContent = 'Upload complete.'; fileInput.value = '';
                        const listEl = document.getElementById(`evidence-list-${componentId}`);
                        listEl.innerHTML += `<div class="evidence-item"><a href="${result.fileUrl}" target="_blank">${result.fileName}</a></div>`;
                        setTimeout(() => { statusEl.textContent = 'Select another file?'; }, 3000);
                    } else { handleError(result); statusEl.textContent = 'Upload failed.'; }
                }).withFailureHandler(handleError).uploadMediaEvidence(currentObservationId, componentId, base64Data, file.name, file.type);
            };
            reader.readAsDataURL(file);
        }
        function toggleObservationView() { observationViewMode = observationViewMode === 'assigned' ? 'full' : 'assigned'; updateComponentVisibility(); }
        function updateComponentVisibility() {
            const components = document.querySelectorAll('.component-section');
            if (observationViewMode === 'assigned') {
                components.forEach(comp => { comp.style.display = comp.dataset.isAssigned === 'true' ? '' : 'none'; });
            } else {
                components.forEach(comp => { comp.style.display = ''; });
            }
        }
        
        // Global Quill management system - consolidated for both interfaces
        window.globalQuillInstances = window.globalQuillInstances || {};
        window.globalObservationNotes = window.globalObservationNotes || {};
        
        function toggleEvidenceSection(contentId) {
            console.log('toggleEvidenceSection called with:', contentId);
            
            // Validate observation context
            if (!currentObservationId) {
                console.warn('Cannot toggle evidence section: No active observation');
                showToast('No active observation - cannot edit evidence', false);
                return;
            }
            
            const content = document.getElementById(contentId);
            if (!content) {
                console.error('Evidence content element not found:', contentId);
                return;
            }
            console.log('Found evidence content element:', content);

            const isExpanded = content.classList.toggle('expanded');
            console.log('Evidence section expanded state:', isExpanded);
            const componentId = contentId.replace('evidence-', '');
            console.log('Component ID:', componentId);

            // Toggle chevron
            const chevron = document.getElementById(`evidence-chevron-${componentId}`);
            if (chevron) {
                chevron.textContent = isExpanded ? '▼' : '▶';
            }

            // Initialize Quill on first expansion if not already initialized
            if (isExpanded && !window.globalQuillInstances[componentId]) {
                console.log('Initializing Quill editor for component:', componentId);
                const success = initializeQuillEditor(componentId);
                if (!success) {
                    console.error('Failed to initialize Quill editor for component:', componentId);
                    showToast(`Failed to initialize text editor for ${componentId}`, false);
                }
            } else if (isExpanded) {
                console.log('Quill instance already exists for component:', componentId);
                
                // Validate existing instance is functional
                const existingEditor = window.globalQuillInstances[componentId];
                if (!existingEditor || !existingEditor.root) {
                    console.warn('Existing Quill instance appears broken, re-initializing...');
                    delete window.globalQuillInstances[componentId];
                    const success = initializeQuillEditor(componentId);
                    if (!success) {
                        console.error('Failed to re-initialize Quill editor for component:', componentId);
                        showToast(`Failed to initialize text editor for ${componentId}`, false);
                    }
                }
            }

            // Store state in sessionStorage for persistence
            try {
                const storageKey = 'evidenceState_' + (window.pageLoadInfo?.cacheVersion || 'default');
                const allStates = JSON.parse(sessionStorage.getItem(storageKey) || '{}');
                allStates[componentId] = isExpanded;
                sessionStorage.setItem(storageKey, JSON.stringify(allStates));
            } catch (e) {
                console.warn('Could not save evidence section state:', e);
            }
        }

        // Consolidated Quill initialization function - make globally available
        window.initializeQuillEditor = function(componentId) {
            console.log('Attempting to initialize Quill editor for:', componentId);
            
            // Validate observation context
            if (!currentObservationId) {
                console.warn(`Cannot initialize Quill editor for ${componentId}: No active observation`);
                return false;
            }
            
            const sanitizedComponentId = componentId.replace(/[^a-zA-Z0-9]/g, '');
            const editorId = 'notes-editor-' + sanitizedComponentId;
            const editorElement = document.getElementById(editorId);
            
            if (!editorElement) {
                console.error('Notes editor element not found:', editorId);
                return false;
            }

            // Check if this component already has a Quill instance in our global registry
            if (window.globalQuillInstances[componentId]) {
                const existingEditor = window.globalQuillInstances[componentId];
                console.log('Quill instance already exists in global registry for:', componentId);
                
                // Verify the existing editor is still valid and attached to the correct element
                if (existingEditor && existingEditor.root && existingEditor.root.parentNode === editorElement) {
                    // Load existing notes content if available and not already loaded
                    if (window.globalObservationNotes[componentId] && 
                        (!existingEditor.root.innerHTML || existingEditor.root.innerHTML === '<p><br></p>')) {
                        existingEditor.root.innerHTML = window.globalObservationNotes[componentId];
                        console.log('Loaded existing notes for component:', componentId);
                    }
                    return true;
                } else {
                    // Existing editor is invalid, clean it up
                    console.warn(`Cleaning up invalid Quill instance for ${componentId}`);
                    delete window.globalQuillInstances[componentId];
                }
            }

            // Check if DOM element already has a Quill instance (prevent duplicates)
            if (editorElement.__quill) {
                console.log('Quill already initialized on DOM element:', editorId);
                const existingEditor = editorElement.__quill;
                
                // Verify this editor is functional
                if (existingEditor && existingEditor.root) {
                    window.globalQuillInstances[componentId] = existingEditor;
                    
                    // Load existing notes content if available and not already loaded
                    if (window.globalObservationNotes[componentId] && 
                        (!existingEditor.root.innerHTML || existingEditor.root.innerHTML === '<p><br></p>')) {
                        existingEditor.root.innerHTML = window.globalObservationNotes[componentId];
                        console.log('Loaded existing notes for component:', componentId);
                    }
                    
                    // Ensure auto-save is set up (check if already has listeners to avoid duplicates)
                    if (!existingEditor._hasAutoSaveListener) {
                        let timeout;
                        existingEditor.on('text-change', () => {
                            clearTimeout(timeout);
                            timeout = setTimeout(() => {
                                saveNotes(componentId, existingEditor.root.innerHTML);
                            }, 1500);
                        });
                        existingEditor._hasAutoSaveListener = true;
                        console.log('Auto-save listener attached to existing editor for:', componentId);
                    }
                    
                    return true;
                } else {
                    // DOM element has broken Quill instance, clean it up
                    console.warn(`Cleaning up broken Quill instance on DOM element for ${componentId}`);
                    delete editorElement.__quill;
                }
            }
            
            console.log('Found editor element:', editorId);
            try {
                // Check if Quill is available
                if (typeof Quill === 'undefined') {
                    console.error('Quill library failed to load from CDN');
                    showToast('Rich text editor unavailable. Please refresh the page.');
                    return false;
                }
                
                const editor = new Quill(editorElement, {
                    theme: 'snow',
                    modules: {
                        toolbar: [
                            [{ 'header': [1, 2, false] }],
                            ['bold', 'italic', 'underline'],
                            [{'list': 'ordered'}, {'list': 'bullet'}],
                            ['clean']
                        ]
                    }
                });
                console.log('Quill editor created successfully');

                // Load existing notes 
                if (window.globalObservationNotes[componentId]) {
                    editor.root.innerHTML = window.globalObservationNotes[componentId];
                    console.log('Loaded existing notes for component:', componentId);
                }

                // Add debounced auto-save
                let timeout;
                editor.on('text-change', () => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        saveNotes(componentId, editor.root.innerHTML);
                    }, 1500); // Save 1.5 seconds after typing stops
                });
                editor._hasAutoSaveListener = true;

                window.globalQuillInstances[componentId] = editor;
                console.log('Quill editor initialized for component:', componentId);
                return true;
            } catch (error) {
                console.error('Error initializing Quill editor:', error);
                return false;
            }
        }
        
        function saveNotes(componentId, content) {
            if (!currentObservationId) {
                console.error('Cannot save notes: No observation context available.');
                showToast('Error: No active observation found. Cannot save notes.');
                return;
            }

            // Update local data using global storage
            window.globalObservationNotes[componentId] = content;

            google.script.run
                .withSuccessHandler(() => console.log(`Notes saved for ${componentId}`))
                .withFailureHandler(error => {
                    console.error('Failed to save notes:', error);
                    showToast('Error saving notes. Please check your connection.');
                })
                .saveObservationNotes(currentObservationId, componentId, content);
        }

        // Clear all notes for a specific component
        window.clearNotes = function(componentId) {
            if (!confirm(`Are you sure you want to clear all notes for this component?\n\nThis action cannot be undone.`)) {
                return;
            }

            const editor = window.globalQuillInstances[componentId];
            if (editor) {
                editor.setContents([], 'user'); // Clear content and trigger change event
                console.log(`Notes cleared for component: ${componentId}`);
                showToast(`Notes cleared for ${componentId}`, true);
                
                // Immediately save the cleared state
                window.globalObservationNotes[componentId] = '';
                saveNotes(componentId, '');
            } else {
                console.warn(`No editor found for component: ${componentId}`);
                showToast(`No notes to clear for ${componentId}`, false);
            }
        }

        // Recovery mechanism to ensure all components with notes data have editors
        function ensureEditorsForNotesData(isEvaluator) {
            if (!isEvaluator || !window.globalObservationNotes) {
                return;
            }
            
            console.log('Running recovery mechanism for orphaned notes data...');
            
            Object.keys(window.globalObservationNotes).forEach(componentId => {
                const notesContent = window.globalObservationNotes[componentId];
                if (notesContent && notesContent.trim() !== '' && notesContent !== '<p><br></p>') {
                    // Check if editor exists
                    if (!window.globalQuillInstances[componentId]) {
                        console.log(`Found orphaned notes data for ${componentId}, attempting to initialize editor...`);
                        
                        // Check if the evidence section exists but is collapsed
                        const evidenceSectionId = `evidence-${componentId}`;
                        const evidenceSection = document.getElementById(evidenceSectionId);
                        
                        if (evidenceSection) {
                            // Expand the section if collapsed
                            const content = document.getElementById(evidenceSectionId);
                            if (content && !content.classList.contains('expanded')) {
                                console.log(`Expanding collapsed section for ${componentId} to recover notes...`);
                                toggleEvidenceSection(evidenceSectionId);
                            }
                            
                            // Try to initialize the editor with a slight delay
                            setTimeout(() => {
                                if (!window.globalQuillInstances[componentId]) {
                                    console.log(`Force initializing editor for ${componentId}...`);
                                    const success = window.initializeQuillEditor(componentId);
                                    if (success) {
                                        console.log(`Successfully recovered notes editor for ${componentId}`);
                                    } else {
                                        console.warn(`Failed to recover notes editor for ${componentId}`);
                                    }
                                }
                            }, 200);
                        } else {
                            console.warn(`Evidence section not found for ${componentId}, cannot recover notes`);
                        }
                    } else {
                        // Editor exists, ensure content is loaded
                        const editor = window.globalQuillInstances[componentId];
                        if (editor && (!editor.root.innerHTML || editor.root.innerHTML === '<p><br></p>')) {
                            editor.root.innerHTML = notesContent;
                            console.log(`Restored content to existing editor for ${componentId}`);
                        }
                    }
                }
            });
        }

        function triggerFileUpload(componentId) {
            const fileInput = document.getElementById(`media-upload-${componentId}`);
            if (!fileInput) {
                console.error('File input not found for component:', componentId);
                return;
            }
            
            // Trigger the file picker
            fileInput.click();
        }

        function uploadSelectedFile(componentId) {
            const fileInput = document.getElementById(`media-upload-${componentId}`);
            if (!fileInput) {
                console.error('File input not found for component:', componentId);
                return;
            }

            const file = fileInput.files[0];
            if (!file) {
                return; // No file selected, user probably cancelled
            }

            if (!currentObservationId) {
                showToast('No observation selected. Please save the observation first.');
                return;
            }

            showToast('Uploading file...', false);

            // Convert file to base64 for Google Apps Script
            const reader = new FileReader();
            reader.onload = function(e) {
                const fileData = {
                    name: file.name,
                    mimeType: file.type,
                    content: e.target.result.split(',')[1], // Remove data:mime;base64, prefix
                    size: file.size
                };

                google.script.run
                    .withSuccessHandler(function(result) {
                        if (result.success) {
                            showToast('File uploaded successfully!', true);
                            updateMediaLinks(componentId, result.fileUrl, result.fileName);
                            fileInput.value = ''; // Clear the input
                        } else {
                            showToast('Upload failed: ' + result.error);
                        }
                    })
                    .withFailureHandler(function(error) {
                        console.error('Upload error:', error);
                        showToast('Upload failed. Please try again.');
                    })
                    .uploadMediaEvidence(currentObservationId, componentId, fileData.content, fileData.name, fileData.mimeType);
            };
            reader.onerror = function() {
                showToast('Error reading file. Please try again.');
            };
            reader.readAsDataURL(file);
        }

        function updateMediaLinks(componentId, fileUrl, fileName) {
            const linksContainer = document.querySelector(`[data-component-id="${componentId}"] ul`);
            if (linksContainer) {
                const listItem = document.createElement('li');
                listItem.className = 'evidence-item';
                listItem.innerHTML = `<a href="${fileUrl}" target="_blank">${fileName}</a>`;
                linksContainer.appendChild(listItem);
            }
        }
        
        function handleLookForChange(checkbox, componentId) {
            const lookForText = checkbox.nextElementSibling.textContent;
            const isChecked = checkbox.checked;

            if (!currentObservationId) {
                console.error('Cannot save look-for selection: Observation context not available.');
                checkbox.checked = !isChecked; // Revert the checkbox state
                showToast('Error: No active observation found. Cannot save selection.');
                return;
            }

            google.script.run
                .withSuccessHandler(() => {
                    console.log(`Saved look-for: ${componentId} -> ${lookForText}`);
                })
                .withFailureHandler(error => {
                    console.error('Save failed:', error);
                    checkbox.checked = !isChecked; // Revert the checkbox state on failure
                    showToast('Failed to save look-for selection. Please check your connection.');
                })
                .saveLookForSelection(currentObservationId, componentId, lookForText, isChecked);
        }
        
        // === New Sticky Navigation Functions ===
        
        function setViewMode(mode) {
            observationViewMode = mode;
            updateViewToggle();
            updateComponentVisibility();
        }
        
        function updateViewToggle() {
            const assignedToggle = document.getElementById('assignedToggle');
            const fullToggle = document.getElementById('fullToggle');
            const slider = document.getElementById('toggleSlider');
            
            if (!assignedToggle || !fullToggle || !slider) return;
            
            // Update active states
            assignedToggle.classList.toggle('active', observationViewMode === 'assigned');
            fullToggle.classList.toggle('active', observationViewMode === 'full');
            
            // Animate slider position
            const toggleWidth = assignedToggle.offsetWidth;
            if (observationViewMode === 'assigned') {
                slider.style.width = toggleWidth + 'px';
                slider.style.transform = 'translateX(0)';
            } else {
                slider.style.width = fullToggle.offsetWidth + 'px';
                slider.style.transform = `translateX(${toggleWidth}px)`;
            }
        }
        
        function showStickyNav(observation) {
            const stickyNav = document.getElementById('stickyNav');
            const viewToggle = document.getElementById('viewToggle');
            const staffContext = document.getElementById('staffContext');
            const staffName = document.getElementById('staffName');
            const navActions = document.getElementById('navActions');
            const finalizeBtn = document.getElementById('finalizeBtn');
            
            if (!stickyNav) return;
            
            stickyNav.classList.add('show');
            
            if (observation) {
                // Show staff context
                if (staffContext && staffName) {
                    staffName.textContent = observation.observedName || 'N/A';
                    staffContext.style.display = 'block';
                }
                
                // Show view toggle for evaluators
                if (viewToggle && window.rubricData?.userContext?.isEvaluator) {
                    viewToggle.style.display = 'flex';
                    updateViewToggle();
                }
                
                // Show action buttons for draft observations
                if (navActions && observation.status === 'Draft') {
                    navActions.style.display = 'flex';
                }
                
                // Update finalize button text based on status
                if (finalizeBtn) {
                    if (observation.status === 'Draft') {
                        finalizeBtn.textContent = '✅ Finalize & Submit';
                        finalizeBtn.onclick = handleFinalizeFromNav;
                    } else {
                        finalizeBtn.style.display = 'none';
                    }
                }
            }
        }
        
        function hideStickyNav() {
            const stickyNav = document.getElementById('stickyNav');
            if (stickyNav) {
                stickyNav.classList.remove('show');
            }
        }
        
        
        // Update existing functions to work with new nav
        const originalToggleObservationView = toggleObservationView;
        toggleObservationView = function() {
            originalToggleObservationView();
            updateViewToggle();
        };

        const userContext = <?!= JSON.stringify(userContext) ?>;

        document.addEventListener('DOMContentLoaded', () => {
            if (userContext.role === 'Administrator') {
                showView('adminStaffListView');
                loadAdminStaffList();
            } else {
                showView('quickActionsView');
            }
        });

        function loadAdminStaffList() {
            showLoading('Loading staff list...');
            google.script.run
                .withSuccessHandler(populateAdminStaffList)
                .withFailureHandler(handleError)
                .getStaffListForDropdown(null, null);
        }

        // Store staff data globally for filtering
        let allStaffData = [];

        function populateAdminStaffList(result) {
            hideLoading();
            if (!result.success) {
                showError(result.error);
                return;
            }

            // Store the staff data for filtering
            allStaffData = result.staff || [];
            
            // Initially show all staff (default filter)
            renderStaffList(allStaffData);
        }

        function renderStaffList(staffToShow) {
            const container = document.getElementById('adminStaffList');
            container.innerHTML = ''; // Clear existing content

            if (staffToShow && staffToShow.length > 0) {
                staffToShow.forEach(staff => {
                    const listItem = document.createElement('div');
                    listItem.className = 'staff-list-item';
                    listItem.onclick = () => displayObservationOptions(staff.email, staff.name);

                    // Determine if probationary (year 0) or tenured (year > 0)
                    const isProbationary = staff.year === 0 || staff.year === 'Probationary';
                    
                    // Set data attribute for filtering
                    listItem.setAttribute('data-staff-type', isProbationary ? 'probationary' : 'tenured');

                    const mainSection = document.createElement('div');
                    mainSection.className = 'staff-item-main';

                    const icon = document.createElement('span');
                    icon.className = 'staff-item-icon';
                    icon.textContent = '👤';

                    const infoSection = document.createElement('div');
                    infoSection.className = 'staff-item-info';

                    const name = document.createElement('div');
                    name.className = 'staff-item-name';
                    name.textContent = staff.name;

                    const details = document.createElement('div');
                    details.className = 'staff-item-details';
                    details.textContent = `${staff.role}`;

                    const yearBadge = document.createElement('div');
                    yearBadge.className = `staff-item-year-badge ${isProbationary ? 'probationary' : 'tenured'}`;
                    yearBadge.textContent = formatYearDisplay(staff.year);

                    infoSection.appendChild(name);
                    infoSection.appendChild(details);
                    mainSection.appendChild(icon);
                    mainSection.appendChild(infoSection);
                    
                    listItem.appendChild(mainSection);
                    listItem.appendChild(yearBadge);
                    container.appendChild(listItem);
                });
            } else {
                const noStaffMessage = document.createElement('div');
                noStaffMessage.style.textAlign = 'center';
                noStaffMessage.style.padding = '40px 20px';
                noStaffMessage.style.color = 'var(--color-text-deemphasized)';
                noStaffMessage.style.fontSize = '1.1rem';
                noStaffMessage.textContent = 'No staff members found for the selected filter.';
                container.appendChild(noStaffMessage);
            }
        }

        function filterStaffList(filterType) {
            // Update active button
            document.querySelectorAll('.filter-toggle-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-filter="${filterType}"]`).classList.add('active');

            // Filter the staff data
            let filteredStaff = allStaffData;

            switch (filterType) {
                case 'all':
                    filteredStaff = allStaffData;
                    break;
                case 'tenured':
                    filteredStaff = allStaffData.filter(staff => staff.year !== 0 && staff.year !== 'Probationary');
                    break;
                case 'probationary':
                    filteredStaff = allStaffData.filter(staff => staff.year === 0 || staff.year === 'Probationary');
                    break;
                default:
                    filteredStaff = allStaffData;
            }

            // Re-render the list with filtered data
            renderStaffList(filteredStaff);
        }

        // Consolidated recording state management
        const recordingState = {
            audio: { 
                recorder: null, 
                stream: null, 
                isRecording: false,
                timer: null,
                startTime: null,
                sessionCount: 0,
                totalSessionTime: 0
            },
            video: { 
                recorder: null, 
                stream: null, 
                isRecording: false,
                timer: null,
                startTime: null,
                sessionCount: 0,
                totalSessionTime: 0
            }
        };

        // Recording constants
        const RECORDING_MAX_DURATION_MS = 10 * 60 * 1000; // 10 minutes
        const WARNING_TIMES = [30000, 10000]; // 30 seconds, 10 seconds

        // Global AudioContext for reuse across recordings (performance optimization)
        let globalAudioContext = null;
        function getAudioContext() {
            if (!globalAudioContext) {
                globalAudioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return globalAudioContext;
        }

        // Convert Float32Array samples to Int16Array for LameJS MP3 encoder
        function convertFloat32ToInt16(float32Array) {
            const int16Array = new Int16Array(float32Array.length);
            for (let i = 0; i < float32Array.length; i++) {
                // Clamp values to [-1, 1] and convert to 16-bit signed integer
                const clampedValue = Math.max(-1, Math.min(1, float32Array[i]));
                int16Array[i] = Math.round(clampedValue * 32767);
            }
            return int16Array;
        }

        // Recording timer functions
        function startRecordingTimer(type) {
            const state = recordingState[type];
            state.startTime = Date.now();
            state.sessionCount++;
            
            updateTimerDisplay(type);
            
            state.timer = setInterval(() => {
                updateTimerDisplay(type);
                checkRecordingWarnings(type);
            }, 1000);
        }

        function stopRecordingTimer(type) {
            const state = recordingState[type];
            if (state.timer) {
                clearInterval(state.timer);
                state.timer = null;
            }
            
            if (state.startTime) {
                const sessionDuration = Date.now() - state.startTime;
                state.totalSessionTime += sessionDuration;
                state.startTime = null;
            }
            
            hideTimerDisplay(type);
        }

        function updateTimerDisplay(type) {
            const state = recordingState[type];
            if (!state.startTime) return;
            
            const elapsed = Date.now() - state.startTime;
            const remaining = Math.max(0, RECORDING_MAX_DURATION_MS - elapsed);
            const remainingSeconds = Math.ceil(remaining / 1000);
            const minutes = Math.floor(remainingSeconds / 60);
            const seconds = remainingSeconds % 60;
            
            const displayElement = document.getElementById(`${type}TimerDisplay`);
            if (displayElement) {
                const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                const percentage = ((RECORDING_MAX_DURATION_MS - remaining) / RECORDING_MAX_DURATION_MS) * 100;
                
                displayElement.innerHTML = `
                    <div class="recording-timer">
                        <div class="timer-info">
                            🔴 Recording ${state.sessionCount} (${formattedTime} remaining)
                        </div>
                        <div class="timer-progress">
                            <div class="progress-bar" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
                
                // Add warning styling for last 30 seconds
                if (remaining <= 30000) {
                    displayElement.classList.add('timer-warning');
                } else {
                    displayElement.classList.remove('timer-warning');
                }
            }
            
            // Auto-stop when time limit reached
            if (remaining <= 0) {
                autoStopRecording(type);
            }
        }

        function hideTimerDisplay(type) {
            const displayElement = document.getElementById(`${type}TimerDisplay`);
            if (displayElement) {
                displayElement.innerHTML = '';
                displayElement.classList.remove('timer-warning');
            }
        }

        function checkRecordingWarnings(type) {
            const state = recordingState[type];
            if (!state.startTime) return;
            
            const elapsed = Date.now() - state.startTime;
            const remaining = RECORDING_MAX_DURATION_MS - elapsed;
            
            for (const warningTime of WARNING_TIMES) {
                if (remaining <= warningTime && remaining > warningTime - 1000) {
                    const seconds = Math.ceil(warningTime / 1000);
                    showToast(`Recording will stop in ${seconds} seconds`, false, 3000);
                    break;
                }
            }
        }

        function autoStopRecording(type) {
            const state = recordingState[type];
            const config = recordingConfig[type];
            
            if (state.isRecording) {
                // Stop the recording
                state.recorder.stop();
                state.stream.getTracks().forEach(track => track.stop());
                state.isRecording = false;
                
                // Update button
                const btn = document.getElementById(config.buttonId);
                btn.textContent = config.stopText;
                btn.classList.remove('recording');
                
                stopRecordingTimer(type);
                
                // Show auto-stop notification and restart option
                showRecordingStoppedNotification(type);
            }
        }

        function showRecordingStoppedNotification(type) {
            const typeText = type === 'audio' ? 'Audio' : 'Video';
            const totalMinutes = Math.floor(recordingState[type].totalSessionTime / 60000);
            const totalSeconds = Math.floor((recordingState[type].totalSessionTime % 60000) / 1000);
            
            const message = `${typeText} recording stopped (10-minute limit reached). 
                            Session ${recordingState[type].sessionCount} saved. 
                            Total recorded: ${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;
            
            showToast(message, true, 5000);
            
            // Show restart button
            showRestartRecordingOption(type);
        }

        function showRestartRecordingOption(type) {
            const config = recordingConfig[type];
            const btn = document.getElementById(config.buttonId);
            const typeText = type === 'audio' ? 'Audio' : 'Video';
            
            // Temporarily change button to show restart option
            const originalText = btn.textContent;
            btn.textContent = `▶️ Continue ${typeText} Recording`;
            btn.style.backgroundColor = '#4CAF50';
            
            // Reset button styling after 10 seconds
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.backgroundColor = '';
            }, 10000);
        }

        // Session overview functions
        function getSessionSummary(type) {
            const state = recordingState[type];
            const totalMinutes = Math.floor(state.totalSessionTime / 60000);
            const totalSeconds = Math.floor((state.totalSessionTime % 60000) / 1000);
            const formattedTime = `${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;
            
            return {
                sessionCount: state.sessionCount,
                totalTime: formattedTime,
                totalTimeMs: state.totalSessionTime
            };
        }

        function logSessionSummary() {
            const audioSummary = getSessionSummary('audio');
            const videoSummary = getSessionSummary('video');
            
            console.log('Recording Session Summary:', {
                audio: audioSummary,
                video: videoSummary
            });
            
            if (audioSummary.sessionCount > 0 || videoSummary.sessionCount > 0) {
                let message = 'Recording Session Summary:\n';
                if (audioSummary.sessionCount > 0) {
                    message += `Audio: ${audioSummary.sessionCount} recordings, ${audioSummary.totalTime} total\n`;
                }
                if (videoSummary.sessionCount > 0) {
                    message += `Video: ${videoSummary.sessionCount} recordings, ${videoSummary.totalTime} total`;
                }
                showToast(message, true, 8000);
            }
        }

        // Function to reset recording session data (useful when starting a new observation)
        function resetRecordingSessions() {
            for (const type of ['audio', 'video']) {
                const state = recordingState[type];
                
                // Stop any active recordings first
                if (state.isRecording) {
                    try {
                        state.recorder.stop();
                        state.stream.getTracks().forEach(track => track.stop());
                    } catch (e) {
                        console.warn(`Error stopping ${type} recording:`, e);
                    }
                }
                
                // Clear timers
                if (state.timer) {
                    clearInterval(state.timer);
                    state.timer = null;
                }
                
                // Reset state
                state.recorder = null;
                state.stream = null;
                state.isRecording = false;
                state.startTime = null;
                state.sessionCount = 0;
                state.totalSessionTime = 0;
                
                // Reset UI
                const config = recordingConfig[type];
                const btn = document.getElementById(config.buttonId);
                if (btn) {
                    btn.textContent = config.stopText;
                    btn.classList.remove('recording');
                    btn.style.backgroundColor = '';
                }
                
                hideTimerDisplay(type);
            }
            
            console.log('Recording sessions reset');
        }

        // Development helper function for testing (can be removed in production)
        function testRecordingSystem() {
            console.log('Testing 10-minute recording system...');
            
            // Test timer display updates
            console.log('Audio session summary:', getSessionSummary('audio'));
            console.log('Video session summary:', getSessionSummary('video'));
            
            // Test UI elements exist
            const audioBtn = document.getElementById('recordAudioBtn');
            const videoBtn = document.getElementById('recordVideoBtn');
            const audioTimer = document.getElementById('audioTimerDisplay');
            const videoTimer = document.getElementById('videoTimerDisplay');
            
            console.log('UI Elements Check:', {
                audioBtn: !!audioBtn,
                videoBtn: !!videoBtn,
                audioTimer: !!audioTimer,
                videoTimer: !!videoTimer
            });
            
            if (audioBtn && videoBtn && audioTimer && videoTimer) {
                console.log('✅ All recording system components properly initialized');
                return true;
            } else {
                console.error('❌ Missing recording system components');
                return false;
            }
        }

        // Recording configuration
        const recordingConfig = {
            audio: {
                constraints: { audio: true },
                buttonId: 'recordAudioBtn',
                startText: '🛑 Stop Audio',
                stopText: '🎤 Record Audio',
                errorMessage: 'Error accessing microphone: '
            },
            video: {
                constraints: { video: true, audio: true },
                buttonId: 'recordVideoBtn', 
                startText: '🛑 Stop Video',
                stopText: '📹 Record Video',
                errorMessage: 'Error accessing camera: '
            }
        };

        async function toggleRecording(type) {
            const state = recordingState[type];
            const config = recordingConfig[type];
            const btn = document.getElementById(config.buttonId);

            if (!state.isRecording) {
                try {
                    state.stream = await navigator.mediaDevices.getUserMedia(config.constraints);

                    const options = {};
                    if (type === 'audio') {
                        // Use audio/webm as it's the most commonly supported format
                        options.mimeType = 'audio/webm';
                    } else if (type === 'video') {
                        if (MediaRecorder.isTypeSupported('video/mp4')) {
                            options.mimeType = 'video/mp4';
                        } else {
                            console.warn('video/mp4 not supported, falling back to video/webm');
                            options.mimeType = 'video/webm';
                        }
                    }

                    state.recorder = new MediaRecorder(state.stream, options);

                    const chunks = [];
                    state.recorder.ondataavailable = event => chunks.push(event.data);

                    state.recorder.onerror = (event) => {
                        console.error('Recording error:', event);
                        showToast(`Recording failed: ${event.error || 'Unknown error'}. Try shorter recordings.`, false);
                        // Reset recording state
                        state.isRecording = false;
                        btn.textContent = config.stopText;
                        btn.classList.remove('recording');
                        stopRecordingTimer(type);
                    };

                    state.recorder.onstop = () => {
                        const blob = new Blob(chunks, { type: state.recorder.mimeType });
                        if (type === 'audio') {
                            encodeAudioToMp3(blob);
                        } else {
                            uploadRecording(blob, 'video');
                        }
                    };

                    state.recorder.start();
                    state.isRecording = true;
                    btn.textContent = config.startText;
                    btn.classList.add('recording');
                    
                    // Start the recording timer
                    startRecordingTimer(type);

                } catch (error) {
                    showToast(config.errorMessage + error.message, false);
                }
            } else {
                state.recorder.stop();
                state.stream.getTracks().forEach(track => track.stop());
                state.isRecording = false;
                btn.textContent = config.stopText;
                btn.classList.remove('recording');
                
                // Stop the recording timer
                stopRecordingTimer(type);
            }
        }

        // Wrapper functions for backwards compatibility
        async function toggleAudioRecording() {
            await toggleRecording('audio');
        }

        async function toggleVideoRecording() {
            await toggleRecording('video');
        }

        function encodeAudioToMp3(audioBlob, bitrate = 192) {
            console.log('Starting MP3 encoding...', { blobSize: audioBlob.size, bitrate });
            
            // Fallback function if MP3 encoding fails
            function fallbackToWebm() {
                console.warn('MP3 encoding failed, uploading original WebM audio');
                showToast('MP3 conversion failed, saving as WebM format', false);
                uploadRecording(audioBlob, 'audio');
            }
            
            const reader = new FileReader();
            reader.onload = function(event) {
                const arrayBuffer = event.target.result;
                console.log('AudioBlob read as ArrayBuffer:', { size: arrayBuffer.byteLength });
                
                const audioContext = getAudioContext(); // Reuse global AudioContext
                audioContext.decodeAudioData(arrayBuffer, (audioBuffer) => {
                    const numChannels = audioBuffer.numberOfChannels;
                    const duration = audioBuffer.duration;
                    const sampleRate = audioBuffer.sampleRate;
                    const totalSamples = audioBuffer.length;
                    
                    console.log('AudioBuffer decoded:', { 
                        channels: numChannels, 
                        duration: duration + 's',
                        sampleRate,
                        totalSamples
                    });
                    
                    // Validate audio buffer has content
                    if (totalSamples === 0 || duration === 0) {
                        console.error('AudioBuffer is empty');
                        fallbackToWebm();
                        return;
                    }
                    
                    // Lamejs supports mono (1) or stereo (2)
                    const channels = numChannels > 2 ? 2 : numChannels;
                    
                    if (numChannels > 2) {
                        console.warn('Only the first two channels will be encoded to MP3 (stereo).');
                    }

                    try {
                        const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, bitrate);
                        const mp3Data = [];
                        const sampleBlockSize = 1152;
                        let totalProcessedSamples = 0;

                        if (channels === 2) {
                            // Stereo encoding
                            const left = audioBuffer.getChannelData(0);
                            const right = audioBuffer.getChannelData(1);
                            
                            for (let i = 0; i < left.length; i += sampleBlockSize) {
                                const leftChunk = left.subarray(i, i + sampleBlockSize);
                                const rightChunk = right.subarray(i, i + sampleBlockSize);
                                
                                // Convert Float32 to Int16 for LameJS
                                const leftInt16 = convertFloat32ToInt16(leftChunk);
                                const rightInt16 = convertFloat32ToInt16(rightChunk);
                                
                                const mp3buf = mp3encoder.encodeBuffer(leftInt16, rightInt16);
                                if (mp3buf.length > 0) {
                                    mp3Data.push(mp3buf);
                                    totalProcessedSamples += leftChunk.length;
                                }
                            }
                        } else {
                            // Mono encoding or mixdown from stereo
                            let samples;
                            if (numChannels === 2) {
                                // Mix down stereo to mono
                                const left = audioBuffer.getChannelData(0);
                                const right = audioBuffer.getChannelData(1);
                                samples = new Float32Array(left.length);
                                for (let i = 0; i < left.length; i++) {
                                    samples[i] = 0.5 * (left[i] + right[i]);
                                }
                                console.log('Mixed stereo to mono');
                            } else {
                                samples = audioBuffer.getChannelData(0);
                            }
                            
                            for (let i = 0; i < samples.length; i += sampleBlockSize) {
                                const sampleChunk = samples.subarray(i, i + sampleBlockSize);
                                
                                // Convert Float32 to Int16 for LameJS
                                const int16Chunk = convertFloat32ToInt16(sampleChunk);
                                
                                const mp3buf = mp3encoder.encodeBuffer(int16Chunk);
                                if (mp3buf.length > 0) {
                                    mp3Data.push(mp3buf);
                                    totalProcessedSamples += sampleChunk.length;
                                }
                            }
                        }
                        
                        const mp3buf = mp3encoder.flush();
                        if (mp3buf.length > 0) {
                            mp3Data.push(mp3buf);
                        }

                        console.log('MP3 encoding completed:', { 
                            chunks: mp3Data.length, 
                            processedSamples: totalProcessedSamples,
                            expectedSamples: totalSamples
                        });

                        if (mp3Data.length === 0) {
                            console.error('No MP3 data generated');
                            fallbackToWebm();
                            return;
                        }

                        const mp3Blob = new Blob(mp3Data, { type: 'audio/mpeg' });
                        console.log('MP3 Blob created:', { size: mp3Blob.size });
                        
                        if (mp3Blob.size === 0) {
                            console.error('MP3 Blob is empty');
                            fallbackToWebm();
                            return;
                        }
                        
                        uploadRecording(mp3Blob, 'audio');
                        
                    } catch (encodingError) {
                        console.error('MP3 encoding error:', encodingError);
                        fallbackToWebm();
                    }
                    
                }, (decodeError) => {
                    console.error('AudioContext decode error:', decodeError);
                    showToast('Failed to decode audio: ' + decodeError.message, false);
                    fallbackToWebm();
                });
            };
            
            reader.onerror = function(readerError) {
                console.error('FileReader error:', readerError);
                fallbackToWebm();
            };
            
            reader.readAsArrayBuffer(audioBlob);
        }

        function uploadRecording(blob, type) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const sessionNumber = recordingState[type].sessionCount;
            let extension;
            
            if (type === 'audio') {
                // Check blob type to determine if it's MP3 or WebM (fallback)
                if (blob.type === 'audio/mpeg' || blob.type === 'audio/mp3') {
                    extension = 'mp3';
                } else {
                    extension = 'webm'; // WebM fallback
                    console.log('Audio saved as WebM (MP3 encoding failed or not applied)');
                }
            } else if (type === 'video') {
                if (blob.type.includes('mp4')) {
                    extension = 'mp4';
                } else {
                    extension = 'webm';
                }
            } else {
                extension = 'bin'; // fallback for unknown type
            }
            const filename = `${type}-recording-${sessionNumber}-${timestamp}.${extension}`;
            
            console.log('Uploading recording:', { 
                type, 
                extension, 
                blobType: blob.type, 
                size: blob.size, 
                filename 
            });

            // Convert blob to base64
            const reader = new FileReader();
            reader.onload = function() {
                const base64Data = reader.result.split(',')[1];

                google.script.run
                    .withSuccessHandler(function(result) {
                        if (result.success) {
                            showToast(`${type} recording saved successfully!`, true);
                            // Add to global recordings list
                            addGlobalRecording(result.fileUrl, filename, type);
                        } else {
                            showToast(`Error saving ${type} recording: ` + result.error, false);
                        }
                    })
                    .withFailureHandler(function(error) {
                        showToast(`Failed to save ${type} recording: ` + error.message, false);
                    })
                    .uploadGlobalRecording(currentObservationId, base64Data, filename, type);
            };
            reader.readAsDataURL(blob);
        }

        function addGlobalRecording(fileUrl, filename, type) {
            if (!window.currentObservation) {
                console.error('Cannot add global recording: No current observation');
                return;
            }

            if (!window.currentObservation.globalRecordings) {
                window.currentObservation.globalRecordings = { audio: [], video: [] };
            }
            
            if (!window.currentObservation.globalRecordings[type]) {
                window.currentObservation.globalRecordings[type] = [];
            }

            window.currentObservation.globalRecordings[type].push({
                url: fileUrl,
                name: filename,
                type: type
            });

            console.log(`Recording saved and added to global state: ${type} at ${fileUrl}`);
            
            // Update transcribe button visibility when recordings are added
            updateTranscribeButtonVisibility();
        }

        /**
         * Updates the visibility and state of the transcribe button based on audio recordings
         */
        function updateTranscribeButtonVisibility() {
            const transcribeBtn = document.getElementById('transcribeAudioBtn');
            if (!transcribeBtn) return;

            // Check if current observation has audio recordings
            let hasAudioRecordings = false;

            // Check for existing recordings in observation data (loaded observations)
            if (window.currentObservation && window.currentObservation.globalRecordings && window.currentObservation.globalRecordings.audio) {
                hasAudioRecordings = window.currentObservation.globalRecordings.audio.length > 0;
            }

            // Also check recording state for current session (new recordings)
            if (recordingState.audio && recordingState.audio.sessionCount > 0) {
                hasAudioRecordings = true;
            }

            if (hasAudioRecordings) {
                transcribeBtn.style.display = 'inline-block';
                transcribeBtn.disabled = false;
                console.log('Transcribe button shown - audio recordings available');
            } else {
                transcribeBtn.style.display = 'none';
                console.log('Transcribe button hidden - no audio recordings');
            }
        }

        /**
         * Requests transcription for the current observation's audio files
         */
        function requestTranscription() {
            if (!currentObservationId) {
                showToast('No observation selected', false);
                return;
            }

            const transcribeBtn = document.getElementById('transcribeAudioBtn');
            if (!transcribeBtn) return;

            // Update button to processing state
            transcribeBtn.classList.add('processing');
            transcribeBtn.disabled = true;
            transcribeBtn.innerHTML = '⭐ Processing...';

            console.log('Starting transcription request for observation:', currentObservationId);

            google.script.run
                .withSuccessHandler(function(result) {
                    console.log('Transcription result:', result);

                    // Reset button state
                    transcribeBtn.classList.remove('processing');
                    transcribeBtn.disabled = false;
                    transcribeBtn.innerHTML = '⭐ Get Transcription';

                    if (result.success) {
                        if (result.cached) {
                            showToast('Using recent transcription (cached)', true);
                        } else {
                            showToast('Transcription completed successfully!', true);
                        }

                        // Show transcription results (Phase 3.2 implementation)
                        displayTranscriptionResults(result.data);
                    } else {
                        if (result.setupRequired) {
                            showToast('Gemini API key not configured. Please contact your administrator.', false);
                        } else {
                            showToast('Transcription failed: ' + result.error, false);
                        }
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Transcription request failed:', error);

                    // Reset button state
                    transcribeBtn.classList.remove('processing');
                    transcribeBtn.disabled = false;
                    transcribeBtn.innerHTML = '⭐ Get Transcription';

                    showToast('Failed to request transcription: ' + error.message, false);
                })
                .requestAudioTranscription(currentObservationId);
        }

        /**
         * Displays transcription results in modal
         * @param {Object} transcriptionData - The transcription data from server
         */
        function displayTranscriptionResults(transcriptionData) {
            if (!transcriptionData) {
                console.error('No transcription data provided');
                showToast('Error: No transcription data received', false);
                return;
            }

            console.log('Displaying transcription results:', transcriptionData);

            try {
                // Store transcription data globally for other functions
                window.currentTranscriptionData = transcriptionData;

                // Populate metadata section
                populateTranscriptionMetadata(transcriptionData);

                // Populate component tags section
                populateComponentTags(transcriptionData.componentTags || {});

                // Populate full transcription
                populateTranscriptionContent(transcriptionData.transcription || '');

                // Update insert button visibility based on script editor state
                updateInsertButtonState();

                // Show the modal
                openTranscriptionModal();

            } catch (error) {
                console.error('Error displaying transcription results:', error);
                showToast('Error displaying transcription: ' + error.message, false);
            }
        }

        /**
         * Populates the transcription metadata section
         * @param {Object} data - Transcription data
         */
        function populateTranscriptionMetadata(data) {
            const metadataDiv = document.getElementById('transcriptionMetadata');
            if (!metadataDiv) return;

            const processingTime = data.processingTime ? `${(data.processingTime / 1000).toFixed(1)}s` : 'Unknown';
            const fileCount = data.fileCount || 0;
            const timestamp = data.timestamp ? new Date(data.timestamp).toLocaleString() : 'Unknown';

            metadataDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-weight: 600;">⏱️ Processing Time:</span>
                        <span>${processingTime}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-weight: 600;">🎵 Audio Files:</span>
                        <span>${fileCount} file${fileCount !== 1 ? 's' : ''}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-weight: 600;">📅 Generated:</span>
                        <span>${timestamp}</span>
                    </div>
                </div>
            `;
        }

        /**
         * Populates the component tags section
         * @param {Object} componentTags - Component tags object
         */
        function populateComponentTags(componentTags) {
            const tagsDiv = document.getElementById('componentTagsContent');
            if (!tagsDiv) return;

            const tagKeys = Object.keys(componentTags);

            if (tagKeys.length === 0) {
                tagsDiv.innerHTML = `
                    <div style="text-align: center; color: #718096; font-style: italic; padding: 20px;">
                        No component tags were identified in this transcription.
                    </div>
                `;
                return;
            }

            let tagsHtml = '';
            tagKeys.forEach(component => {
                const content = componentTags[component];
                if (Array.isArray(content) && content.length > 0) {
                    tagsHtml += `
                        <div style="margin-bottom: 20px; border: 1px solid #e2e8f0; border-radius: 6px; overflow: hidden;">
                            <div style="background: #4a5568; color: white; padding: 10px 15px; font-weight: 600; font-size: 0.9rem;">
                                Component ${component.toUpperCase()}
                            </div>
                            <div style="padding: 15px;">
                                ${content.map(text => `
                                    <div style="background: white; border: 1px solid #e2e8f0; border-radius: 4px; padding: 12px; margin-bottom: 8px; font-size: 0.9rem; line-height: 1.5;">
                                        ${escapeHtml(text)}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
            });

            if (tagsHtml) {
                tagsDiv.innerHTML = tagsHtml;
            } else {
                tagsDiv.innerHTML = `
                    <div style="text-align: center; color: #718096; font-style: italic; padding: 20px;">
                        Component tags were detected but no content was extracted.
                    </div>
                `;
            }
        }

        /**
         * Populates the full transcription content
         * @param {string} transcription - The full transcription text
         */
        function populateTranscriptionContent(transcription) {
            const contentDiv = document.getElementById('transcriptionContent');
            if (!contentDiv) return;

            if (!transcription || transcription.trim() === '') {
                contentDiv.innerHTML = `
                    <div style="text-align: center; color: #718096; font-style: italic;">
                        No transcription content available.
                    </div>
                `;
                return;
            }

            // Format the transcription for display
            const formattedTranscription = formatTranscriptionForDisplay(transcription);
            contentDiv.innerHTML = formattedTranscription;
        }

        /**
         * Formats transcription text for display with proper styling
         * @param {string} text - Raw transcription text
         * @returns {string} Formatted HTML
         */
        function formatTranscriptionForDisplay(text) {
            return escapeHtml(text)
                .replace(/\*\*Speaker (\d+):\*\*/g, '<div style="font-weight: 600; color: #2d3748; margin-top: 15px; margin-bottom: 5px;">🎤 Speaker $1:</div>')
                .replace(/\*\[(\d{2}:\d{2})\]\*/g, '<span style="background: #bee3f8; color: #2b6cb0; padding: 2px 6px; border-radius: 3px; font-size: 0.8rem; font-weight: 500;">⏰ $1</span>')
                .replace(/\[(\d[a-f]):\]/g, '<span style="background: #d69e2e; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8rem; font-weight: 500; margin-right: 5px;">🏷️ $1</span>')
                .replace(/\n\n/g, '<br><br>')
                .replace(/\n/g, '<br>');
        }

        /**
         * Opens the transcription modal
         */
        function openTranscriptionModal() {
            const overlay = document.getElementById('transcriptionModalOverlay');
            if (!overlay) {
                console.error('Transcription modal overlay not found');
                return;
            }

            overlay.style.display = 'flex';
            setTimeout(() => {
                overlay.classList.add('show');
                document.body.style.overflow = 'hidden'; // Prevent background scrolling
            }, 10);

            // Add escape key listener
            const handleEscape = (event) => {
                if (event.key === 'Escape') {
                    closeTranscriptionModal();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);

            // Add click-outside-to-close
            overlay.addEventListener('click', function(event) {
                if (event.target === overlay) {
                    closeTranscriptionModal();
                }
            });
        }

        /**
         * Closes the transcription modal
         */
        function closeTranscriptionModal() {
            const overlay = document.getElementById('transcriptionModalOverlay');
            if (!overlay) return;

            overlay.classList.remove('show');
            document.body.style.overflow = ''; // Restore scrolling

            setTimeout(() => {
                overlay.style.display = 'none';
                // Clear transcription data
                window.currentTranscriptionData = null;
            }, 400);
        }

        /**
         * Simple HTML escaping function to prevent XSS
         * @param {string} unsafe - Unsafe text
         * @returns {string} Escaped text
         */
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        /**
         * Copies the full transcription to clipboard
         */
        function copyTranscriptionToClipboard() {
            if (!window.currentTranscriptionData || !window.currentTranscriptionData.transcription) {
                showToast('No transcription available to copy', false);
                return;
            }

            const transcription = window.currentTranscriptionData.transcription;

            // Use the modern Clipboard API if available
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(transcription)
                    .then(() => {
                        showToast('Transcription copied to clipboard!', true);
                        console.log('Transcription copied to clipboard via Clipboard API');
                    })
                    .catch(err => {
                        console.error('Failed to copy via Clipboard API:', err);
                        // Fallback to older method
                        fallbackCopyToClipboard(transcription);
                    });
            } else {
                // Fallback for older browsers or non-secure contexts
                fallbackCopyToClipboard(transcription);
            }
        }

        /**
         * Fallback copy method for browsers without Clipboard API
         * @param {string} text - Text to copy
         */
        function fallbackCopyToClipboard(text) {
            try {
                // Create a temporary textarea element
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.left = '-999999px';
                textarea.style.top = '-999999px';
                document.body.appendChild(textarea);

                // Select and copy the text
                textarea.focus();
                textarea.select();

                const successful = document.execCommand('copy');
                document.body.removeChild(textarea);

                if (successful) {
                    showToast('Transcription copied to clipboard!', true);
                    console.log('Transcription copied to clipboard via fallback method');
                } else {
                    throw new Error('execCommand failed');
                }
            } catch (err) {
                console.error('Failed to copy transcription:', err);
                showToast('Failed to copy transcription. Please select and copy manually.', false);
            }
        }

        /**
         * Updates the insert button state based on script editor availability
         */
        function updateInsertButtonState() {
            const insertBtn = document.getElementById('insertScriptBtn');
            if (!insertBtn) return;

            // Check if script editor is open and Quill instance exists
            const scriptModal = document.getElementById('scriptEditorModal');
            const isScriptEditorOpen = scriptModal && scriptModal.style.display !== 'none';
            const hasQuillInstance = typeof scriptQuill !== 'undefined' && scriptQuill !== null;

            if (isScriptEditorOpen && hasQuillInstance) {
                insertBtn.style.display = 'flex';
                insertBtn.disabled = false;
                console.log('Insert button enabled - script editor is open');
            } else {
                insertBtn.style.display = 'none';
                console.log('Insert button hidden - script editor not available');
            }
        }

        /**
         * Inserts the transcription into the script editor at cursor position
         */
        function insertTranscriptionIntoScript() {
            if (!window.currentTranscriptionData || !window.currentTranscriptionData.transcription) {
                showToast('No transcription available to insert', false);
                return;
            }

            // Check if script editor is available
            if (typeof scriptQuill === 'undefined' || scriptQuill === null) {
                showToast('Script editor is not open. Please open the script editor first.', false);
                return;
            }

            try {
                // Format transcription for script insertion
                const formattedText = formatTranscriptionForScript(window.currentTranscriptionData);

                // Get current cursor position or selection
                const range = scriptQuill.getSelection(true);
                const insertPosition = range ? range.index : scriptQuill.getLength();

                // Insert the formatted transcription
                scriptQuill.insertText(insertPosition, formattedText, 'user');

                // Position cursor after the inserted text
                const newPosition = insertPosition + formattedText.length;
                scriptQuill.setSelection(newPosition, 0, 'user');

                // Focus the script editor
                scriptQuill.focus();

                showToast('Transcription inserted into script editor!', true);
                console.log('Transcription successfully inserted into script editor');

                // Optionally close the transcription modal after insertion
                setTimeout(() => {
                    closeTranscriptionModal();
                }, 1000);

            } catch (error) {
                console.error('Error inserting transcription into script:', error);
                showToast('Failed to insert transcription: ' + error.message, false);
            }
        }

        /**
         * Formats transcription data for script editor insertion
         * @param {Object} transcriptionData - The complete transcription data
         * @returns {string} Formatted text for script insertion
         */
        function formatTranscriptionForScript(transcriptionData) {
            if (!transcriptionData.transcription) return '';

            let formattedText = '\n\n=== AI TRANSCRIPTION ===\n\n';

            // Add metadata
            if (transcriptionData.timestamp) {
                const date = new Date(transcriptionData.timestamp).toLocaleString();
                formattedText += `Generated: ${date}\n`;
            }
            if (transcriptionData.fileCount) {
                formattedText += `Audio files: ${transcriptionData.fileCount}\n`;
            }
            formattedText += '\n';

            // Add component tags if available
            const componentTags = transcriptionData.componentTags || {};
            const tagKeys = Object.keys(componentTags);
            if (tagKeys.length > 0) {
                formattedText += '--- Component Tags ---\n';
                tagKeys.forEach(component => {
                    const content = componentTags[component];
                    if (Array.isArray(content) && content.length > 0) {
                        formattedText += `\n[${component.toUpperCase()}]\n`;
                        content.forEach(text => {
                            formattedText += `• ${text}\n`;
                        });
                    }
                });
                formattedText += '\n';
            }

            // Add full transcription
            formattedText += '--- Full Transcription ---\n\n';
            formattedText += transcriptionData.transcription;
            formattedText += '\n\n=== END TRANSCRIPTION ===\n\n';

            return formattedText;
        }

        // === Transcription Testing Functions ===

        /**
         * Comprehensive unit testing for all transcription components
         * This function tests each component independently to ensure they work correctly
         */
        function runTranscriptionUnitTests() {
            console.log('🧪 Starting Transcription Unit Tests...');

            const testResults = {
                passed: 0,
                failed: 0,
                tests: []
            };

            // Test 1: escapeHtml function
            try {
                const testInput = '<script>alert("test")</script>';
                const expected = '&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;';
                const result = escapeHtml(testInput);

                if (result === expected) {
                    testResults.passed++;
                    testResults.tests.push('✅ escapeHtml function works correctly');
                } else {
                    testResults.failed++;
                    testResults.tests.push('❌ escapeHtml function failed');
                }
            } catch (error) {
                testResults.failed++;
                testResults.tests.push('❌ escapeHtml function threw error: ' + error.message);
            }

            // Test 2: formatTranscriptionForDisplay function
            try {
                const testTranscription = '**Speaker 1:** Hello world *[01:30]* This is a test [1a] Component reference.';
                const result = formatTranscriptionForDisplay(testTranscription);

                if (result.includes('🎤 Speaker 1:') && result.includes('⏰ 01:30') && result.includes('🏷️ 1a')) {
                    testResults.passed++;
                    testResults.tests.push('✅ formatTranscriptionForDisplay works correctly');
                } else {
                    testResults.failed++;
                    testResults.tests.push('❌ formatTranscriptionForDisplay failed formatting');
                }
            } catch (error) {
                testResults.failed++;
                testResults.tests.push('❌ formatTranscriptionForDisplay threw error: ' + error.message);
            }

            // Test 3: formatTranscriptionForScript function
            try {
                const mockData = {
                    transcription: 'Test transcription content',
                    timestamp: new Date().toISOString(),
                    fileCount: 2,
                    componentTags: {
                        '1a:': ['Test content for 1a']
                    }
                };
                const result = formatTranscriptionForScript(mockData);

                if (result.includes('=== AI TRANSCRIPTION ===') &&
                    result.includes('Generated:') &&
                    result.includes('[1A]') &&
                    result.includes('Test transcription content')) {
                    testResults.passed++;
                    testResults.tests.push('✅ formatTranscriptionForScript works correctly');
                } else {
                    testResults.failed++;
                    testResults.tests.push('❌ formatTranscriptionForScript failed formatting');
                }
            } catch (error) {
                testResults.failed++;
                testResults.tests.push('❌ formatTranscriptionForScript threw error: ' + error.message);
            }

            // Test 4: Modal functions exist and are callable
            try {
                if (typeof openTranscriptionModal === 'function' &&
                    typeof closeTranscriptionModal === 'function' &&
                    typeof displayTranscriptionResults === 'function') {
                    testResults.passed++;
                    testResults.tests.push('✅ All modal functions are defined');
                } else {
                    testResults.failed++;
                    testResults.tests.push('❌ Some modal functions are missing');
                }
            } catch (error) {
                testResults.failed++;
                testResults.tests.push('❌ Modal function test threw error: ' + error.message);
            }

            // Test 5: Copy to clipboard function exists
            try {
                if (typeof copyTranscriptionToClipboard === 'function' &&
                    typeof fallbackCopyToClipboard === 'function') {
                    testResults.passed++;
                    testResults.tests.push('✅ Copy functions are defined');
                } else {
                    testResults.failed++;
                    testResults.tests.push('❌ Copy functions are missing');
                }
            } catch (error) {
                testResults.failed++;
                testResults.tests.push('❌ Copy function test threw error: ' + error.message);
            }

            // Test 6: Script integration functions exist
            try {
                if (typeof insertTranscriptionIntoScript === 'function' &&
                    typeof updateInsertButtonState === 'function') {
                    testResults.passed++;
                    testResults.tests.push('✅ Script integration functions are defined');
                } else {
                    testResults.failed++;
                    testResults.tests.push('❌ Script integration functions are missing');
                }
            } catch (error) {
                testResults.failed++;
                testResults.tests.push('❌ Script integration test threw error: ' + error.message);
            }

            // Test 7: DOM elements exist
            try {
                const transcribeBtn = document.getElementById('transcribeAudioBtn');
                const modalOverlay = document.getElementById('transcriptionModalOverlay');

                if (transcribeBtn && modalOverlay) {
                    testResults.passed++;
                    testResults.tests.push('✅ Required DOM elements exist');
                } else {
                    testResults.failed++;
                    testResults.tests.push('❌ Required DOM elements missing');
                }
            } catch (error) {
                testResults.failed++;
                testResults.tests.push('❌ DOM element test threw error: ' + error.message);
            }

            // Test 8: Request transcription function exists and is bound correctly
            try {
                if (typeof requestTranscription === 'function') {
                    testResults.passed++;
                    testResults.tests.push('✅ requestTranscription function is defined');
                } else {
                    testResults.failed++;
                    testResults.tests.push('❌ requestTranscription function is missing');
                }
            } catch (error) {
                testResults.failed++;
                testResults.tests.push('❌ requestTranscription test threw error: ' + error.message);
            }

            // Display test results
            console.log('\n🧪 Transcription Unit Test Results:');
            console.log(`✅ Passed: ${testResults.passed}`);
            console.log(`❌ Failed: ${testResults.failed}`);
            console.log(`📊 Success Rate: ${(testResults.passed / (testResults.passed + testResults.failed) * 100).toFixed(1)}%`);

            testResults.tests.forEach(test => console.log(test));

            const successRate = testResults.passed / (testResults.passed + testResults.failed) * 100;
            if (successRate >= 90) {
                console.log('🎉 Unit tests PASSED! All core functionality is working.');
                showToast(`Unit tests passed! ${testResults.passed}/${testResults.passed + testResults.failed} tests successful`, true);
            } else {
                console.log('⚠️ Some unit tests FAILED. Check console for details.');
                showToast(`Unit tests completed: ${testResults.passed}/${testResults.passed + testResults.failed} passed`, false);
            }

            return testResults;
        }

        /**
         * Tests transcription UI with mock data
         */
        function testTranscriptionUIWithMockData() {
            console.log('🎭 Testing transcription UI with mock data...');

            const mockTranscriptionData = {
                transcription: '**Speaker 1:** This is a test transcription for component 1a. *[01:30]* The teacher demonstrates excellent classroom management.\n\n**Speaker 2:** I agree, the students are very engaged. *[02:15]* [1b] The learning environment is well organized.',
                componentTags: {
                    '1a:': ['The teacher demonstrates excellent classroom management'],
                    '1b:': ['The learning environment is well organized']
                },
                timestamp: new Date().toISOString(),
                processingTime: 15000,
                fileCount: 2
            };

            try {
                displayTranscriptionResults(mockTranscriptionData);
                console.log('✅ Mock data UI test successful');
                showToast('Mock transcription displayed successfully!', true);
                return true;
            } catch (error) {
                console.error('❌ Mock data UI test failed:', error);
                showToast('Mock transcription test failed: ' + error.message, false);
                return false;
            }
        }

        /**
         * Integration testing for the complete transcription workflow
         */
        function runTranscriptionIntegrationTests() {
            console.log('🔗 Starting Transcription Integration Tests...');

            const integrationResults = {
                passed: 0,
                failed: 0,
                tests: []
            };

            // Test 1: Button visibility logic with different states
            try {
                // Test without recordings
                window.currentObservation = { globalRecordings: { audio: [] } };
                updateTranscribeButtonVisibility();

                const transcribeBtn = document.getElementById('transcribeAudioBtn');
                if (transcribeBtn && transcribeBtn.style.display === 'none') {
                    integrationResults.passed++;
                    integrationResults.tests.push('✅ Button hidden when no recordings');
                } else {
                    integrationResults.failed++;
                    integrationResults.tests.push('❌ Button visibility logic failed (no recordings)');
                }

                // Test with recordings
                window.currentObservation = { globalRecordings: { audio: [{ url: 'test.mp3' }] } };
                updateTranscribeButtonVisibility();

                if (transcribeBtn && transcribeBtn.style.display !== 'none') {
                    integrationResults.passed++;
                    integrationResults.tests.push('✅ Button shown when recordings exist');
                } else {
                    integrationResults.failed++;
                    integrationResults.tests.push('❌ Button visibility logic failed (with recordings)');
                }
            } catch (error) {
                integrationResults.failed += 2;
                integrationResults.tests.push('❌ Button visibility test threw error: ' + error.message);
            }

            // Test 2: Modal open/close cycle
            try {
                const mockData = {
                    transcription: 'Test integration transcription',
                    componentTags: {},
                    timestamp: new Date().toISOString(),
                    processingTime: 5000,
                    fileCount: 1
                };

                // Open modal
                displayTranscriptionResults(mockData);
                const overlay = document.getElementById('transcriptionModalOverlay');

                if (overlay && overlay.style.display === 'flex') {
                    integrationResults.passed++;
                    integrationResults.tests.push('✅ Modal opens correctly');

                    // Close modal
                    closeTranscriptionModal();
                    setTimeout(() => {
                        if (overlay.style.display === 'none') {
                            integrationResults.passed++;
                            integrationResults.tests.push('✅ Modal closes correctly');
                        } else {
                            integrationResults.failed++;
                            integrationResults.tests.push('❌ Modal close failed');
                        }
                    }, 500);
                } else {
                    integrationResults.failed++;
                    integrationResults.tests.push('❌ Modal open failed');
                }
            } catch (error) {
                integrationResults.failed++;
                integrationResults.tests.push('❌ Modal open/close test threw error: ' + error.message);
            }

            // Test 3: Insert button state with script editor states
            try {
                // Test without script editor
                window.scriptQuill = null;
                updateInsertButtonState();

                const insertBtn = document.getElementById('insertScriptBtn');
                if (insertBtn && insertBtn.style.display === 'none') {
                    integrationResults.passed++;
                    integrationResults.tests.push('✅ Insert button hidden without script editor');
                } else {
                    integrationResults.failed++;
                    integrationResults.tests.push('❌ Insert button state logic failed');
                }
            } catch (error) {
                integrationResults.failed++;
                integrationResults.tests.push('❌ Insert button test threw error: ' + error.message);
            }

            // Display results after a brief delay to account for async operations
            setTimeout(() => {
                console.log('\n🔗 Integration Test Results:');
                console.log(`✅ Passed: ${integrationResults.passed}`);
                console.log(`❌ Failed: ${integrationResults.failed}`);

                const total = integrationResults.passed + integrationResults.failed;
                if (total > 0) {
                    console.log(`📊 Success Rate: ${(integrationResults.passed / total * 100).toFixed(1)}%`);
                }

                integrationResults.tests.forEach(test => console.log(test));

                if (integrationResults.passed >= integrationResults.failed) {
                    console.log('🎉 Integration tests PASSED!');
                    showToast('Integration tests passed!', true);
                } else {
                    console.log('⚠️ Some integration tests FAILED.');
                    showToast('Integration tests completed with issues', false);
                }
            }, 600);

            return integrationResults;
        }

        /**
         * Regression testing to ensure existing functionality is unaffected
         */
        function runTranscriptionRegressionTests() {
            console.log('🔄 Starting Transcription Regression Tests...');

            const regressionResults = {
                passed: 0,
                failed: 0,
                tests: []
            };

            // Test 1: Existing recording functions still work
            try {
                if (typeof toggleAudioRecording === 'function' &&
                    typeof toggleVideoRecording === 'function') {
                    regressionResults.passed++;
                    regressionResults.tests.push('✅ Recording functions still exist');
                } else {
                    regressionResults.failed++;
                    regressionResults.tests.push('❌ Recording functions missing or modified');
                }
            } catch (error) {
                regressionResults.failed++;
                regressionResults.tests.push('❌ Recording function test threw error: ' + error.message);
            }

            // Test 2: Script editor functions still work
            try {
                if (typeof openScriptEditor === 'function' &&
                    typeof closeScriptEditor === 'function') {
                    regressionResults.passed++;
                    regressionResults.tests.push('✅ Script editor functions still exist');
                } else {
                    regressionResults.failed++;
                    regressionResults.tests.push('❌ Script editor functions missing or modified');
                }
            } catch (error) {
                regressionResults.failed++;
                regressionResults.tests.push('❌ Script editor function test threw error: ' + error.message);
            }

            // Test 3: Observation management functions still work
            try {
                if (typeof loadSelectedView === 'function' &&
                    typeof clearFilters === 'function' &&
                    typeof handleRubricData === 'function') {
                    regressionResults.passed++;
                    regressionResults.tests.push('✅ Observation management functions still exist');
                } else {
                    regressionResults.failed++;
                    regressionResults.tests.push('❌ Observation management functions missing or modified');
                }
            } catch (error) {
                regressionResults.failed++;
                regressionResults.tests.push('❌ Observation management test threw error: ' + error.message);
            }

            // Test 4: Core UI functions still work
            try {
                if (typeof showToast === 'function' &&
                    typeof showLoading === 'function' &&
                    typeof hideLoading === 'function' &&
                    typeof showError === 'function') {
                    regressionResults.passed++;
                    regressionResults.tests.push('✅ Core UI functions still exist');
                } else {
                    regressionResults.failed++;
                    regressionResults.tests.push('❌ Core UI functions missing or modified');
                }
            } catch (error) {
                regressionResults.failed++;
                regressionResults.tests.push('❌ Core UI function test threw error: ' + error.message);
            }

            // Test 5: Welcome modal still works (original modal system)
            try {
                if (typeof showWelcomeModal === 'function' &&
                    typeof closeWelcomeModal === 'function') {
                    regressionResults.passed++;
                    regressionResults.tests.push('✅ Welcome modal functions still exist');
                } else {
                    regressionResults.failed++;
                    regressionResults.tests.push('❌ Welcome modal functions missing or modified');
                }
            } catch (error) {
                regressionResults.failed++;
                regressionResults.tests.push('❌ Welcome modal test threw error: ' + error.message);
            }

            // Test 6: No global namespace pollution
            try {
                const knownGlobals = ['currentObservationId', 'currentObservedUser', 'scriptQuill', 'recordingState'];
                const unexpectedGlobals = [];

                for (let prop in window) {
                    if (prop.toLowerCase().includes('transcription') || prop.toLowerCase().includes('gemini')) {
                        if (prop !== 'currentTranscriptionData') {
                            unexpectedGlobals.push(prop);
                        }
                    }
                }

                if (unexpectedGlobals.length === 0) {
                    regressionResults.passed++;
                    regressionResults.tests.push('✅ No unexpected global variables added');
                } else {
                    regressionResults.failed++;
                    regressionResults.tests.push('❌ Unexpected globals found: ' + unexpectedGlobals.join(', '));
                }
            } catch (error) {
                regressionResults.failed++;
                regressionResults.tests.push('❌ Global namespace test threw error: ' + error.message);
            }

            // Display results
            console.log('\n🔄 Regression Test Results:');
            console.log(`✅ Passed: ${regressionResults.passed}`);
            console.log(`❌ Failed: ${regressionResults.failed}`);

            const total = regressionResults.passed + regressionResults.failed;
            if (total > 0) {
                console.log(`📊 Success Rate: ${(regressionResults.passed / total * 100).toFixed(1)}%`);
            }

            regressionResults.tests.forEach(test => console.log(test));

            if (regressionResults.failed === 0) {
                console.log('🎉 Regression tests PASSED! No existing functionality was broken.');
                showToast('Regression tests passed - no functionality broken!', true);
            } else {
                console.log('⚠️ Some regression tests FAILED. Existing functionality may be affected.');
                showToast('Regression tests found issues with existing functionality', false);
            }

            return regressionResults;
        }

        /**
         * Runs all transcription tests (unit, integration, regression)
         */
        function runAllTranscriptionTests() {
            console.log('🚀 Running Complete Transcription Test Suite...');

            const unitResults = runTranscriptionUnitTests();
            setTimeout(() => {
                const integrationResults = runTranscriptionIntegrationTests();
                setTimeout(() => {
                    const regressionResults = runTranscriptionRegressionTests();

                    // Summary report after all tests complete
                    setTimeout(() => {
                        const totalPassed = unitResults.passed + integrationResults.passed + regressionResults.passed;
                        const totalFailed = unitResults.failed + integrationResults.failed + regressionResults.failed;
                        const totalTests = totalPassed + totalFailed;

                        console.log('\n🏆 COMPLETE TEST SUITE SUMMARY:');
                        console.log(`📊 Total Tests: ${totalTests}`);
                        console.log(`✅ Total Passed: ${totalPassed}`);
                        console.log(`❌ Total Failed: ${totalFailed}`);
                        console.log(`🎯 Overall Success Rate: ${(totalPassed / totalTests * 100).toFixed(1)}%`);

                        if (totalFailed === 0) {
                            console.log('🎉 ALL TESTS PASSED! Transcription feature is ready for production.');
                            showToast('🎉 All transcription tests passed! Feature is ready for use.', true, 5000);
                        } else if (totalPassed / totalTests >= 0.9) {
                            console.log('✅ TESTS MOSTLY PASSED! Minor issues detected.');
                            showToast('✅ Transcription tests mostly passed with minor issues.', true, 3000);
                        } else {
                            console.log('⚠️ SIGNIFICANT ISSUES DETECTED! Review required before production.');
                            showToast('⚠️ Transcription tests found significant issues.', false, 5000);
                        }
                    }, 1000);
                }, 1000);
            }, 1000);
        }

        // === Observation State Management Functions ===
        
        /**
         * Clears all observation-related state to prevent cross-contamination between observations
         */
        function clearObservationState() {
            console.log('Clearing all observation state...');
            
            // Clear observation context
            currentObservationId = null;
            clearWorkProductAnswersCache(); // Clear cache when clearing observation
            currentObservedUser = { email: null, name: null };

            // Clear script editor state
            clearScriptEditor();
            
            // Clear Quill editor instances and notes
            clearQuillInstances();
            
            // Clear any UI state
            resetObservationUI();
            
            console.log('Observation state cleared successfully');
        }
        
        /**
         * Clears script editor state and destroys the Quill instance
         */
        function clearScriptEditor() {
            // Clearing script editor state
            
            // CRITICAL: Clean up speech recognition first
            cleanupSpeechRecognition();
            
            // Clear auto-save timer
            if (scriptSaveDebounceTimer) {
                clearTimeout(scriptSaveDebounceTimer);
                scriptSaveDebounceTimer = null;
            }
            
            // Destroy Quill instance if it exists
            if (scriptQuill) {
                try {
                    // Destroying existing script Quill instance
                    
                    // Remove all event listeners
                    scriptQuill.off('text-change');
                    
                    // Get container element before destroying Quill
                    const container = document.getElementById('scriptEditor');
                    
                    // Clear the editor content
                    scriptQuill.setContents([], 'silent');
                    
                    // More thorough destruction of Quill instance
                    if (typeof scriptQuill.destroy === 'function') {
                        scriptQuill.destroy();
                    }
                    
                    // Nullify the JavaScript reference
                    scriptQuill = null;
                    
                    // CRITICAL: Clean up DOM elements completely
                    if (container) {
                        // Cleaning up script editor DOM
                        resetScriptEditorContainer();
                    }
                    
                } catch (error) {
                    console.warn('Error destroying script Quill instance:', error);
                    
                    // Emergency cleanup - force reset container even if Quill destruction failed
                    scriptQuill = null;
                    resetScriptEditorContainer();
                }
            }
            
            // Reset script state variables
            scriptContent = {};
            isScriptDirty = false;
            isSavingScript = false;
            
            // Reset UI state
            updateSaveButtonState();
            
            console.log('Script editor state cleared');
        }
        
        /**
         * Destroys all Quill editor instances and clears notes data
         */
        function clearQuillInstances() {
            console.log('Clearing all Quill instances and notes data...');
            
            // Destroy all existing Quill instances
            if (window.globalQuillInstances) {
                Object.keys(window.globalQuillInstances).forEach(componentId => {
                    const editor = window.globalQuillInstances[componentId];
                    if (editor && typeof editor.off === 'function') {
                        try {
                            // Remove all event listeners
                            editor.off('text-change');
                            // Clear the editor content
                            editor.setContents([], 'silent');
                            
                            // Clear the __quill reference from the DOM element
                            const editorElement = document.getElementById(`notesEditor-${componentId}`);
                            if (editorElement && editorElement.__quill) {
                                delete editorElement.__quill;
                            }
                        } catch (error) {
                            console.warn(`Error destroying Quill instance for ${componentId}:`, error);
                        }
                    }
                });
            }
            
            // Reset global storage objects
            window.globalQuillInstances = {};
            window.globalObservationNotes = {};
            
            console.log('All Quill instances and notes data cleared');
        }
        
        /**
         * Resets observation-related UI elements to default state
         */
        function resetObservationUI() {
            console.log('Resetting observation UI...');
            
            // Close script editor modal if open
            const scriptModal = document.getElementById('scriptEditorModal');
            if (scriptModal) {
                scriptModal.style.display = 'none';
            }
            
            // Reset any expanded evidence sections
            const evidenceSections = document.querySelectorAll('[id^="evidence-content-"]');
            evidenceSections.forEach(section => {
                section.style.display = 'none';
            });
            
            // Reset chevron indicators
            const chevrons = document.querySelectorAll('[id^="evidence-chevron-"]');
            chevrons.forEach(chevron => {
                chevron.textContent = '▶';
            });
            
            // Clear any temporary UI states from sessionStorage related to evidence
            try {
                const storagePrefix = 'evidenceState_';
                Object.keys(sessionStorage).forEach(key => {
                    if (key.startsWith(storagePrefix)) {
                        sessionStorage.removeItem(key);
                    }
                });
            } catch (error) {
                console.warn('Error clearing evidence state from sessionStorage:', error);
            }
            
            console.log('Observation UI reset completed');
        }
        
        /**
         * Removes all orphaned Quill elements globally from the document
         * This prevents toolbar duplication issues when recreating editors
         */
        function removeOrphanedQuillElements() {
            let removedCount = 0;
            
            try {
                // Find all Quill toolbars globally (not just in script editor)
                const orphanedToolbars = document.querySelectorAll('.ql-toolbar');
                orphanedToolbars.forEach(toolbar => {
                    console.log('Removing orphaned Quill toolbar:', toolbar);
                    toolbar.remove();
                    removedCount++;
                });
                
                // Find all Quill containers globally
                const orphanedContainers = document.querySelectorAll('.ql-container');
                orphanedContainers.forEach(container => {
                    // Only remove if not inside our target script editor
                    const scriptEditor = document.getElementById('scriptEditor');
                    if (!scriptEditor || !scriptEditor.contains(container)) {
                        console.log('Removing orphaned Quill container:', container);
                        container.remove();
                        removedCount++;
                    }
                });
                
                // Find all Quill editors globally
                const orphanedEditors = document.querySelectorAll('.ql-editor');
                orphanedEditors.forEach(editor => {
                    // Only remove if not inside our target script editor
                    const scriptEditor = document.getElementById('scriptEditor');
                    if (!scriptEditor || !scriptEditor.contains(editor)) {
                        console.log('Removing orphaned Quill editor:', editor);
                        editor.remove();
                        removedCount++;
                    }
                });
                
                if (removedCount > 0) {
                    console.log(`Removed ${removedCount} orphaned Quill elements globally`);
                }
                
                return removedCount;
                
            } catch (error) {
                console.error('Error removing orphaned Quill elements:', error);
                return 0;
            }
        }

        /**
         * Completely resets the script editor container to pristine state
         * This utility function ensures no leftover Quill DOM elements remain
         */
        function resetScriptEditorContainer() {
            // Resetting script editor container
            
            // Clean up speech recognition first
            cleanupSpeechRecognition();
            
            // FIRST: Remove any orphaned Quill elements globally (fixes toolbar duplication)
            const orphanedCount = removeOrphanedQuillElements();
            if (orphanedCount > 0) {
                console.log(`Fixed toolbar duplication: removed ${orphanedCount} orphaned elements`);
            }
            
            const container = document.getElementById('scriptEditor');
            if (!container) {
                console.warn('Script editor container not found');
                return false;
            }
            
            try {
                // Count existing toolbars for diagnostics
                const existingToolbars = document.querySelectorAll('#scriptEditor .ql-toolbar').length;
                if (existingToolbars > 0) {
                    console.log(`Found ${existingToolbars} existing toolbars in container before cleanup`);
                }
                
                // Remove all Quill-generated content
                container.innerHTML = '';
                
                // Reset all CSS classes (Quill adds classes like 'ql-container')
                container.className = '';
                
                // Remove any Quill-specific data attributes
                container.removeAttribute('data-quill');
                container.removeAttribute('contenteditable');
                
                // Remove any Quill-added inline styles
                container.removeAttribute('style');
                
                // Clear any remaining Quill references
                if (container.__quill) {
                    delete container.__quill;
                }
                
                // Final verification: ensure no toolbars remain
                const remainingToolbars = document.querySelectorAll('#scriptEditor .ql-toolbar').length;
                if (remainingToolbars > 0) {
                    console.warn(`Warning: ${remainingToolbars} toolbars still remain after cleanup`);
                }
                
                console.log('Script editor container reset successfully');
                return true;
                
            } catch (error) {
                console.error('Error resetting script editor container:', error);
                
                // Emergency fallback - try to at least clear innerHTML
                try {
                    container.innerHTML = '';
                } catch (e) {
                    console.error('Emergency container reset also failed:', e);
                }
                return false;
            }
        }
        
        /**
         * Diagnostic function to detect and fix broken observation state
         */
        function diagnoseAndRecoverObservationState() {
            console.log('Running observation state diagnostics...');
            
            const issues = [];
            const fixes = [];
            
            // Check for orphaned currentObservationId without proper context
            if (currentObservationId && !currentObservedUser.email) {
                issues.push('currentObservationId set but no observed user context');
                currentObservationId = null;
                fixes.push('Cleared orphaned observation ID');
            }
            
            // Check for broken script editor state
            if (scriptQuill && !currentObservationId) {
                issues.push('Script editor exists but no observation context');
                clearScriptEditor();
                fixes.push('Cleared orphaned script editor');
            }
            
            // Check for leftover Quill DOM elements without corresponding JS instance
            const scriptContainer = document.getElementById('scriptEditor');
            if (scriptContainer && !scriptQuill) {
                const hasQuillElements = scriptContainer.querySelector('.ql-toolbar, .ql-container, .ql-editor');
                if (hasQuillElements) {
                    issues.push('Found orphaned Quill DOM elements in script editor');
                    resetScriptEditorContainer();
                    fixes.push('Cleaned up orphaned script editor DOM elements');
                }
            }
            
            // Check for broken Quill instances
            if (window.globalQuillInstances) {
                Object.keys(window.globalQuillInstances).forEach(componentId => {
                    const editor = window.globalQuillInstances[componentId];
                    if (!editor || !editor.root || !editor.root.parentNode) {
                        issues.push(`Broken Quill instance for component ${componentId}`);
                        delete window.globalQuillInstances[componentId];
                        fixes.push(`Removed broken Quill instance for ${componentId}`);
                    }
                });
            }
            
            // Check for notes data without observation context
            if (window.globalObservationNotes && !currentObservationId) {
                const notesCount = Object.keys(window.globalObservationNotes).length;
                if (notesCount > 0) {
                    issues.push(`${notesCount} orphaned notes entries without observation context`);
                    window.globalObservationNotes = {};
                    fixes.push('Cleared orphaned notes data');
                }
            }
            
            // Check for mismatched DOM and JS state
            const scriptModal = document.getElementById('scriptEditorModal');
            if (scriptModal && scriptModal.style.display !== 'none' && !scriptQuill) {
                issues.push('Script modal open but no Quill instance');
                scriptModal.style.display = 'none';
                fixes.push('Closed orphaned script modal');
            }
            
            if (issues.length > 0) {
                console.warn('Observation state issues detected:', issues);
                console.log('Applied fixes:', fixes);
                showToast(`Recovered from ${issues.length} state issue(s)`, true);
            } else {
                console.log('Observation state is healthy');
            }
            
            return { issues, fixes };
        }
        
        /**
         * Emergency state reset function for when things go really wrong
         */
        function emergencyStateReset() {
            console.warn('EMERGENCY: Performing complete state reset...');
            
            try {
                // Force clear all state
                currentObservationId = null;
                clearWorkProductAnswersCache(); // Clear cache when clearing observation
                currentObservedUser = { email: null, name: null };

                // Destroy script editor
                if (scriptQuill) {
                    try {
                        scriptQuill.off('text-change');
                        scriptQuill = null;
                    } catch (e) {
                        console.warn('Error destroying script Quill:', e);
                        scriptQuill = null;
                    }
                }
                
                // Force clean script editor container
                resetScriptEditorContainer();
                
                scriptContent = {};
                isScriptDirty = false;
                isSavingScript = false;
                
                if (scriptSaveDebounceTimer) {
                    clearTimeout(scriptSaveDebounceTimer);
                    scriptSaveDebounceTimer = null;
                }
                
                // Destroy all Quill instances
                if (window.globalQuillInstances) {
                    Object.keys(window.globalQuillInstances).forEach(componentId => {
                        try {
                            const editor = window.globalQuillInstances[componentId];
                            if (editor && editor.off) {
                                editor.off('text-change');
                            }
                            const element = document.getElementById(`notesEditor-${componentId}`);
                            if (element && element.__quill) {
                                delete element.__quill;
                            }
                        } catch (e) {
                            console.warn(`Error cleaning up Quill for ${componentId}:`, e);
                        }
                    });
                }
                window.globalQuillInstances = {};
                window.globalObservationNotes = {};
                
                // Reset UI
                const scriptModal = document.getElementById('scriptEditorModal');
                if (scriptModal) {
                    scriptModal.style.display = 'none';
                }
                
                console.log('Emergency state reset completed');
                showToast('Emergency state reset completed', true);
                
            } catch (error) {
                console.error('Error during emergency reset:', error);
                showToast('Emergency reset encountered errors - please refresh page', false);
            }
        }
        
        // === Periodic State Monitoring ===
        
        let stateMonitorInterval = null;
        
        /**
         * Starts periodic monitoring of observation state
         */
        function startStateMonitoring() {
            if (stateMonitorInterval) {
                clearInterval(stateMonitorInterval);
            }
            
            stateMonitorInterval = setInterval(() => {
                try {
                    diagnoseAndRecoverObservationState();
                } catch (error) {
                    console.error('Error during state monitoring:', error);
                }
            }, 30000); // Check every 30 seconds
            
            console.log('State monitoring started');
        }
        
        /**
         * Stops periodic state monitoring
         */
        function stopStateMonitoring() {
            if (stateMonitorInterval) {
                clearInterval(stateMonitorInterval);
                stateMonitorInterval = null;
                console.log('State monitoring stopped');
            }
        }
        
        // Start monitoring when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Clean up old session storage backups on page load
            cleanupOldSessionBackups();
            
            setTimeout(() => {
                startStateMonitoring();
            }, 5000); // Start monitoring after 5 seconds
        });
        
        // === Debug and Testing Functions ===
        
        /**
         * Debug function to check script editor state and DOM
         * Can be called from browser console: window.debugScriptEditor()
         */
        window.debugScriptEditor = function() {
            const container = document.getElementById('scriptEditor');
            const result = {
                hasContainer: !!container,
                hasScriptQuill: !!scriptQuill,
                containerHTML: container ? container.innerHTML : null,
                containerClasses: container ? Array.from(container.classList) : null,
                quillToolbars: document.querySelectorAll('#scriptEditor .ql-toolbar').length,
                quillContainers: document.querySelectorAll('#scriptEditor .ql-container').length,
                quillEditors: document.querySelectorAll('#scriptEditor .ql-editor').length,
                containerAttributes: container ? Array.from(container.attributes).map(attr => `${attr.name}="${attr.value}"`) : null
            };
            
            console.log('Script Editor Debug Info:', result);
            
            if (result.quillToolbars > 1) {
                console.warn(`🚨 TOOLBAR DUPLICATION DETECTED: ${result.quillToolbars} toolbars found!`);
            } else if (result.quillToolbars === 1) {
                console.log('✅ Script editor state is clean (1 toolbar)');
            } else {
                console.log('ℹ️ No toolbars found (editor not initialized)');
            }
            
            return result;
        };
        
        /**
         * Test function to simulate opening/closing script editor multiple times
         * Can be called from browser console: window.testScriptEditorCleanup()
         */
        window.testScriptEditorCleanup = function(iterations = 3) {
            // Development testing function - remove in production
            
            if (!currentObservationId) {
                console.error('Cannot test: No active observation. Please load an observation first.');
                return;
            }
            
            for (let i = 0; i < iterations; i++) {
                console.log(`\n--- Test iteration ${i + 1} ---`);
                
                // Open script editor
                openScriptEditor();
                window.debugScriptEditor();
                
                // Close script editor
                closeScriptEditor();
                
                // Force clear to simulate observation switching
                clearScriptEditor();
                window.debugScriptEditor();
            }
            
            console.log('\n🏁 Test completed. Check results above.');
        };

        // === Work Product Answer Functions ===

        function refreshWorkProductAnswers(forceRefresh = false) {
            if (!currentObservationId) {
                showToast('No observation selected');
                return;
            }

            // Check if this is a work product observation
            if (!window.currentObservationType || window.currentObservationType !== 'Work Product') {
                return;
            }

            // Check client-side cache first (unless force refresh is requested)
            if (!forceRefresh) {
                const cachedAnswers = workProductAnswersCache.get(currentObservationId);
                if (cachedAnswers) {
                    console.log('Using cached work product answers for observation:', currentObservationId);
                    displayWorkProductAnswers(cachedAnswers);
                    return;
                }
            } else {
                // Clear specific cache entry for force refresh
                workProductAnswersCache.delete(currentObservationId);
                console.log('Force refresh requested - cleared cache for observation:', currentObservationId);
            }

            showLoading('Loading staff responses...');
            google.script.run
                .withSuccessHandler(function(result) {
                    // Cache the result if successful
                    if (result.success) {
                        workProductAnswersCache.set(currentObservationId, result);
                    }
                    displayWorkProductAnswers(result);
                })
                .withFailureHandler(function(error) {
                    hideLoading();
                    console.error('Failed to load answers:', error);
                    showToast('Failed to load staff responses');
                })
                .getWorkProductAnswersForClient(currentObservationId);
        }

        function displayWorkProductAnswers(result) {
            hideLoading();
            const container = document.getElementById('workProductAnswersDisplay');
            if (!container) return;

            if (!result.success) {
                container.innerHTML = '<p style="color: #dc2626;">Error loading answers: ' + result.error + '</p>';
                return;
            }

            if (!result.answers || result.answers.length === 0) {
                container.innerHTML = '<p style="color: #6b7280; font-style: italic;">No staff responses yet.</p>';
                return;
            }

            // Load questions to match with answers
            google.script.run
                .withSuccessHandler(function(questionsResult) {
                    if (questionsResult.success) {
                        displayAnswersWithQuestions(result.answers, questionsResult.questions);
                    }
                })
                .getWorkProductQuestionsForClient();
        }

        function displayAnswersWithQuestions(answers, questions) {
            const container = document.getElementById('workProductAnswersDisplay');
            if (!container) return;

            let html = '';
            questions.forEach(question => {
                const answer = answers.find(a => a.questionId === question.questionId);
                const answerText = answer ? answer.answerText : 'No response yet';

                html += `
                    <div style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 4px; border-left: 3px solid #10b981;">
                        <strong style="color: #374151;">${question.questionText}</strong>
                        <div style="margin-top: 5px; color: #6b7280; white-space: pre-wrap;">${answerText}</div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Show/hide work product answers section based on observation type
        function toggleWorkProductAnswersSection(show) {
            const section = document.getElementById('workProductAnswersSection');
            if (section) {
                section.style.display = show ? 'block' : 'none';
            }
        }

        // === Script Editor Mode Switching Functions ===

        // Global state for script editor mode
        let scriptEditorMode = 'view'; // 'view' or 'edit'
        let cachedStaffResponses = null; // Cache staff responses for mode switching

        function switchToViewMode() {
            console.log('Switching to View-Only mode');
            scriptEditorMode = 'view';

            // Update button states
            document.getElementById('viewModeBtn').classList.add('active');
            document.getElementById('editModeBtn').classList.remove('active');

            // Hide Quill editor and component tagging toolbar
            document.getElementById('scriptEditor').style.display = 'none';
            document.querySelector('.script-tagging-toolbar').style.display = 'none';

            // Show staff responses in view-only format
            showStaffResponsesViewOnly();
        }

        function switchToEditMode() {
            console.log('Switching to Edit & Tag mode');
            scriptEditorMode = 'edit';

            // Update button states
            document.getElementById('editModeBtn').classList.add('active');
            document.getElementById('viewModeBtn').classList.remove('active');

            // Show Quill editor and component tagging toolbar
            document.getElementById('scriptEditor').style.display = 'block';
            document.querySelector('.script-tagging-toolbar').style.display = 'block';

            // Hide view-only display and populate Quill editor
            hideStaffResponsesViewOnly();
            populateQuillWithStaffResponses();
        }

        function showStaffResponsesViewOnly() {
            // Create or show the view-only container
            let viewContainer = document.getElementById('staffResponsesViewOnly');
            if (!viewContainer) {
                viewContainer = document.createElement('div');
                viewContainer.id = 'staffResponsesViewOnly';
                viewContainer.className = 'staff-responses-view-only';

                // Insert before the script editor
                const scriptEditor = document.getElementById('scriptEditor');
                scriptEditor.parentNode.insertBefore(viewContainer, scriptEditor);
            }

            viewContainer.style.display = 'block';

            // Load and display staff responses if we have them
            if (cachedStaffResponses) {
                displayStaffResponsesInViewMode(cachedStaffResponses);
            } else {
                // Load staff responses
                loadStaffResponsesForView();
            }
        }

        function hideStaffResponsesViewOnly() {
            const viewContainer = document.getElementById('staffResponsesViewOnly');
            if (viewContainer) {
                viewContainer.style.display = 'none';
            }
        }

        function loadStaffResponsesForView() {
            if (!currentObservationId || !window.currentObservationType || window.currentObservationType !== 'Work Product') {
                return;
            }

            const viewContainer = document.getElementById('staffResponsesViewOnly');
            if (viewContainer) {
                viewContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #6b7280;">Loading staff responses...</div>';
            }

            google.script.run
                .withSuccessHandler(function(result) {
                    if (result.success) {
                        cachedStaffResponses = result;
                        displayStaffResponsesInViewMode(result);
                    } else {
                        if (viewContainer) {
                            viewContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #dc2626;">Error loading responses: ' + result.error + '</div>';
                        }
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Failed to load staff responses:', error);
                    if (viewContainer) {
                        viewContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #dc2626;">Failed to load staff responses</div>';
                    }
                })
                .getWorkProductAnswersForClient(currentObservationId);
        }

        function displayStaffResponsesInViewMode(result) {
            const viewContainer = document.getElementById('staffResponsesViewOnly');
            if (!viewContainer) return;

            if (!result.answers || result.answers.length === 0) {
                viewContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #6b7280;">No staff responses available yet.</div>';
                return;
            }

            // Load questions for display
            google.script.run
                .withSuccessHandler(function(questionsResult) {
                    if (questionsResult.success) {
                        const questionsMap = {};
                        questionsResult.questions.forEach(q => {
                            questionsMap[q.questionId] = q.questionText;
                        });

                        let html = '';
                        result.answers.forEach(answer => {
                            const questionText = questionsMap[answer.questionId] || `Question ${answer.questionId}`;
                            html += `
                                <div class="response-item">
                                    <div class="response-question">${questionText}</div>
                                    <div class="response-answer">${answer.answerText || '<em style="color: #9ca3af;">No response provided</em>'}</div>
                                </div>
                            `;
                        });

                        viewContainer.innerHTML = html;
                    } else {
                        viewContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #dc2626;">Error loading questions for display</div>';
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Failed to load questions:', error);
                    // Fallback: show answers without question text
                    let html = '';
                    result.answers.forEach(answer => {
                        html += `
                            <div class="response-item">
                                <div class="response-question">Question ${answer.questionId}</div>
                                <div class="response-answer">${answer.answerText || '<em style="color: #9ca3af;">No response provided</em>'}</div>
                            </div>
                        `;
                    });
                    viewContainer.innerHTML = html;
                })
                .getWorkProductQuestionsForClient();
        }

        function populateQuillWithStaffResponses() {
            if (!scriptQuill || !cachedStaffResponses) {
                return;
            }

            // Load questions and populate Quill editor
            google.script.run
                .withSuccessHandler(function(questionsResult) {
                    if (questionsResult.success && cachedStaffResponses.answers) {
                        const questionsMap = {};
                        questionsResult.questions.forEach(q => {
                            questionsMap[q.questionId] = q.questionText;
                        });

                        let content = '';
                        cachedStaffResponses.answers.forEach((answer, index) => {
                            const questionText = questionsMap[answer.questionId] || `Question ${answer.questionId}`;
                            content += `${questionText}\n\n${answer.answerText || 'No response provided'}\n\n---\n\n`;
                        });

                        scriptQuill.setText(content);
                        console.log('Populated Quill editor with staff responses');
                    }
                })
                .getWorkProductQuestionsForClient();
        }

        function initializeScriptEditorMode() {
            // Show mode toggle only for work product observations
            if (window.currentObservationType === 'Work Product') {
                document.getElementById('scriptEditorModeToggle').style.display = 'block';
                // Start in view mode by default
                switchToViewMode();
            } else {
                document.getElementById('scriptEditorModeToggle').style.display = 'none';
                // For non-work product observations, ensure normal mode
                scriptEditorMode = 'edit';
                document.getElementById('scriptEditor').style.display = 'block';
                document.querySelector('.script-tagging-toolbar').style.display = 'block';
                hideStaffResponsesViewOnly();
            }
        }

        // Stop monitoring when page unloads
        window.addEventListener('beforeunload', function(e) {
            stopStateMonitoring();
            
            // CRITICAL: Auto-save script content if STT is running or content is dirty
            if ((sttIsRecording || isScriptDirty) && scriptQuill && currentObservationId) {
                // Attempt synchronous save - this is limited but better than losing data
                try {
                    const content = scriptQuill.getContents();
                    const htmlContent = scriptQuill.root.innerHTML;
                    
                    // Store in sessionStorage as backup
                    sessionStorage.setItem(`script_backup_${currentObservationId}`, JSON.stringify({
                        content: content,
                        html: htmlContent,
                        timestamp: Date.now()
                    }));
                    
                    console.log('Script content backed up to sessionStorage before unload');
                } catch (error) {
                    console.error('Error backing up script content:', error);
                }
                
                // Show browser warning
                e.preventDefault();
                e.returnValue = 'Speech-to-text is running and script content may not be saved. Are you sure you want to leave?';
                return 'Speech-to-text is running and script content may not be saved. Are you sure you want to leave?';
            }
            
            // CRITICAL: Clean up speech recognition on page unload
            cleanupSpeechRecognition();
        });

        // === Script Editor Functions ===
        const SCRIPT_EDITOR_CONSTANTS = <?!= JSON.stringify(scriptEditorSettings) ?>;
        let scriptQuill = null;
        let scriptContent = {};
        const SILENT_SAVE_DEBOUNCE_MS = 5000;
        let isScriptDirty = false;
        let scriptSaveDebounceTimer;
        let isSavingScript = false;

        function updateSaveButtonState() {
            const saveBtn = document.getElementById('saveScriptBtn');
            if (!saveBtn) return;

            if (isScriptDirty) {
                saveBtn.textContent = 'Save all changes';
                saveBtn.disabled = false;
                saveBtn.classList.remove('btn-secondary');
                saveBtn.classList.add('btn-primary');
            } else {
                saveBtn.textContent = 'Saved!';
                saveBtn.disabled = true;
                saveBtn.classList.remove('btn-primary');
                saveBtn.classList.add('btn-secondary');
            }
        }

        // Encapsulated speech recognition state
        let sttRecognitionInstance = null;
        let sttIsRecording = false;
        let sttTimeoutId = null;
        let sttAutoRestartTimeoutId = null;
        let sttIsInitializing = false; // Prevent race conditions during initialization
        let sttLastTranscriptIndex = 0; // Track processed results to avoid duplicates
        let sttFinalTextEndPosition = null; // Track where final text ends for final-only transcription
        // For long observation sessions (20-40 minutes), we need continuous recognition
        // Chrome has built-in timeouts (~60s), so we auto-restart to maintain continuity
        const STT_AUTO_RESTART_INTERVAL_MS = 50000; // 50 second auto-restart to prevent browser timeout
        const STT_SESSION_CLEANUP_INTERVAL_MS = 5 * 60 * 1000; // Clean up old session storage every 5 minutes

        // Cleanup function to ensure proper speech recognition cleanup
        function cleanupSpeechRecognition() {
            if (sttRecognitionInstance) {
                try {
                    sttRecognitionInstance.stop();
                } catch (e) {
                    console.warn('Error stopping speech recognition:', e);
                }
                sttRecognitionInstance = null;
            }
            sttIsRecording = false;
            sttIsInitializing = false;
            sttLastTranscriptIndex = 0;
            
            // Reset final text position
            sttFinalTextEndPosition = null;
            
            // Clear timeout if it exists
            if (sttTimeoutId) {
                clearTimeout(sttTimeoutId);
                sttTimeoutId = null;
            }
            
            // Clear auto-restart interval
            if (sttAutoRestartTimeoutId) {
                clearInterval(sttAutoRestartTimeoutId);
                sttAutoRestartTimeoutId = null;
            }
            
            // Reset button state if it exists
            const sttButton = document.querySelector('.ql-stt-button');
            if (sttButton) {
                sttButton.classList.remove('recording', 'processing');
                sttButton.innerHTML = '🎤';
                sttButton.title = 'Start speech-to-text recording';
                sttButton.setAttribute('aria-label', 'Start speech-to-text recording');
            }
        }

        function handleSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                // Enhanced browser detection for better user guidance
                const userAgent = navigator.userAgent;
                let browserInfo = 'Please use Chrome, Edge, or Safari';
                let additionalInfo = '';

                if (userAgent.includes('Firefox')) {
                    browserInfo = 'Firefox does not support speech recognition';
                    additionalInfo = ' - please switch to Chrome, Edge, or Safari for this feature';
                } else if (userAgent.includes('Chrome') && !userAgent.includes('Edge')) {
                    additionalInfo = ' - ensure you\'re using the latest version of Chrome';
                } else if (userAgent.includes('Safari') && !userAgent.includes('Chrome')) {
                    additionalInfo = ' - ensure Safari has microphone permissions enabled';
                } else if (userAgent.includes('Edge')) {
                    additionalInfo = ' - ensure you\'re using the latest version of Edge';
                } else {
                    additionalInfo = ' - this browser is not supported for speech recognition';
                }

                showToast(`Speech recognition is not supported. ${browserInfo}${additionalInfo}.`, false);
                
                // Disable the button visually if speech recognition is not supported
                const sttButton = document.querySelector('.ql-stt-button');
                if (sttButton) {
                    sttButton.disabled = true;
                    sttButton.innerHTML = '🎤❌';
                    sttButton.title = `Speech recognition not supported in this browser. ${browserInfo}.`;
                    sttButton.style.opacity = '0.5';
                }
                return;
            }

            const sttButton = document.querySelector('.ql-stt-button');
            if (!sttButton) {
                console.error('Speech-to-text button not found in the DOM.');
                return;
            }

            // Prevent race conditions during initialization
            if (sttIsInitializing) {
                // Prevent race conditions - ignoring duplicate initialization
                return;
            }

            // If already recording, stop the recording
            if (sttIsRecording) {
                cleanupSpeechRecognition();
                return;
            }

            // Set initializing state to prevent race conditions
            sttIsInitializing = true;
            sttButton.classList.add('processing');
            sttButton.innerHTML = '⏳';
            sttButton.title = 'Initializing speech recognition...';

            // Check microphone permissions before starting
            if (navigator.permissions) {
                navigator.permissions.query({ name: 'microphone' }).then(permissionStatus => {
                    // Double-check state in case user clicked button multiple times during async operation
                    if (sttIsRecording || !sttIsInitializing) {
                        sttIsInitializing = false;
                        return; // Already recording or canceled, ignore this request
                    }
                    
                    if (permissionStatus.state === 'denied') {
                        showToast('Microphone permission denied. Please allow microphone access and try again.', false);
                        sttIsInitializing = false;
                        sttButton.classList.remove('processing');
                        sttButton.innerHTML = '🎤';
                        sttButton.title = 'Start speech-to-text recording';
                        return;
                    }
                    startSpeechRecognition(sttButton);
                }).catch(() => {
                    // Fallback if permissions API not available
                    if (sttIsInitializing && !sttIsRecording) {
                        startSpeechRecognition(sttButton);
                    }
                });
            } else {
                // Fallback for browsers without permissions API
                if (sttIsInitializing && !sttIsRecording) {
                    startSpeechRecognition(sttButton);
                }
            }
        }

        // Final-only transcription helper function

        function insertFinalTranscript(finalText) {
            if (!scriptQuill) return;
            
            try {
                // Determine where to insert final text (accumulative transcription)
                let insertPosition;
                if (sttFinalTextEndPosition !== null) {
                    // Continue appending after previous final text
                    insertPosition = sttFinalTextEndPosition;
                } else {
                    // First final text - use current cursor position
                    const currentRange = scriptQuill.getSelection(true);
                    insertPosition = currentRange ? currentRange.index : 0;
                }
                
                // Insert final text with space
                const textToInsert = finalText + ' ';
                scriptQuill.insertText(insertPosition, textToInsert, 'user');
                
                // Update the final text end position for next insertion
                sttFinalTextEndPosition = insertPosition + textToInsert.length;
                
                // Position cursor after the new final text
                scriptQuill.setSelection(sttFinalTextEndPosition, 0, 'user');
                
            } catch (e) {
                console.warn('Error inserting final transcript:', e);
            }
        }

        function startSpeechRecognition(sttButton) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            try {
                sttRecognitionInstance = new SpeechRecognition();
                sttRecognitionInstance.lang = navigator.language || 'en-US';
                sttRecognitionInstance.continuous = true; // Continuous for long observation sessions (20-40 min)
                sttRecognitionInstance.interimResults = false; // Final results only for reliable transcription
                sttRecognitionInstance.maxAlternatives = 1;
                
                // Reset transcript index for new session
                sttLastTranscriptIndex = 0;
                
                // Initialize final text position for live captions
                const currentRange = scriptQuill.getSelection(true);
                sttFinalTextEndPosition = currentRange ? currentRange.index : 0;

                sttRecognitionInstance.addEventListener('start', () => {
                    sttIsRecording = true;
                    sttIsInitializing = false;
                    sttButton.classList.remove('processing');
                    sttButton.classList.add('recording');
                    sttButton.innerHTML = '🔴';
                    sttButton.title = 'Recording - Click to stop';
                    sttButton.setAttribute('aria-label', 'Stop speech-to-text recording');
                    showToast('Speech recognition started - speak now', true);
                });
            } catch (error) {
                console.error('Failed to create speech recognition instance:', error);
                showToast('Failed to initialize speech recognition. Please try again.', false);
                sttIsInitializing = false;
                sttButton.classList.remove('processing');
                sttButton.innerHTML = '🎤';
                sttButton.title = 'Start speech-to-text recording';
                return;
            }

            sttRecognitionInstance.addEventListener('result', e => {
                if (e.results && e.results.length > 0) {
                    // CRITICAL: Check if scriptQuill still exists before processing any results
                    if (!scriptQuill || typeof scriptQuill.getSelection !== 'function') {
                        console.warn('Script editor no longer available, stopping speech recognition');
                        cleanupSpeechRecognition();
                        return;
                    }
                    
                    // Process final results only - much simpler!
                    let hasNewFinalResults = false;
                    
                    // Process all NEW final results (avoid duplicates)
                    for (let i = sttLastTranscriptIndex; i < e.results.length; i++) {
                        if (e.results[i].length > 0 && e.results[i].isFinal) {
                            const transcript = e.results[i][0].transcript.trim();
                            if (transcript.length > 0) {
                                insertFinalTranscript(transcript);
                                hasNewFinalResults = true;
                            }
                        }
                    }
                    
                    // Update button if we processed new results
                    if (hasNewFinalResults) {
                        sttButton.innerHTML = '🔴';
                        sttButton.title = 'Recording - Click to stop';
                    }
                    
                    // Track processed results to avoid duplicates
                    sttLastTranscriptIndex = e.results.length;
                }
            });

            sttRecognitionInstance.addEventListener('error', (event) => {
                console.error('Speech recognition error:', event.error, event);
                const errorMessages = {
                    'not-allowed': 'Microphone access denied. Please allow microphone permissions and refresh the page.',
                    'no-speech': 'No speech detected. Speech recognition will continue automatically.',
                    'audio-capture': 'No microphone found. Please check your microphone connection and try again.',
                    'network': 'Network error occurred. Check your internet connection. Speech recognition will attempt to restart.',
                    'service-not-allowed': 'Speech service not allowed. This may be due to browser security settings.',
                    'bad-grammar': 'Speech recognition failed. This is usually temporary - please continue speaking.',
                    'language-not-supported': 'Your browser language is not supported. Try speaking in English or change your browser language.',
                    'aborted': 'Speech recognition was stopped.'
                };
                
                const message = errorMessages[event.error] || `Speech recognition error: ${event.error}. Please try again.`;
                
                // Don't show toast for common recoverable errors in continuous mode
                const recoverableErrors = ['no-speech', 'bad-grammar'];
                if (!recoverableErrors.includes(event.error)) {
                    showToast(message, false);
                }
                
                // Auto-retry for network errors in continuous mode
                if (event.error === 'network' && sttIsRecording) {
                    console.log('Network error detected, attempting auto-recovery in 2 seconds...');
                    setTimeout(() => {
                        if (sttIsRecording && !sttRecognitionInstance) {
                            // Attempting auto-recovery after network error
                            handleSpeechRecognition();
                        }
                    }, 2000);
                } else {
                    cleanupSpeechRecognition();
                }
            });

            sttRecognitionInstance.addEventListener('end', () => {
                // No interim text to clean up - final results only!
                
                // For continuous long sessions, auto-restart unless manually stopped
                if (sttIsRecording) {
                    // Update button to show restarting
                    const sttButton = document.querySelector('.ql-stt-button');
                    if (sttButton) {
                        sttButton.innerHTML = '⟳';
                        sttButton.title = 'Restarting recognition...';
                    }
                    
                    // Small delay before restart to prevent rapid cycling
                    setTimeout(() => {
                        if (sttIsRecording && scriptQuill) {
                            try {
                                sttRecognitionInstance.start();
                            } catch (error) {
                                console.error('Failed to restart speech recognition:', error);
                                showToast('Speech recognition stopped. Click microphone to restart.', false);
                                cleanupSpeechRecognition();
                            }
                        }
                    }, 500);
                } else {
                    cleanupSpeechRecognition();
                }
            });

            // Set up auto-restart interval for long sessions (20-40 minutes)
            // This prevents browser-level timeouts while maintaining continuous recording
            sttAutoRestartTimeoutId = setInterval(() => {
                if (sttIsRecording && sttRecognitionInstance) {
                    // Performing scheduled restart to maintain continuity
                    try {
                        sttRecognitionInstance.stop(); // This will trigger 'end' event and auto-restart
                    } catch (error) {
                        console.warn('Error during scheduled STT restart:', error);
                    }
                }
            }, STT_AUTO_RESTART_INTERVAL_MS);

            try {
                sttRecognitionInstance.start();
                // Processing indicator is already set, will be updated on start event
            } catch (error) {
                console.error('Failed to start speech recognition:', error);
                showToast('Failed to start speech recognition. Please try again.', false);
                cleanupSpeechRecognition();
            }
        }

        function createQuillEditorWithSpeech() {
            const toolbarOptions = [...SCRIPT_EDITOR_CONSTANTS.TOOLBAR_OPTIONS, ['stt-button']];
            
            // Initialize Quill editor using constants
            scriptQuill = new Quill('#scriptEditor', {
                theme: 'snow',
                modules: {
                    toolbar: {
                        container: toolbarOptions,
                        handlers: {
                            'stt-button': handleSpeechRecognition
                        }
                    }
                }
            });

            // Add our custom button with accessibility attributes
            const sttButton = document.querySelector('.ql-stt-button');
            if (sttButton) {
                sttButton.innerHTML = '🎤';
                sttButton.setAttribute('title', 'Start speech-to-text recording');
                sttButton.setAttribute('aria-label', 'Speech-to-text recording');
                sttButton.setAttribute('role', 'button');
                sttButton.setAttribute('tabindex', '0');
            }

            console.log('Script Quill editor initialized successfully');
            
            // DIAGNOSTIC: Check toolbar count after initialization
            const postInitToolbars = document.querySelectorAll('.ql-toolbar').length;
            const scriptEditorToolbars = document.querySelectorAll('#scriptEditor .ql-toolbar').length;
            console.log(`Post-initialization toolbar count: ${postInitToolbars} total, ${scriptEditorToolbars} in script editor`);
            
            if (postInitToolbars > 1) {
                console.warn(`WARNING: Found ${postInitToolbars} toolbars after initialization - toolbar duplication detected!`);
                // Log details of each toolbar for debugging
                document.querySelectorAll('.ql-toolbar').forEach((toolbar, index) => {
                    console.warn(`Toolbar ${index + 1}:`, {
                        parent: toolbar.parentElement?.id || 'unknown',
                        classes: Array.from(toolbar.classList),
                        location: toolbar.parentElement?.outerHTML?.substring(0, 100) || 'unknown'
                    });
                });
            } else if (postInitToolbars === 1) {
                console.log('✓ Toolbar duplication fix successful: exactly 1 toolbar found');
            } else {
                console.error('ERROR: No toolbars found after initialization - this should not happen');
            }

            // Load existing content for current observation
            loadScriptContent();

            // Auto-save on content change (STT-aware)
            scriptQuill.on('text-change', function(delta, oldDelta, source) {
                if (source === 'user') {
                    isScriptDirty = true;
                    updateSaveButtonState();
                    clearTimeout(scriptSaveDebounceTimer);
                    
                    // Coordinate with STT: Extend debounce time if actively recording
                    const debounceTime = sttIsRecording ? SILENT_SAVE_DEBOUNCE_MS * 2 : SILENT_SAVE_DEBOUNCE_MS;
                    
                    scriptSaveDebounceTimer = setTimeout(() => {
                        // No interim text to worry about - just save!
                        silentSaveScriptContent();
                    }, debounceTime);
                }
            });
        }

        function initializeQuillWithSpeech() {
            try {
                console.log('Creating new Quill instance on clean container...');
                createQuillEditorWithSpeech();

            } catch (error) {
                console.error('Error initializing script editor:', error);

                // If initialization fails, try emergency reset and retry ONCE
                console.log('Attempting emergency reset and retry...');
                resetScriptEditorContainer();

                try {
                    createQuillEditorWithSpeech();

                } catch (retryError) {
                    console.error('Script editor initialization failed even after reset:', retryError);
                    showToast('Failed to initialize script editor: ' + retryError.message, false);
                    modal.style.display = 'none';
                    return;
                }
            }
        }

        function openScriptEditor() {
            // Validate observation context before opening
            if (!currentObservationId) {
                showToast('Cannot open script editor: No active observation', false);
                console.error('Cannot open script editor: No active observation context');
                return;
            }
            
            if (!currentObservedUser.email) {
                showToast('Cannot open script editor: Invalid observation context', false);
                console.error('Cannot open script editor: Invalid observed user context');
                return;
            }
            
            // Opening script editor
            
            // Run diagnostics to check for any state issues
            diagnoseAndRecoverObservationState();
            
            const modal = document.getElementById('scriptEditorModal');
            const loadingOverlay = document.getElementById('scriptEditorLoadingOverlay');

            modal.style.display = 'flex';
            loadingOverlay.style.display = 'flex'; // Show loading overlay immediately
            document.body.style.overflow = 'hidden'; // Prevent background scrolling

            // Disable existing Quill editor if it exists to prevent interaction during loading
            if (scriptQuill) {
                scriptQuill.disable();
            }

            // Clear any pending auto-save timer when opening editor
            clearTimeout(scriptSaveDebounceTimer);

            if (!scriptQuill) {
                // DEFENSIVE CHECK: Ensure container is clean before creating new Quill instance
                const container = document.getElementById('scriptEditor');
                if (!container) {
                    console.error('Script editor container not found');
                    showToast('Script editor container not found', false);
                    modal.style.display = 'none';
                    return;
                }
                
                // ENHANCED CLEANUP: Check for toolbar duplication issues before initialization
                
                // 1. Check for leftover Quill elements in container
                const hasQuillElements = container.querySelector('.ql-toolbar, .ql-container, .ql-editor');
                if (hasQuillElements) {
                    console.warn('Found leftover Quill elements in container, cleaning up...');
                    resetScriptEditorContainer();
                }
                
                // 2. Check for orphaned toolbars globally (main fix for toolbar duplication)
                const globalToolbars = document.querySelectorAll('.ql-toolbar').length;
                if (globalToolbars > 0) {
                    console.warn(`Found ${globalToolbars} orphaned toolbars globally, performing global cleanup...`);
                    removeOrphanedQuillElements();
                }
                
                // 3. Check for any Quill-related classes or attributes on container
                if (container.classList.length > 0 || container.hasAttribute('data-quill')) {
                    console.warn('Container has Quill-related attributes, resetting...');
                    resetScriptEditorContainer();
                }
                
                // 4. Final diagnostic before initialization
                const finalToolbarCount = document.querySelectorAll('.ql-toolbar').length;
                if (finalToolbarCount > 0) {
                    console.warn(`Warning: Still found ${finalToolbarCount} toolbars after cleanup - this may cause duplication`);
                } else {
                    console.log('Pre-initialization cleanup complete - no existing toolbars found');
                }

                initializeQuillWithSpeech();

            } else {
                // Ensure existing editor has the right content for current observation
                // Reusing existing script editor
                loadScriptContent();
            }
            
            isScriptDirty = false;
            updateSaveButtonState();
        }

        async function closeScriptEditor() {
            // CRITICAL: Auto-save content before closing if STT is running or content is dirty
            if (sttIsRecording || isScriptDirty) {
                // Auto-saving content before closing
                
                try {
                    // Force save the current content
                    const success = await saveScriptContent();
                    if (success) {
                        showToast('Script content auto-saved before closing', true);
                    } else {
                        console.warn('Auto-save failed, prompting user');
                        if (!confirm('Failed to auto-save changes. Close anyway and lose changes?')) {
                            return;
                        }
                    }
                } catch (error) {
                    console.error('Error during auto-save:', error);
                    if (!confirm('Error saving changes. Close anyway and lose changes?')) {
                        return;
                    }
                }
            }
            
            // Clear any pending auto-save timer
            clearTimeout(scriptSaveDebounceTimer);
            
            // CRITICAL: Clean up speech recognition when closing editor
            cleanupSpeechRecognition();
            
            const modal = document.getElementById('scriptEditorModal');
            modal.style.display = 'none';
            document.body.style.overflow = ''; // Restore background scrolling

            // Hide loading overlay if still visible
            hideScriptEditorLoading();
            
            isScriptDirty = false;
        }

        function manualSaveScriptContent() {
            if (!scriptQuill || !currentObservationId || isSavingScript) return;

            showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SAVING, false);
            saveScriptContent().then(success => {
                if (success) {
                    showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SAVED, true);
                }
            }).catch(error => {
                // Log errors, but don't show a toast as saveScriptContent already does.
                console.warn("Could not manually save script:", error.message);
            });
        }

        function silentSaveScriptContent() {
            if (!scriptQuill || !currentObservationId || !isScriptDirty || isSavingScript) return;
            // Auto-saving script content
            saveScriptContent().catch(error => {
                // Silent saves should not bother the user, so just log.
                console.warn("Could not silently save script:", error.message);
            });
        }

        function saveScriptContent() {
            return new Promise((resolve, reject) => {
                if (isSavingScript) {
                    reject(new Error('A save operation is already in progress.'));
                    return;
                }
                if (!scriptQuill || !currentObservationId) {
                    reject(new Error('Quill editor or observation ID is not available.'));
                    return;
                }

                isSavingScript = true;
                const content = scriptQuill.getContents();
                scriptContent = content; // Keep local copy

                google.script.run
                    .withSuccessHandler(function(result) {
                        isSavingScript = false;
                        if (result.success) {
                            isScriptDirty = false;
                            updateSaveButtonState();
                            resolve(true);
                        } else {
                            console.error('Failed to save script content:', result.error);
                            showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.ERROR_SAVING + result.error, false);
                            reject(new Error(result.error || 'Unknown save error'));
                        }
                    })
                    .withFailureHandler(function(error) {
                        isSavingScript = false;
                        console.error('Error saving script content:', error);
                        showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.SERVER_ERROR + error.message, false);
                        reject(error);
                    })
                    .updateObservationScript(currentObservationId, content);
            });
        }

        function hideScriptEditorLoading() {
            const loadingOverlay = document.getElementById('scriptEditorLoadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.style.display = 'none';
            }
            
            // Re-enable the Quill editor
            if (scriptQuill) {
                scriptQuill.enable();
            }
            
            // FINAL DIAGNOSTIC: Verify toolbar duplication fix after editor is fully loaded
            const finalToolbarCount = document.querySelectorAll('.ql-toolbar').length;
            const sttButtonCount = document.querySelectorAll('.ql-stt-button').length;
            
            console.log(`Script editor fully loaded - Final toolbar check: ${finalToolbarCount} toolbars, ${sttButtonCount} STT buttons`);
            
            if (finalToolbarCount > 1) {
                console.error(`TOOLBAR DUPLICATION DETECTED: ${finalToolbarCount} toolbars found after editor load`);
            } else if (sttButtonCount === 0) {
                console.warn('Warning: STT button not found - microphone functionality may be missing from toolbar');
            } else if (sttButtonCount > 1) {
                console.warn(`Warning: Multiple STT buttons found (${sttButtonCount}) - duplicate functionality detected`);
            } else {
                console.log('✓ Script editor loaded successfully with single toolbar and STT button');
            }
        }

        // Clean up old session storage backups to prevent memory bloat
        function cleanupOldSessionBackups() {
            // Check if sessionStorage is available
            if (typeof Storage === 'undefined' || !window.sessionStorage) {
                console.warn('SessionStorage is not available in this browser');
                return;
            }

            try {
                const keysToRemove = [];
                const maxAge = 30 * 60 * 1000; // 30 minutes
                const now = Date.now();
                
                // Get all keys first to avoid issues with changing storage during iteration
                const allKeys = [];
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i);
                    if (key && key.startsWith('script_backup_')) {
                        allKeys.push(key);
                    }
                }
                
                // Process each backup key
                allKeys.forEach(key => {
                    try {
                        const item = sessionStorage.getItem(key);
                        if (!item) {
                            keysToRemove.push(key);
                            return;
                        }

                        const data = JSON.parse(item);
                        if (!data || !data.timestamp || typeof data.timestamp !== 'number') {
                            // Invalid backup data structure, mark for removal
                            keysToRemove.push(key);
                        } else if ((now - data.timestamp) > maxAge) {
                            // Expired backup, mark for removal
                            keysToRemove.push(key);
                        }
                    } catch (parseError) {
                        // JSON parse failed, invalid backup data - mark for removal
                        console.warn(`Invalid session backup data for key ${key}:`, parseError.message);
                        keysToRemove.push(key);
                    }
                });
                
                // Remove old/invalid backups safely
                keysToRemove.forEach(key => {
                    try {
                        sessionStorage.removeItem(key);
                    } catch (removeError) {
                        console.warn(`Failed to remove session backup key ${key}:`, removeError.message);
                    }
                });
                
                if (keysToRemove.length > 0) {
                    // Cleaned up session storage backups
                }
                
                // Check for storage quota issues
                try {
                    const testKey = 'storage_test_' + Date.now();
                    sessionStorage.setItem(testKey, 'test');
                    sessionStorage.removeItem(testKey);
                } catch (quotaError) {
                    if (quotaError.name === 'QuotaExceededError' || quotaError.name === 'QUOTA_EXCEEDED_ERR') {
                        console.warn('SessionStorage quota exceeded - consider clearing more data');
                    }
                }
                
            } catch (error) {
                console.warn('Error during session storage cleanup:', error.message);
                
                // If there's a critical error, try a more aggressive cleanup
                if (error.name === 'SecurityError' || error.name === 'InvalidAccessError') {
                    console.warn('SessionStorage access denied - backup features may not work');
                } else {
                    // Try to clear at least some backup keys if possible
                    try {
                        const keys = Object.keys(sessionStorage).filter(key => key.startsWith('script_backup_'));
                        if (keys.length > 10) { // If too many backups, clear half
                            keys.slice(0, Math.floor(keys.length / 2)).forEach(key => {
                                try { sessionStorage.removeItem(key); } catch (e) { /* ignore */ }
                            });
                            // Emergency cleanup performed
                        }
                    } catch (emergencyError) {
                        // Complete failure - disable backup features
                        console.error('Complete session storage failure - backup features disabled');
                    }
                }
            }
        }

        function loadScriptContent() {
            if (!currentObservationId) {
                console.warn('Cannot load script content: currentObservationId is not set');
                hideScriptEditorLoading(); // Hide loading on error
                return;
            }
            
            // Validate that we have a valid observation context
            if (!currentObservedUser.email) {
                console.warn('Cannot load script content: No observed user context');
                hideScriptEditorLoading(); // Hide loading on error
                return;
            }
            
            // Loading script content
            
            google.script.run
                .withSuccessHandler(function(content) {
                    // Double-check that we still have the same observation ID (prevent race conditions)
                    if (!scriptQuill || !currentObservationId) {
                        console.warn('Script editor or observation context lost during load');
                        return;
                    }
                    
                    console.log('Script content loaded successfully', { 
                        observationId: currentObservationId,
                        hasContent: !!(content && typeof content === 'object' && Object.keys(content).length > 0)
                    });
                    
                    // Clean up old session storage backups
                    cleanupOldSessionBackups();
                    
                    // Check for sessionStorage backup first (in case of unexpected closure)
                    const backupKey = `script_backup_${currentObservationId}`;
                    const backup = sessionStorage.getItem(backupKey);
                    let useBackup = false;
                    
                    if (backup) {
                        try {
                            const backupData = JSON.parse(backup);
                            const backupAge = Date.now() - backupData.timestamp;
                            const maxAge = 30 * 60 * 1000; // 30 minutes
                            
                            if (backupAge < maxAge) {
                                const useBackupResponse = confirm(
                                    'Found unsaved script content from a previous session. ' +
                                    'This might contain speech-to-text data that wasn\'t saved. ' +
                                    'Do you want to restore it?'
                                );
                                
                                if (useBackupResponse) {
                                    scriptQuill.setContents(backupData.content, 'silent');
                                    scriptContent = backupData.content;
                                    isScriptDirty = true; // Mark as dirty so user can save
                                    useBackup = true;
                                    showToast('Restored unsaved script content from previous session', true);
                                    // Restored from backup
                                }
                            }
                            
                            // Clean up old backup
                            sessionStorage.removeItem(backupKey);
                            
                        } catch (error) {
                            console.error('Error processing sessionStorage backup:', error);
                            sessionStorage.removeItem(backupKey);
                        }
                    }
                    
                    if (!useBackup) {
                        if (content && typeof content === 'object' && Object.keys(content).length > 0) {
                            scriptQuill.setContents(content, 'silent');
                            scriptContent = content;
                        } else {
                            // Load empty content for new observations
                            scriptQuill.setContents([], 'silent');
                            scriptContent = {};
                        }
                    }
                    isScriptDirty = false;
                    updateSaveButtonState();
                    
                    // Hide loading overlay and re-enable editor
                    hideScriptEditorLoading();

                    // Load component tags and restore highlighting AFTER content is loaded
                    // Small delay to ensure Quill content is fully processed
                    setTimeout(() => {
                        loadComponentTags();
                        // Initialize script editor mode system AFTER everything is loaded
                        initializeScriptEditorMode();
                    }, 50);
                })
                .withFailureHandler(function(error) {
                    console.error('Error loading script content:', error);
                    showToast(SCRIPT_EDITOR_CONSTANTS.UI_STRINGS.LOAD_ERROR + error.message, false);
                    
                    // Clear script editor on error to prevent showing wrong content
                    if (scriptQuill) {
                        scriptQuill.setContents([], 'silent');
                        scriptContent = {};
                        isScriptDirty = false;
                        updateSaveButtonState();
                    }
                    
                    // Hide loading overlay and re-enable editor even on error
                    hideScriptEditorLoading();
                })
                .getObservationScript(currentObservationId);
        }


        // === Component Tagging System ===
        let componentTags = {};
        const TAG_COLORS = {
            '1a:': '#e3f2fd', '1b:': '#f3e5f5', '1c:': '#e8f5e8', '1d:': '#fff3e0',
            '1e:': '#fce4ec', '1f:': '#e0f2f1', '2a:': '#e1f5fe', '2b:': '#f1f8e9',
            '2c:': '#fef7e0', '2d:': '#ede7f6', '2e:': '#fcf2ff', '3a:': '#e8eaf6',
            '3b:': '#f9fbe7', '3c:': '#fff8e1', '3d:': '#ffebee', '4a:': '#e0f7fa',
            '4b:': '#f0f4c3', '4c:': '#ffe0b2', '4d:': '#d1c4e9', '4e:': '#ffcdd2',
            '4f:': '#b2dfdb'
        };

        function populateComponentSelector() {
            const selector = document.getElementById('componentSelector');
            if (!selector) {
                console.warn('Component selector element not found');
                return;
            }
            
            // Check if rubric data is available (using the same source as the main rubric)
            if (window.rubricData && window.rubricData.domains && window.rubricData.domains.length > 0) {
                // Data is available, populate the selector
                selector.innerHTML = '<option value="">Select Component to Tag</option>';
                
                let hasComponents = false;
                window.rubricData.domains.forEach(domain => {
                    if (domain.components && domain.components.length > 0) {
                        domain.components.forEach(component => {
                            // Only show assigned components to match main rubric behavior
                            if (component.isAssigned) {
                                const option = document.createElement('option');
                                option.value = component.componentId;
                                option.textContent = `${domain.name}: ${component.title}`;
                                selector.appendChild(option);
                                hasComponents = true;
                            }
                        });
                    }
                });
                
                if (!hasComponents) {
                    selector.innerHTML = '<option value="">No components available</option>';
                    console.warn('Rubric data exists but contains no components');
                }
            } else {
                // Rubric data not available - this should not happen if called after rubric is loaded
                selector.innerHTML = '<option value="">Rubric data not loaded</option>';
                console.warn('Component selector called but rubric data not available:', {
                    hasWindow: typeof window !== 'undefined',
                    hasRubricData: !!window.rubricData,
                    hasDomains: window.rubricData && !!window.rubricData.domains,
                    domainsLength: window.rubricData && window.rubricData.domains ? window.rubricData.domains.length : 'N/A'
                });
            }
        }

        function tagSelectedText() {
            if (!scriptQuill) {
                showToast('Script editor not initialized', false);
                return;
            }
            
            const range = scriptQuill.getSelection();
            if (!range || range.length === 0) {
                showToast('Please select text to tag', false);
                return;
            }
            
            const componentId = document.getElementById('componentSelector').value;
            if (!componentId) {
                showToast('Please select a component', false);
                return;
            }
            
            // Get the selected text
            const selectedText = scriptQuill.getText(range.index, range.length);
            if (!selectedText.trim()) {
                showToast('Selected text is empty', false);
                return;
            }
            
            // Apply visual formatting to tagged text
            const tagColor = TAG_COLORS[componentId] || '#e3f2fd';
            scriptQuill.formatText(range.index, range.length, 'background', tagColor);
            scriptQuill.formatText(range.index, range.length, 'color', '#1565c0');
            
            // Store tag information
            const tagData = {
                componentId: componentId,
                start: range.index,
                length: range.length,
                text: selectedText.trim(),
                timestamp: new Date().toISOString(),
                color: tagColor
            };
            
            if (!componentTags[componentId]) {
                componentTags[componentId] = [];
            }
            componentTags[componentId].push(tagData);
            
            // Update status
            document.getElementById('tagStatus').textContent = 
                `Tagged "${selectedText.substring(0, 30)}${selectedText.length > 30 ? '...' : ''}" to ${componentId}`;
            
            // Save tags
            saveComponentTags();
            
            showToast('Text tagged successfully', true);
        }

        function pushTaggedToNotes() {
            const allTags = Object.keys(componentTags);
            if (allTags.length === 0) {
                showToast('No tagged evidence to push.', false);
                return;
            }

            let pushedCount = 0;
            allTags.forEach(componentId => {
                const tags = componentTags[componentId];
                if (tags && tags.length > 0) {
                    let notesEditor = window.globalQuillInstances && window.globalQuillInstances[componentId];
                    if (!notesEditor) {
                        const evidenceSectionId = `evidence-${componentId}`;
                        const evidenceSection = document.getElementById(evidenceSectionId);
                        if (evidenceSection) {
                            toggleEvidenceSection(evidenceSectionId);
                            const attemptPush = (retries = 8) => { // Increased retries
                                if (retries <= 0) {
                                    console.warn(`Could not initialize notes editor for ${componentId} after multiple attempts.`);
                                    showToast(`Could not push to ${componentId} notes - editor initialization failed`, false);
                                    return;
                                }
                                
                                // Try to force initialization if editor doesn't exist
                                if (!window.globalQuillInstances[componentId]) {
                                    console.log(`Attempting to force initialize editor for ${componentId}, retries left: ${retries}`);
                                    window.initializeQuillEditor(componentId);
                                }
                                
                                notesEditor = window.globalQuillInstances && window.globalQuillInstances[componentId];
                                if (notesEditor) {
                                    completePushToNotes(componentId, tags, notesEditor);
                                } else {
                                    setTimeout(() => attemptPush(retries - 1), 300); // Increased delay
                                }
                            };
                            attemptPush();
                        } else {
                            console.warn(`Evidence section not found for ${componentId}.`);
                            showToast(`Could not find notes section for ${componentId}`, false);
                        }
                    } else {
                        completePushToNotes(componentId, tags, notesEditor);
                    }
                    pushedCount++;
                }
            });

            if (pushedCount > 0) {
                showToast(`Pushed all tagged evidence to their respective notes sections.`, true);
                document.getElementById('tagStatus').textContent = `Pushed all tagged evidence to notes.`;
            } else {
                showToast('No tagged evidence to push.', false);
            }
        }
        
        function completePushToNotes(componentId, tags, notesEditor) {
            // Combine all tagged text for this component
            const taggedContent = tags.map(tag => tag.text).join('\n\n');
            
            // Get current notes content
            const currentContent = notesEditor.root.innerHTML;
            const separator = currentContent && currentContent !== '<p><br></p>' ? '\n\n' : '';
            const scriptHeader = '<p><strong>From Script:</strong></p>';
            const newContent = currentContent + separator + scriptHeader + '<p>' + taggedContent.replace(/\n/g, '</p><p>') + '</p>';
            
            // Update notes editor
            notesEditor.root.innerHTML = newContent;
            
            // Trigger save
            setTimeout(() => {
                const event = new Event('input', { bubbles: true });
                notesEditor.root.dispatchEvent(event);
            }, 100);
            
            document.getElementById('tagStatus').textContent = 
                `Pushed ${tags.length} tagged item(s) to ${componentId} notes`;
            
            showToast(`Tagged content added to ${componentId} notes`, true);
        }

        function clearComponentTags() {
            const componentId = document.getElementById('componentSelector').value;
            if (!componentId) {
                // Clear all tags
                if (confirm('Clear all component tags from the script?')) {
                    componentTags = {};
                    // Remove all formatting - this is a simplified approach
                    if (scriptQuill) {
                        const length = scriptQuill.getLength();
                        scriptQuill.removeFormat(0, length);
                    }
                    saveComponentTags();
                    document.getElementById('tagStatus').textContent = 'All tags cleared';
                    showToast('All tags cleared', true);
                }
            } else {
                // Clear tags for specific component
                if (componentTags[componentId] && componentTags[componentId].length > 0) {
                    if (confirm(`Clear all tags for component ${componentId}?`)) {
                        delete componentTags[componentId];
                        saveComponentTags();
                        document.getElementById('tagStatus').textContent = `Tags cleared for ${componentId}`;
                        showToast(`Tags cleared for ${componentId}`, true);
                    }
                }
            }
        }

        function saveComponentTags() {
            if (!currentObservationId) return;
            
            google.script.run
                .withSuccessHandler(function(result) {
                    if (result.success) {
                        console.log('Component tags saved successfully');
                    } else {
                        console.error('Failed to save component tags:', result.error);
                        showToast('Failed to save tags: ' + result.error, false);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Error saving component tags:', error);
                    showToast('Error saving tags: ' + error.message, false);
                })
                .saveComponentTags(currentObservationId, componentTags);
        }

        function loadComponentTags() {
            if (!currentObservationId) return;
            
            google.script.run
                .withSuccessHandler(function(tags) {
                    if (tags) {
                        componentTags = tags;
                        // Restore visual formatting for tagged text
                        restoreVisualHighlighting();
                        console.log('Component tags loaded:', componentTags);
                    }
                })
                .withFailureHandler(function(error) {
                    console.error('Error loading component tags:', error);
                })
                .getComponentTags(currentObservationId);
        }

        function restoreVisualHighlighting() {
            if (!scriptQuill || !componentTags) {
                // Cannot restore highlighting - missing dependencies
                return;
            }

            // Ensure Quill is ready and has content
            if (!scriptQuill.getLength || scriptQuill.getLength() <= 1) {
                console.log('Script editor has no content, skipping highlight restoration');
                return;
            }

            console.log('Restoring visual highlighting for tagged components...');
            const documentLength = scriptQuill.getLength() - 1; // Exclude final newline
            let restoredCount = 0;
            
            // Iterate through all component tags and restore their visual formatting
            Object.keys(componentTags).forEach(componentId => {
                const tags = componentTags[componentId];
                if (tags && Array.isArray(tags)) {
                    tags.forEach((tag, tagIndex) => {
                        if (tag.start !== undefined && tag.length !== undefined) {
                            // Validate tag position against document length
                            if (tag.start < 0 || tag.start >= documentLength || 
                                tag.start + tag.length > documentLength) {
                                console.warn(`Skipping invalid tag position for ${componentId}[${tagIndex}]: start=${tag.start}, length=${tag.length}, docLength=${documentLength}`);
                                return;
                            }
                            
                            const tagColor = tag.color || TAG_COLORS[componentId] || '#e3f2fd';
                            try {
                                // Apply the background color and text color formatting
                                scriptQuill.formatText(tag.start, tag.length, 'background', tagColor);
                                scriptQuill.formatText(tag.start, tag.length, 'color', '#1565c0');
                                restoredCount++;
                                console.log(`Restored highlighting for ${componentId}[${tagIndex}] at position ${tag.start}-${tag.start + tag.length}`);
                            } catch (error) {
                                console.warn(`Failed to restore highlighting for ${componentId}[${tagIndex}] at position ${tag.start}:`, error);
                            }
                        } else {
                            console.warn(`Invalid tag data for ${componentId}[${tagIndex}]:`, tag);
                        }
                    });
                }
            });
            
            console.log(`Visual highlighting restoration completed: ${restoredCount} tags restored`);
        }

        // Extend the openScriptEditor function to initialize component selector
        const originalOpenScriptEditor = openScriptEditor;
        openScriptEditor = function() {
            originalOpenScriptEditor();
            // Populate component selector immediately (no race condition)
            populateComponentSelector();
            // loadComponentTags() will be called after content loads to prevent race condition
        };
    </script>

    <!-- Loading Overlay -->
    <div class="loading" id="loading">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">Loading...</div>
        </div>
    </div>

    <!-- Script Editor Modal -->
    <div class="script-editor-modal" id="scriptEditorModal" style="display: none;">
        <div class="script-editor-container">
            <!-- Loading overlay -->
            <div class="script-editor-loading-overlay" id="scriptEditorLoadingOverlay" style="display: none;">
                <div class="script-editor-loading-spinner"></div>
                <div class="script-editor-loading-text">Loading script content...</div>
            </div>
            
            <div class="script-editor-header">
                <h2>Observation Script Editor</h2>

                <!-- Mode Toggle Buttons -->
                <div class="script-editor-mode-toggle" id="scriptEditorModeToggle" style="display: none;">
                    <button id="viewModeBtn" class="mode-toggle-btn active" onclick="switchToViewMode()">
                        📖 View Staff Responses
                    </button>
                    <button id="editModeBtn" class="mode-toggle-btn" onclick="switchToEditMode()">
                        ✏️ Edit & Tag Content
                    </button>
                </div>

                <div class="script-editor-controls">
                    <button id="saveScriptBtn" class="btn-secondary" onclick="manualSaveScriptContent()" disabled>Saved!</button>
                    <button class="btn-secondary" onclick="closeScriptEditor()">Close</button>
                </div>
            </div>
            
            <!-- Component Tagging Toolbar -->
            <div class="script-tagging-toolbar">
                <div class="tagging-controls">
                    <select id="componentSelector" class="component-selector">
                        <option value="">Select Component to Tag</option>
                    </select>
                    <button class="btn-tag" onclick="tagSelectedText()">🏷️ Tag Selection</button>
                    <button class="btn-push" onclick="pushTaggedToNotes()">➡️ Push Tagged to Notes</button>
                    <button class="btn-clear-tags" onclick="clearComponentTags()">🗑️ Clear Tags</button>
                </div>
                <div class="tag-status" id="tagStatus">
                    Select text and choose a component to create tags
                </div>
            </div>
            
            <div class="script-editor-content">
                <div id="scriptEditor"></div>
            </div>
        </div>
    </div>

    <!-- Transcription Results Modal -->
    <div class="welcome-modal-overlay" id="transcriptionModalOverlay" style="display: none;">
        <div class="welcome-modal" id="transcriptionModal" style="max-width: 900px;">
            <div class="welcome-modal-header">
                <div class="welcome-modal-icon">⭐</div>
                <h1>AI Transcription Results</h1>
                <p class="welcome-subtitle" id="transcriptionSubtitle">Enhanced transcription with component tagging</p>
            </div>

            <div class="welcome-modal-content" style="max-height: 60vh; overflow-y: auto;">
                <!-- Transcription Metadata -->
                <div class="transcription-metadata" id="transcriptionMetadata" style="background: #f8fafc; padding: 15px; border-radius: 8px; margin-bottom: 20px; font-size: 0.9rem; color: #4a5568;">
                    <!-- Metadata will be populated by JavaScript -->
                </div>

                <!-- Component Tags Section -->
                <div class="transcription-section" id="componentTagsSection" style="margin-bottom: 25px;">
                    <h3 style="color: #2d3748; margin-bottom: 15px; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                        🏷️ Component Tags
                    </h3>
                    <div id="componentTagsContent" style="background: #f7fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px;">
                        <!-- Component tags will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Full Transcription Section -->
                <div class="transcription-section">
                    <h3 style="color: #2d3748; margin-bottom: 15px; font-size: 1.1rem; display: flex; align-items: center; gap: 8px;">
                        📝 Full Transcription
                    </h3>
                    <div id="transcriptionContent" style="background: white; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; line-height: 1.6; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; white-space: pre-wrap; max-height: 400px; overflow-y: auto;">
                        <!-- Transcription content will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <div class="welcome-modal-footer" style="display: flex; gap: 12px; justify-content: center; align-items: center;">
                <button class="btn-secondary" onclick="copyTranscriptionToClipboard()" style="display: flex; align-items: center; gap: 6px;">
                    📋 Copy to Clipboard
                </button>
                <button class="btn-primary" id="insertScriptBtn" onclick="insertTranscriptionIntoScript()" style="display: none; align-items: center; gap: 6px;">
                    ➡️ Insert into Script
                </button>
                <button class="welcome-continue-btn" onclick="closeTranscriptionModal()" style="background: #4a5568;">
                    <span class="btn-icon">✖️</span>
                    Close
                </button>
            </div>
        </div>
    </div>
</body>
</html>